diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/atomic.h linux-2.6.30.9-rsdk/arch/mips/include/asm/atomic.h
--- linux-2.6.30.9/arch/mips/include/asm/atomic.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/atomic.h	2011-12-05 15:50:14.000000000 +0000
@@ -9,18 +9,30 @@
  * License.  See the file "COPYING" in the main directory of this archive
  * for more details.
  *
- * Copyright (C) 1996, 97, 99, 2000, 03, 04, 06 by Ralf Baechle
+ * Copyright (C) 1996, 97, 99, 2000, 03, 04 by Ralf Baechle
  */
+
+/*
+ * As workaround for the ATOMIC_DEC_AND_LOCK / atomic_dec_and_lock mess in
+ * <linux/spinlock.h> we have to include <linux/spinlock.h> outside the
+ * main big wrapper ...
+ */
+#include <linux/spinlock.h>
+
 #ifndef _ASM_ATOMIC_H
 #define _ASM_ATOMIC_H
 
 #include <linux/irqflags.h>
-#include <linux/types.h>
-#include <asm/barrier.h>
 #include <asm/cpu-features.h>
 #include <asm/war.h>
-#include <asm/system.h>
 
+//typedef struct { volatile int counter; } atomic_t;
+//
+#if 0
+typedef struct {
+	volatile int counter;
+} atomic_t;
+#endif
 #define ATOMIC_INIT(i)    { (i) }
 
 /*
@@ -49,8 +61,9 @@
  */
 static __inline__ void atomic_add(int i, atomic_t * v)
 {
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -62,27 +75,27 @@
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	ll	%0, %1		# atomic_add		\n"
 		"	addu	%0, %2					\n"
 		"	sc	%0, %1					\n"
-		"	beqz	%0, 2f					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	beqz	%0, 1b					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		v->counter += i;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
+#endif
 }
 
 /*
@@ -94,8 +107,9 @@
  */
 static __inline__ void atomic_sub(int i, atomic_t * v)
 {
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -107,27 +121,27 @@
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	ll	%0, %1		# atomic_sub		\n"
 		"	subu	%0, %2					\n"
 		"	sc	%0, %1					\n"
-		"	beqz	%0, 2f					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	beqz	%0, 1b					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		v->counter -= i;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
+#endif
 }
 
 /*
@@ -135,12 +149,11 @@
  */
 static __inline__ int atomic_add_return(int i, atomic_t * v)
 {
-	int result;
-
-	smp_llsc_mb();
+	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -149,50 +162,49 @@
 		"	sc	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else if (cpu_has_llsc) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
-		"	beqz	%0, 2f					\n"
+		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		result = v->counter;
 		result += i;
 		v->counter = result;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return result;
 }
 
 static __inline__ int atomic_sub_return(int i, atomic_t * v)
 {
-	int result;
-
-	smp_llsc_mb();
+	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -201,38 +213,38 @@
 		"	sc	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else if (cpu_has_llsc) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	ll	%1, %2		# atomic_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	sc	%0, %2					\n"
-		"	beqz	%0, 2f					\n"
+		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		result = v->counter;
 		result -= i;
 		v->counter = result;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return result;
 }
@@ -247,12 +259,11 @@
  */
 static __inline__ int atomic_sub_if_positive(int i, atomic_t * v)
 {
-	int result;
-
-	smp_llsc_mb();
+	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -264,13 +275,14 @@
 		"	beqzl	%0, 1b					\n"
 		"	 subu	%0, %1, %3				\n"
 		"	.set	reorder					\n"
+		"	sync						\n"
 		"1:							\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else if (cpu_has_llsc) {
-		int temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -279,35 +291,34 @@
 		"	bltz	%0, 1f					\n"
 		"	sc	%0, %2					\n"
 		"	.set	noreorder				\n"
-		"	beqz	%0, 2f					\n"
+		"	beqz	%0, 1b					\n"
 		"	 subu	%0, %1, %3				\n"
 		"	.set	reorder					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	sync						\n"
 		"1:							\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		result = v->counter;
 		result -= i;
 		if (result >= 0)
 			v->counter = result;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return result;
 }
 
-#define atomic_cmpxchg(v, o, n) (cmpxchg(&((v)->counter), (o), (n)))
-#define atomic_xchg(v, new) (xchg(&((v)->counter), (new)))
+#define atomic_cmpxchg(v, o, n) ((int)cmpxchg(&((v)->counter), (o), (n)))
+#define atomic_xchg(v, new) (xchg(&((v)->counter), new))
 
 /**
  * atomic_add_unless - add unless the number is a given value
@@ -318,20 +329,14 @@
  * Atomically adds @a to @v, so long as it was not @u.
  * Returns non-zero if @v was not @u, and zero otherwise.
  */
-static __inline__ int atomic_add_unless(atomic_t *v, int a, int u)
-{
-	int c, old;
-	c = atomic_read(v);
-	for (;;) {
-		if (unlikely(c == (u)))
-			break;
-		old = atomic_cmpxchg((v), c, c + (a));
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return c != (u);
-}
+#define atomic_add_unless(v, a, u)				\
+({								\
+	int c, old;						\
+	c = atomic_read(v);					\
+	while (c != (u) && (old = atomic_cmpxchg((v), c, c + (a))) != c) \
+		c = old;					\
+	c != (u);						\
+})
 #define atomic_inc_not_zero(v) atomic_add_unless((v), 1, 0)
 
 #define atomic_dec_return(v) atomic_sub_return(1, (v))
@@ -403,6 +408,8 @@
 
 #ifdef CONFIG_64BIT
 
+typedef struct { volatile __s64 counter; } atomic64_t;
+
 #define ATOMIC64_INIT(i)    { (i) }
 
 /*
@@ -428,8 +435,9 @@
  */
 static __inline__ void atomic64_add(long i, atomic64_t * v)
 {
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -441,27 +449,27 @@
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	lld	%0, %1		# atomic64_add		\n"
 		"	addu	%0, %2					\n"
 		"	scd	%0, %1					\n"
-		"	beqz	%0, 2f					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	beqz	%0, 1b					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		v->counter += i;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
+#endif
 }
 
 /*
@@ -473,8 +481,9 @@
  */
 static __inline__ void atomic64_sub(long i, atomic64_t * v)
 {
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -486,27 +495,27 @@
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else if (cpu_has_llsc) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	lld	%0, %1		# atomic64_sub		\n"
 		"	subu	%0, %2					\n"
 		"	scd	%0, %1					\n"
-		"	beqz	%0, 2f					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	beqz	%0, 1b					\n"
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter));
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		v->counter -= i;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
+#endif
 }
 
 /*
@@ -514,12 +523,11 @@
  */
 static __inline__ long atomic64_add_return(long i, atomic64_t * v)
 {
-	long result;
-
-	smp_llsc_mb();
+	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -528,50 +536,49 @@
 		"	scd	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else if (cpu_has_llsc) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_add_return	\n"
 		"	addu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
-		"	beqz	%0, 2f					\n"
+		"	beqz	%0, 1b					\n"
 		"	addu	%0, %1, %3				\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		result = v->counter;
 		result += i;
 		v->counter = result;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return result;
 }
 
 static __inline__ long atomic64_sub_return(long i, atomic64_t * v)
 {
-	long result;
-
-	smp_llsc_mb();
+	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -580,38 +587,38 @@
 		"	scd	%0, %2					\n"
 		"	beqzl	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else if (cpu_has_llsc) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
 		"1:	lld	%1, %2		# atomic64_sub_return	\n"
 		"	subu	%0, %1, %3				\n"
 		"	scd	%0, %2					\n"
-		"	beqz	%0, 2f					\n"
+		"	beqz	%0, 1b					\n"
 		"	subu	%0, %1, %3				\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	sync						\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		result = v->counter;
 		result -= i;
 		v->counter = result;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return result;
 }
@@ -626,12 +633,11 @@
  */
 static __inline__ long atomic64_sub_if_positive(long i, atomic64_t * v)
 {
-	long result;
-
-	smp_llsc_mb();
+	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -643,13 +649,14 @@
 		"	beqzl	%0, 1b					\n"
 		"	 dsubu	%0, %1, %3				\n"
 		"	.set	reorder					\n"
+		"	sync						\n"
 		"1:							\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else if (cpu_has_llsc) {
-		long temp;
+		unsigned long temp;
 
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -658,63 +665,32 @@
 		"	bltz	%0, 1f					\n"
 		"	scd	%0, %2					\n"
 		"	.set	noreorder				\n"
-		"	beqz	%0, 2f					\n"
+		"	beqz	%0, 1b					\n"
 		"	 dsubu	%0, %1, %3				\n"
 		"	.set	reorder					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	sync						\n"
 		"1:							\n"
 		"	.set	mips0					\n"
 		: "=&r" (result), "=&r" (temp), "=m" (v->counter)
 		: "Ir" (i), "m" (v->counter)
 		: "memory");
 	} else {
+#endif
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		result = v->counter;
 		result -= i;
 		if (result >= 0)
 			v->counter = result;
-		raw_local_irq_restore(flags);
+		local_irq_restore(flags);
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return result;
 }
 
-#define atomic64_cmpxchg(v, o, n) \
-	((__typeof__((v)->counter))cmpxchg(&((v)->counter), (o), (n)))
-#define atomic64_xchg(v, new) (xchg(&((v)->counter), (new)))
-
-/**
- * atomic64_add_unless - add unless the number is a given value
- * @v: pointer of type atomic64_t
- * @a: the amount to add to v...
- * @u: ...unless v is equal to u.
- *
- * Atomically adds @a to @v, so long as it was not @u.
- * Returns non-zero if @v was not @u, and zero otherwise.
- */
-static __inline__ int atomic64_add_unless(atomic64_t *v, long a, long u)
-{
-	long c, old;
-	c = atomic64_read(v);
-	for (;;) {
-		if (unlikely(c == (u)))
-			break;
-		old = atomic64_cmpxchg((v), c, c + (a));
-		if (likely(old == c))
-			break;
-		c = old;
-	}
-	return c != (u);
-}
-
-#define atomic64_inc_not_zero(v) atomic64_add_unless((v), 1, 0)
-
 #define atomic64_dec_return(v) atomic64_sub_return(1, (v))
 #define atomic64_inc_return(v) atomic64_add_return(1, (v))
 
@@ -788,11 +764,10 @@
  * atomic*_return operations are serializing but not the non-*_return
  * versions.
  */
-#define smp_mb__before_atomic_dec()	smp_llsc_mb()
-#define smp_mb__after_atomic_dec()	smp_llsc_mb()
-#define smp_mb__before_atomic_inc()	smp_llsc_mb()
-#define smp_mb__after_atomic_inc()	smp_llsc_mb()
+#define smp_mb__before_atomic_dec()	smp_mb()
+#define smp_mb__after_atomic_dec()	smp_mb()
+#define smp_mb__before_atomic_inc()	smp_mb()
+#define smp_mb__after_atomic_inc()	smp_mb()
 
 #include <asm-generic/atomic.h>
-
 #endif /* _ASM_ATOMIC_H */
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/bitops.h linux-2.6.30.9-rsdk/arch/mips/include/asm/bitops.h
--- linux-2.6.30.9/arch/mips/include/asm/bitops.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/bitops.h	2011-12-05 15:50:14.000000000 +0000
@@ -57,10 +57,10 @@
  */
 static inline void set_bit(unsigned long nr, volatile unsigned long *addr)
 {
-	unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
+//	unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 	unsigned short bit = nr & SZLONG_MASK;
-	unsigned long temp;
-
+//	unsigned long temp;
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		__asm__ __volatile__(
 		"	.set	mips3					\n"
@@ -97,7 +97,9 @@
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (1UL << bit), "m" (*m));
-	} else {
+	} else 
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
@@ -122,8 +124,9 @@
  */
 static inline void clear_bit(unsigned long nr, volatile unsigned long *addr)
 {
-	unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 	unsigned short bit = nr & SZLONG_MASK;
+#if !defined(CONFIG_REALTEK_CPU)
+	unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 	unsigned long temp;
 
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
@@ -162,7 +165,9 @@
 		"	.set	mips0					\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (~(1UL << bit)), "m" (*m));
-	} else {
+	} else
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
@@ -202,6 +207,7 @@
 {
 	unsigned short bit = nr & SZLONG_MASK;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 		unsigned long temp;
@@ -231,7 +237,9 @@
 		"	.set	mips0				\n"
 		: "=&r" (temp), "=m" (*m)
 		: "ir" (1UL << bit), "m" (*m));
-	} else {
+	} else 
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
@@ -260,6 +268,7 @@
 
 	smp_llsc_mb();
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 		unsigned long temp;
@@ -296,7 +305,9 @@
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-	} else {
+	} else 
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
@@ -328,6 +339,7 @@
 	unsigned short bit = nr & SZLONG_MASK;
 	unsigned long res;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 		unsigned long temp;
@@ -364,7 +376,9 @@
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-	} else {
+	} else 
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
@@ -397,6 +411,7 @@
 
 	smp_llsc_mb();
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 		unsigned long temp;
@@ -453,7 +468,9 @@
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-	} else {
+	} else 
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
@@ -487,6 +504,7 @@
 
 	smp_llsc_mb();
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long *m = ((unsigned long *) addr) + (nr >> SZLONG_LOG);
 		unsigned long temp;
@@ -523,7 +541,9 @@
 		: "=&r" (temp), "=m" (*m), "=&r" (res)
 		: "r" (1UL << bit), "m" (*m)
 		: "memory");
-	} else {
+	} else
+#endif
+	{
 		volatile unsigned long *a = addr;
 		unsigned long mask;
 		unsigned long flags;
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/cmpxchg.h linux-2.6.30.9-rsdk/arch/mips/include/asm/cmpxchg.h
--- linux-2.6.30.9/arch/mips/include/asm/cmpxchg.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/cmpxchg.h	2011-12-05 15:50:14.000000000 +0000
@@ -12,6 +12,7 @@
 
 #define __HAVE_ARCH_CMPXCHG 1
 
+#if 0
 #define __cmpxchg_asm(ld, st, m, old, new)				\
 ({									\
 	__typeof(*(m)) __ret;						\
@@ -65,7 +66,69 @@
 									\
 	__ret;								\
 })
+#else
+static inline unsigned long __cmpxchg_asm(char *a, char* b, volatile int * m, unsigned long old,
+	unsigned long new)
+{
+	__u32 retval;
+
+#if !defined(CONFIG_REALTEK_CPU)
+	if (cpu_has_llsc && R10000_LLSC_WAR) {
+		__asm__ __volatile__(
+		"	.set	push					\n"
+		"	.set	noat					\n"
+		"	.set	mips3					\n"
+		"1:	ll	%0, %2			# __cmpxchg_u32	\n"
+		"	bne	%0, %z3, 2f				\n"
+		"	.set	mips0					\n"
+		"	move	$1, %z4					\n"
+		"	.set	mips3					\n"
+		"	sc	$1, %1					\n"
+		"	beqzl	$1, 1b					\n"
+#ifdef CONFIG_SMP
+		"	sync						\n"
+#endif
+		"2:							\n"
+		"	.set	pop					\n"
+		: "=&r" (retval), "=R" (*m)
+		: "R" (*m), "Jr" (old), "Jr" (new)
+		: "memory");
+	} else if (cpu_has_llsc) {
+		__asm__ __volatile__(
+		"	.set	push					\n"
+		"	.set	noat					\n"
+		"	.set	mips3					\n"
+		"1:	ll	%0, %2			# __cmpxchg_u32	\n"
+		"	bne	%0, %z3, 2f				\n"
+		"	.set	mips0					\n"
+		"	move	$1, %z4					\n"
+		"	.set	mips3					\n"
+		"	sc	$1, %1					\n"
+		"	beqz	$1, 1b					\n"
+#ifdef CONFIG_SMP
+		"	sync						\n"
+#endif
+		"2:							\n"
+		"	.set	pop					\n"
+		: "=&r" (retval), "=R" (*m)
+		: "R" (*m), "Jr" (old), "Jr" (new)
+		: "memory");
+	} else {
+#endif		
+		unsigned long flags;
 
+		local_irq_save(flags);
+		retval = *m;
+		if (retval == old)
+			*m = new;
+		local_irq_restore(flags);	/* implies memory barrier  */
+#if !defined(CONFIG_REALTEK_CPU)
+	}
+#endif
+
+	return retval;
+}
+#endif
 /*
  * This function doesn't exist, so you'll get a linker error
  * if something tries to do an invalid cmpxchg().
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/futex.h linux-2.6.30.9-rsdk/arch/mips/include/asm/futex.h
--- linux-2.6.30.9/arch/mips/include/asm/futex.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/futex.h	2011-12-05 15:50:14.000000000 +0000
@@ -16,6 +16,7 @@
 #include <asm/errno.h>
 #include <asm/war.h>
 
+#if !defined(CONFIG_REALTEK_CPU)
 #define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)		\
 {									\
 	if (cpu_has_llsc && R10000_LLSC_WAR) {				\
@@ -73,6 +74,12 @@
 	} else								\
 		ret = -ENOSYS;						\
 }
+#else
+#define __futex_atomic_op(insn, ret, oldval, uaddr, oparg)		\
+{									\
+		ret = -ENOSYS;						\
+}
+#endif
 
 static inline int
 futex_atomic_op_inuser(int encoded_op, int __user *uaddr)
@@ -139,6 +146,7 @@
 	if (!access_ok(VERIFY_WRITE, uaddr, sizeof(int)))
 		return -EFAULT;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		__asm__ __volatile__(
 		"# futex_atomic_cmpxchg_inatomic			\n"
@@ -195,6 +203,7 @@
 		: "memory");
 	} else
 		return -ENOSYS;
+#endif
 
 	return retval;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/local.h linux-2.6.30.9-rsdk/arch/mips/include/asm/local.h
--- linux-2.6.30.9/arch/mips/include/asm/local.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/local.h	2011-12-05 15:50:14.000000000 +0000
@@ -29,6 +29,7 @@
 {
 	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long temp;
 
@@ -57,7 +58,9 @@
 		: "=&r" (result), "=&r" (temp), "=m" (l->a.counter)
 		: "Ir" (i), "m" (l->a.counter)
 		: "memory");
-	} else {
+	} else 
+#endif
+	{
 		unsigned long flags;
 
 		local_irq_save(flags);
@@ -74,6 +77,7 @@
 {
 	unsigned long result;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long temp;
 
@@ -102,7 +106,9 @@
 		: "=&r" (result), "=&r" (temp), "=m" (l->a.counter)
 		: "Ir" (i), "m" (l->a.counter)
 		: "memory");
-	} else {
+	} else 
+#endif
+	{
 		unsigned long flags;
 
 		local_irq_save(flags);
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/string.h linux-2.6.30.9-rsdk/arch/mips/include/asm/string.h
--- linux-2.6.30.9/arch/mips/include/asm/string.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/string.h	2011-12-05 15:50:14.000000000 +0000
@@ -92,7 +92,7 @@
 	"3:\t.set\tat\n\t"
 	".set\treorder"
 	: "=r" (__cs), "=r" (__ct), "=r" (__res)
-	: "0" (__cs), "1" (__ct));
+	: "0" (__cs), "1" (__ct),  "m" (*__cs), "m" (*__ct));
 
   return __res;
 }
@@ -125,7 +125,7 @@
 	".set\tat\n\t"
 	".set\treorder"
 	: "=r" (__cs), "=r" (__ct), "=r" (__count), "=r" (__res)
-	: "0" (__cs), "1" (__ct), "2" (__count));
+	: "0" (__cs), "1" (__ct), "2" (__count), "m" (*__cs), "m" (*__ct));
 
 	return __res;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/system.h linux-2.6.30.9-rsdk/arch/mips/include/asm/system.h
--- linux-2.6.30.9/arch/mips/include/asm/system.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/system.h	2011-12-05 15:50:14.000000000 +0000
@@ -84,6 +84,7 @@
 {
 	__u32 retval;
 
+#if !defined(CONFIG_REALTEK_CPU)
 	if (cpu_has_llsc && R10000_LLSC_WAR) {
 		unsigned long dummy;
 
@@ -95,6 +96,9 @@
 		"	.set	mips3					\n"
 		"	sc	%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
+#ifdef CONFIG_SMP
+		"	sync						\n"
+#endif
 		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
@@ -109,24 +113,25 @@
 		"	move	%2, %z4					\n"
 		"	.set	mips3					\n"
 		"	sc	%2, %1					\n"
-		"	beqz	%2, 2f					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	beqz	%2, 1b					\n"
+#ifdef CONFIG_SMP
+		"	sync						\n"
+#endif
 		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
 		: "memory");
 	} else {
+#endif		
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		retval = *m;
 		*m = val;
-		raw_local_irq_restore(flags);	/* implies memory barrier  */
+		local_irq_restore(flags);	/* implies memory barrier  */
+#if !defined(CONFIG_REALTEK_CPU)
 	}
-
-	smp_llsc_mb();
+#endif
 
 	return retval;
 }
@@ -145,6 +150,9 @@
 		"	move	%2, %z4					\n"
 		"	scd	%2, %1					\n"
 		"	beqzl	%2, 1b					\n"
+#ifdef CONFIG_SMP
+		"	sync						\n"
+#endif
 		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
@@ -157,10 +165,10 @@
 		"1:	lld	%0, %3			# xchg_u64	\n"
 		"	move	%2, %z4					\n"
 		"	scd	%2, %1					\n"
-		"	beqz	%2, 2f					\n"
-		"	.subsection 2					\n"
-		"2:	b	1b					\n"
-		"	.previous					\n"
+		"	beqz	%2, 1b					\n"
+#ifdef CONFIG_SMP
+		"	sync						\n"
+#endif
 		"	.set	mips0					\n"
 		: "=&r" (retval), "=m" (*m), "=&r" (dummy)
 		: "R" (*m), "Jr" (val)
@@ -168,14 +176,12 @@
 	} else {
 		unsigned long flags;
 
-		raw_local_irq_save(flags);
+		local_irq_save(flags);
 		retval = *m;
 		*m = val;
-		raw_local_irq_restore(flags);	/* implies memory barrier  */
+		local_irq_restore(flags);	/* implies memory barrier  */
 	}
 
-	smp_llsc_mb();
-
 	return retval;
 }
 #else
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/thread_info.h linux-2.6.30.9-rsdk/arch/mips/include/asm/thread_info.h
--- linux-2.6.30.9/arch/mips/include/asm/thread_info.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/thread_info.h	2011-12-05 15:50:14.000000000 +0000
@@ -63,8 +63,11 @@
 #define current_thread_info()  __current_thread_info
 
 /* thread information allocation */
+#ifdef CONFIG_KERNEL_STACK_SIZE_ORDER
+  #define THREAD_SIZE_ORDER (CONFIG_KERNEL_STACK_SIZE_ORDER)
+#else
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_32BIT)
-#define THREAD_SIZE_ORDER (1)
+    #define THREAD_SIZE_ORDER (2)
 #endif
 #if defined(CONFIG_PAGE_SIZE_4KB) && defined(CONFIG_64BIT)
 #define THREAD_SIZE_ORDER (2)
@@ -81,6 +84,7 @@
 #ifdef CONFIG_PAGE_SIZE_64KB
 #define THREAD_SIZE_ORDER (0)
 #endif
+#endif
 
 #define THREAD_SIZE (PAGE_SIZE << THREAD_SIZE_ORDER)
 #define THREAD_MASK (THREAD_SIZE - 1UL)
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/include/asm/war.h linux-2.6.30.9-rsdk/arch/mips/include/asm/war.h
--- linux-2.6.30.9/arch/mips/include/asm/war.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/include/asm/war.h	2011-12-05 15:50:14.000000000 +0000
@@ -9,6 +9,51 @@
 #ifndef _ASM_WAR_H
 #define _ASM_WAR_H
 
+#undef cpu_has_llsc
+#define MIPS34K_MISSED_ITLB_WAR 0
+#define cpu_has_llsc 0
+#define R10000_LLSC_WAR 0
+#define DADDI_WAR 0
+/*
+ *  * Workarounds default to off
+ *   */
+#ifndef ICACHE_REFILLS_WORKAROUND_WAR
+#define ICACHE_REFILLS_WORKAROUND_WAR	0
+#endif
+#ifndef R4600_V1_INDEX_ICACHEOP_WAR
+#define R4600_V1_INDEX_ICACHEOP_WAR	0
+#endif
+#ifndef R4600_V1_HIT_CACHEOP_WAR
+#define R4600_V1_HIT_CACHEOP_WAR	0
+#endif
+#ifndef R4600_V2_HIT_CACHEOP_WAR
+#define R4600_V2_HIT_CACHEOP_WAR	0
+#endif
+#ifndef R5432_CP0_INTERRUPT_WAR
+#define R5432_CP0_INTERRUPT_WAR		0
+#endif
+#ifndef BCM1250_M3_WAR
+#define BCM1250_M3_WAR			0
+#endif
+#ifndef SIBYTE_1956_WAR
+#define SIBYTE_1956_WAR			0
+#endif
+#ifndef MIPS4K_ICACHE_REFILL_WAR
+#define MIPS4K_ICACHE_REFILL_WAR	0
+#endif
+#ifndef MIPS_CACHE_SYNC_WAR
+#define MIPS_CACHE_SYNC_WAR		0
+#endif
+#ifndef TX49XX_ICACHE_INDEX_INV_WAR
+#define TX49XX_ICACHE_INDEX_INV_WAR	0
+#endif
+#ifndef RM9000_CDEX_SMP_WAR
+#define RM9000_CDEX_SMP_WAR		0
+#endif
+#ifndef R10000_LLSC_WAR
+#define R10000_LLSC_WAR			0
+#endif
+#if 0
 #include <war.h>
 
 /*
@@ -240,5 +285,5 @@
 #ifndef MIPS34K_MISSED_ITLB_WAR
 #error Check setting of MIPS34K_MISSED_ITLB_WAR for your platform
 #endif
-
+#endif
 #endif /* _ASM_WAR_H */
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/Kconfig linux-2.6.30.9-rsdk/arch/mips/Kconfig
--- linux-2.6.30.9/arch/mips/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -17,7 +17,40 @@
 
 choice
 	prompt "System type"
-	default SGI_IP22
+	default MACH_RTL8196B
+
+config MACH_RTL8196B
+	bool "Realtek rtl8196b"
+	select CPU_R3000
+	select IRQ_CPU
+#	select SYS_HAS_EARLY_PRINTK
+	select CPU_BIG_ENDIAN
+	select RTL_819X
+	select RTL_8196B_GW
+	select RTL_8196B
+	select REALTEK_CPU
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_CPU_R3000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_100HZ
+	select RTL8196B
+	select DMA_NONCOHERENT
+
+config MACH_RTL8196C
+	bool "Realtek rtl8196c"
+	select CPU_R3000
+	select IRQ_CPU
+	select SYS_HAS_EARLY_PRINTK
+	select CPU_BIG_ENDIAN
+	select RTL_819X
+	select RTL_8196C_GW
+	select RTL_8196C
+	select REALTEK_CPU
+	select SYS_SUPPORTS_BIG_ENDIAN
+	select SYS_HAS_CPU_R3000
+	select SYS_SUPPORTS_32BIT_KERNEL
+	select SYS_SUPPORTS_100HZ
+	select DMA_NONCOHERENT
 
 config MACH_ALCHEMY
 	bool "Alchemy processor based machines"
@@ -633,19 +666,119 @@
 
 endchoice
 
-source "arch/mips/alchemy/Kconfig"
-source "arch/mips/basler/excite/Kconfig"
-source "arch/mips/jazz/Kconfig"
-source "arch/mips/lasat/Kconfig"
-source "arch/mips/pmc-sierra/Kconfig"
-source "arch/mips/sgi-ip27/Kconfig"
-source "arch/mips/sibyte/Kconfig"
-source "arch/mips/txx9/Kconfig"
-source "arch/mips/vr41xx/Kconfig"
-source "arch/mips/cavium-octeon/Kconfig"
-
+#source "arch/mips/alchemy/Kconfig"
+#source "arch/mips/basler/excite/Kconfig"
+#source "arch/mips/jazz/Kconfig"
+#source "arch/mips/lasat/Kconfig"
+#source "arch/mips/pmc-sierra/Kconfig"
+#source "arch/mips/sgi-ip27/Kconfig"
+#source "arch/mips/sibyte/Kconfig"
+#source "arch/mips/txx9/Kconfig"
+#source "arch/mips/vr41xx/Kconfig"
+#source "arch/mips/cavium-octeon/Kconfig"
+config RTL_FLASH_MAPPING_ENABLE
+        bool "Enable Flash Mapping"
+
+comment "Flash size 2M or 4M, default 2M"
+config RTL_FLASH_SIZE
+	hex "Size of Flash"
+	depends on RTL_819X
+	default "0x200000"
+	help
+          Size of Flash, Normally should be 2M or 4M.
+
+comment "Hardware setting offset,should be 4K alignment"
+config RTL_HW_SETTING_OFFSET
+        hex "Hardware setting offset in flash."
+        depends on RTL_819X 
+        default "0x6000"
+        help
+	  Hardware Setting store in flash from the offset.
+	  it should be 4k alignment.
+
+comment "Default setting offset,should be 4K alignment."
+comment "size of default and current setting should be same."
+config RTL_DEFAULT_SETTING_OFFSET
+        hex "Default setting offset in flash."
+        depends on RTL_819X 
+        default "0x8000"
+        help
+	  Default Setting store in flash from the offset.
+	  normally the default setting shoud save before current settting.
+	  NOTE: make sure it's size is enough for default setting,
+		default size is 16K.
+
+comment "Current setting offset,should be 4K alignment."
+config RTL_CURRENT_SETTING_OFFSET
+        hex "Current setting offset in flash."
+        depends on RTL_819X 
+        default "0xC000"
+        help
+	  Current Setting store in flash from the offset.
+	  normally the current setting saved after default setting.
+	  NOTE: make sure it's size is enough for current setting,
+		default size is 16K.
+
+comment "Webpage image offset,should be 4K alignment."
+comment "size of web page is normally about 100K."
+config RTL_WEB_PAGES_OFFSET
+	hex "webpages image offset in flash."
+	depends on RTL_819X
+	default "0x10000"
+	help
+	  Webpages image store in flash from the offset.
+	  NOTE: default size is 128K.
+
+comment "Linux image offset,should be 4K alignment."
+comment "this offset MUST between 0x10000~0x30000."
+config RTL_LINUX_IMAGE_OFFSET
+        hex "linux image offset in flash."
+        depends on RTL_819X 
+        default "0x30000"
+        help
+	  linux image store in flash from the offset.
+
+comment "Root image offset,should be 64K alignment."
+config RTL_ROOT_IMAGE_OFFSET
+        hex "root image offset in flash."
+        depends on RTL_819X 
+        default "0xF0000"
+        help
+	  root image store in flash from the offset.
 endmenu
 
+config DMA_NONCOHERENT
+	bool
+	default y
+
+config RTL8196B
+	bool
+	default n
+
+config RTL_8196B
+	bool
+	default n
+
+config RTL_8196C
+	bool
+	default n
+
+config RTL_8196B_GW
+	bool
+	default n
+
+config RTL_8196C_GW
+	bool
+	default n
+
+config RTL_819X
+	bool
+	default y
+
+config REALTEK_CPU
+	bool
+	default y
+
 config RWSEM_GENERIC_SPINLOCK
 	bool
 	default y
@@ -687,7 +820,7 @@
 
 config GENERIC_CMOS_UPDATE
 	bool
-	default y
+	default n
 
 config SCHED_OMIT_FRAME_POINTER
 	bool
@@ -767,7 +900,7 @@
 config EARLY_PRINTK
 	bool "Early printk" if EMBEDDED && DEBUG_KERNEL
 	depends on SYS_HAS_EARLY_PRINTK
-	default y
+	default n
 	help
 	  This option enables special console drivers which allow the kernel
 	  to print messages very early in the bootup process.
@@ -1003,7 +1136,7 @@
 
 choice
 	prompt "CPU type"
-	default CPU_R4X00
+	default CPU_R3000
 
 config CPU_LOONGSON2
 	bool "Loongson 2"
@@ -1084,7 +1217,6 @@
 config CPU_R3000
 	bool "R3000"
 	depends on SYS_HAS_CPU_R3000
-	select CPU_HAS_WB
 	select CPU_SUPPORTS_32BIT_KERNEL
 	select CPU_SUPPORTS_HIGHMEM
 	help
@@ -1398,6 +1530,16 @@
 
 endchoice
 
+config KERNEL_STACK_SIZE_ORDER
+        int "Kenel Stack Size Order Configuration"
+        default "2"
+        help
+          With Page Size 4K
+          1 for 8K kenel stack size
+          2 for 16K kernel stack size
+          3 for 32K kernel stack size
+          etc...
+
 choice
 	prompt "Kernel page size"
 	default PAGE_SIZE_4KB
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/asm-offsets.c linux-2.6.30.9-rsdk/arch/mips/kernel/asm-offsets.c
--- linux-2.6.30.9/arch/mips/kernel/asm-offsets.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/asm-offsets.c	2011-12-05 15:50:14.000000000 +0000
@@ -8,6 +8,7 @@
  * Kevin Kissell, kevink@mips.com and Carsten Langgaard, carstenl@mips.com
  * Copyright (C) 2000 MIPS Technologies, Inc.
  */
+
 #include <linux/compat.h>
 #include <linux/types.h>
 #include <linux/sched.h>
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/cpu-probe.c linux-2.6.30.9-rsdk/arch/mips/kernel/cpu-probe.c
--- linux-2.6.30.9/arch/mips/kernel/cpu-probe.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/cpu-probe.c	2011-12-05 15:50:14.000000000 +0000
@@ -32,6 +32,14 @@
  */
 void (*cpu_wait)(void) = NULL;
 
+#if defined(CONFIG_REALTEK_CPU)
+static void rlx_wait(void)
+{
+	#ifdef CONFIG_RTL865X_SUSPEND
+	__asm__("	sleep			\n");
+	#endif
+}
+#else
 static void r3081_wait(void)
 {
 	unsigned long cfg = read_c0_conf();
@@ -113,6 +121,7 @@
 		"	.set	mips0			\n"
 		: : "r" (au1k_wait));
 }
+#endif
 
 static int __initdata nowait = 0;
 
@@ -127,6 +136,11 @@
 
 void __init check_wait(void)
 {
+#if defined(CONFIG_RTL_819X)
+	printk("Checking for 'wait' instruction... ");
+	cpu_wait = rlx_wait;
+	printk(" available.\n");
+#else
 	struct cpuinfo_mips *c = &current_cpu_data;
 
 	if (nowait) {
@@ -211,6 +225,7 @@
 	default:
 		break;
 	}
+#endif
 }
 
 static inline void check_errata(void)
@@ -892,9 +907,24 @@
 __cpuinit void cpu_probe(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
-	unsigned int cpu = smp_processor_id();
+
+ 
+#if defined(CONFIG_RTL8652)|| defined(CONFIG_RTL_8196B) || defined(CONFIG_RTL_8196C)
+	c->fpu_id       = FPIR_IMP_NONE;
+        c->cputype      = CPU_R3000;
+        c->isa_level= MIPS_CPU_ISA_I;
+        c->options      = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE | MIPS_CPU_NOFPUEX;
+        c->tlbsize      = 32;
+        c->icache.ways = 2;
+        c->dcache.ways = 2;
 
 	c->processor_id	= PRID_IMP_UNKNOWN;
+	//c->options = MIPS_CPU_TLB | MIPS_CPU_3K_CACHE | MIPS_CPU_NOFPUEX;
+	//c->tlbsize = 32;  /* defined in bspcpu.h */
+	c->processor_id = read_c0_prid();
+#else
+	unsigned int cpu = smp_processor_id();
+	c->processor_id	= PRID_IMP_UNKNOWN;
 	c->fpu_id	= FPIR_IMP_NONE;
 	c->cputype	= CPU_UNKNOWN;
 
@@ -952,14 +982,15 @@
 		c->srsets = ((read_c0_srsctl() >> 26) & 0x0f) + 1;
 	else
 		c->srsets = 1;
+#endif
 }
 
 __cpuinit void cpu_report(void)
 {
 	struct cpuinfo_mips *c = &current_cpu_data;
 
-	printk(KERN_INFO "CPU revision is: %08x (%s)\n",
-	       c->processor_id, cpu_name_string());
+	printk(KERN_INFO "CPU revision is: %08x\n",
+	       c->processor_id);
 	if (c->options & MIPS_CPU_FPU)
 		printk(KERN_INFO "FPU revision is: %08x\n", c->fpu_id);
 }
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/early_printk.c linux-2.6.30.9-rsdk/arch/mips/kernel/early_printk.c
--- linux-2.6.30.9/arch/mips/kernel/early_printk.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/early_printk.c	2011-12-05 15:50:14.000000000 +0000
@@ -34,11 +34,12 @@
 
 static int early_console_initialized __initdata;
 
+extern void smp_setup_processor_id(void);
 void __init setup_early_printk(void)
 {
 	if (early_console_initialized)
 		return;
 	early_console_initialized = 1;
-
 	register_console(&early_console);
+	smp_setup_processor_id();
 }
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/genex.S linux-2.6.30.9-rsdk/arch/mips/kernel/genex.S
--- linux-2.6.30.9/arch/mips/kernel/genex.S	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/genex.S	2011-12-05 15:50:14.000000000 +0000
@@ -163,38 +163,8 @@
 
 	.align  5
 BUILD_ROLLBACK_PROLOGUE handle_int
+	.section .iram-gen
 NESTED(handle_int, PT_SIZE, sp)
-#ifdef CONFIG_TRACE_IRQFLAGS
-	/*
-	 * Check to see if the interrupted code has just disabled
-	 * interrupts and ignore this interrupt for now if so.
-	 *
-	 * local_irq_disable() disables interrupts and then calls
-	 * trace_hardirqs_off() to track the state. If an interrupt is taken
-	 * after interrupts are disabled but before the state is updated
-	 * it will appear to restore_all that it is incorrectly returning with
-	 * interrupts disabled
-	 */
-	.set	push
-	.set	noat
-	mfc0	k0, CP0_STATUS
-#if defined(CONFIG_CPU_R3000) || defined(CONFIG_CPU_TX39XX)
-	and	k0, ST0_IEP
-	bnez	k0, 1f
-
-	mfc0	k0, CP0_EPC
-	.set	noreorder
-	j	k0
-	rfe
-#else
-	and	k0, ST0_IE
-	bnez	k0, 1f
-
-	eret
-#endif
-1:
-	.set pop
-#endif
 	SAVE_ALL
 	CLI
 	TRACE_IRQS_OFF
@@ -204,6 +174,7 @@
 	PTR_LA	ra, ret_from_irq
 	j	plat_irq_dispatch
 	END(handle_int)
+	.previous
 
 	__INIT
 
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/Makefile linux-2.6.30.9-rsdk/arch/mips/kernel/Makefile
--- linux-2.6.30.9/arch/mips/kernel/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -1,6 +1,7 @@
 #
 # Makefile for the Linux/MIPS kernel.
 #
+DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
 
 extra-y		:= head.o init_task.o vmlinux.lds
 
@@ -8,6 +9,7 @@
 		   ptrace.o reset.o setup.o signal.o syscall.o \
 		   time.o topology.o traps.o unaligned.o watch.o
 
+obj-y	+= cevt-rtl819x.o
 obj-$(CONFIG_CEVT_BCM1480)	+= cevt-bcm1480.o
 obj-$(CONFIG_CEVT_R4K_LIB)	+= cevt-r4k.o
 obj-$(CONFIG_MIPS_MT_SMTC)	+= cevt-smtc.o
@@ -91,3 +93,4 @@
 obj-$(CONFIG_HAVE_STD_PC_SERIAL_PORT)	+= 8250-platform.o
 
 EXTRA_CFLAGS += -Werror
+EXTRA_CFLAGS += -I$(DIR_RTLASIC)
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/setup.c linux-2.6.30.9-rsdk/arch/mips/kernel/setup.c
--- linux-2.6.30.9/arch/mips/kernel/setup.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/setup.c	2011-12-05 15:50:14.000000000 +0000
@@ -32,6 +32,9 @@
 #include <asm/smp-ops.h>
 #include <asm/system.h>
 
+#include <asm/mach-realtek/rtl_types.h>
+#include <asm/mach-realtek/rtl8196b/platform.h>
+
 struct cpuinfo_mips cpu_data[NR_CPUS] __read_mostly;
 
 EXPORT_SYMBOL(cpu_data);
@@ -90,12 +93,10 @@
 		prev->size += size;
 		return;
 	}
-
 	if (x == BOOT_MEM_MAP_MAX) {
 		pr_err("Ooops! Too many entries in the memory map!\n");
 		return;
 	}
-
 	boot_mem_map.map[x].addr = start;
 	boot_mem_map.map[x].size = size;
 	boot_mem_map.map[x].type = type;
@@ -114,16 +115,16 @@
 
 		switch (boot_mem_map.map[i].type) {
 		case BOOT_MEM_RAM:
-			printk(KERN_CONT "(usable)\n");
+			printk(KERN_INFO "(usable)\n");
 			break;
 		case BOOT_MEM_ROM_DATA:
-			printk(KERN_CONT "(ROM data)\n");
+			printk(KERN_INFO "(ROM data)\n");
 			break;
 		case BOOT_MEM_RESERVED:
-			printk(KERN_CONT "(reserved)\n");
+			printk(KERN_INFO "(reserved)\n");
 			break;
 		default:
-			printk(KERN_CONT "type %lu\n", boot_mem_map.map[i].type);
+			printk(KERN_INFO "type %lu\n", boot_mem_map.map[i].type);
 			break;
 		}
 	}
@@ -468,10 +469,10 @@
 
 static void __init arch_mem_init(char **cmdline_p)
 {
-	extern void plat_mem_setup(void);
-
+	//extern void plat_mem_setup(void);
+	//unsigned int test;
 	/* call board setup routine */
-	plat_mem_setup();
+	//plat_mem_setup();
 
 	pr_info("Determined physical RAM map:\n");
 	print_memory_map();
@@ -490,6 +491,9 @@
 
 	bootmem_init();
 	sparse_init();
+	//test = *(volatile unsigned int *)(0xb800311C);
+//printk(KERN_INFO "----wtdog(%d)\n",test);
+	*(volatile unsigned int *)(0xb800311C) = 0xa5000000;
 	paging_init();
 }
 
@@ -546,10 +550,13 @@
 	}
 }
 
+static void __init rtl8652_setup(void);
 void __init setup_arch(char **cmdline_p)
 {
+	boot_mem_map.nr_map = 0;
 	cpu_probe();
 	prom_init();
+	plat_mem_setup();
 
 #ifdef CONFIG_EARLY_PRINTK
 	setup_early_printk();
@@ -569,6 +576,19 @@
 
 	resource_init();
 	plat_smp_setup();
+
+#ifdef CONFIG_RTL865X_SUSPEND
+       {
+       /* initial the cpu_wait function pointer, it is NULL originally. */
+       void (RTL865x_cpu_wait)(void);
+       cpu_wait = RTL865x_cpu_wait;
+       }
+#endif
+
+      rtl8652_setup( );
+#if defined(CONFIG_RTL8214_SUPPORT)
+      rtl8651_getAsicEthernetPHYReg( CONFIG_EXTRTL8212_PHYID_P5, 0, &tmp );
+#endif
 }
 
 static int __init fpu_disable(char *s)
@@ -609,3 +629,94 @@
 }
 arch_initcall(debugfs_mips);
 #endif
+
+#if 0
+static void shutdown_netdev()
+{
+
+	struct net_device *dev;
+	
+	printk("Shutdown network interface\n");
+	read_lock(&dev_base_lock);
+	
+      	for (dev = dev_base; dev; dev = dev->next) 
+	{
+		if( (dev->flags &IFF_UP) && (dev->stop))
+		{
+			printk("%s:===>\n",dev->name);			
+			rtnl_lock();
+			dev_close(dev);
+			rtnl_unlock();			
+		}
+      	}
+	read_unlock(&dev_base_lock);
+}
+
+
+
+static void rtl8652_machine_restart(char *command)
+{
+	unsigned long flags;
+	static void (*back_to_prom)(void) = (void (*)(void)) 0xbfc00000;
+
+	REG32(GIMR)=0;	
+
+	//save_flags(flags); 
+#if 0	
+	shutdown_netdev();
+#endif
+	//cli();
+	/* Perform full-reset for sw-core. */
+    	REG32(SIRR) |= FULL_RST;
+    	//tick_Delay10ms(2000);
+
+	printk("Enable Watch Dog to Reset whole system\n");
+#ifdef CONFIG_RTL8196_RTL8366
+        {
+                int ret;
+                ret = smi_init(GPIO_PORT_F, 2, 1);
+/*                printk("[%s][%d]:%d\n", __FUNCTION__, __LINE__, ret); */
+                ret = rtl8366rb_initChip();
+/*                printk("[%s][%d]:%d\n", __FUNCTION__, __LINE__, ret); */
+                ret = rtl8366rb_initVlan();
+/*                printk("[%s][%d]:%d\n", __FUNCTION__, __LINE__, ret);*/
+		ret = rtl8366rb_initChip();
+         }
+#endif
+	*(volatile unsigned long *)(0xB800311c)=0; /*this is to enable 865xc watch dog reset*/
+		
+	for(;;);
+	/* Reboot */
+	back_to_prom();
+}
+
+static void rtl8652_machine_halt(void)
+{
+	printk(KERN_EMERG "RTL8652 halted.\n");
+	while(1);
+}
+
+static void rtl8652_machine_power_off(void)
+{
+	printk(KERN_EMERG "RTL8652 halted. Please turn off power.\n");
+	while(1);
+}
+#endif
+static void __init rtl8652_setup(void)
+{	
+	//clear GIMR first!
+	set_io_port_base(KSEG1ADDR(0x18000000));
+
+	REG32(GIMR)=0;	
+	REG32(IRR0)=0;
+	REG32(IRR1)=0;
+	REG32(IRR2)=0;
+	REG32(IRR3)=0;
+	
+	//_machine_restart = rtl8652_machine_restart;
+	//_machine_halt = rtl8652_machine_halt;
+	//pm_power_off = rtl8652_machine_power_off;
+#ifdef CONFIG_RTL8186_KB
+	rtl865x_startBooting_ledControl();
+#endif
+}
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/syscall.c linux-2.6.30.9-rsdk/arch/mips/kernel/syscall.c
--- linux-2.6.30.9/arch/mips/kernel/syscall.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/syscall.c	2011-12-05 15:50:14.000000000 +0000
@@ -436,7 +436,6 @@
 	register unsigned long __a2 asm("$6") = (unsigned long) envp;
 	register unsigned long __a3 asm("$7");
 	unsigned long __v0;
-
 	__asm__ volatile ("					\n"
 	"	.set	noreorder				\n"
 	"	li	$2, %5		# __NR_execve		\n"
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/time.c linux-2.6.30.9-rsdk/arch/mips/kernel/time.c
--- linux-2.6.30.9/arch/mips/kernel/time.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/time.c	2011-12-05 15:50:14.000000000 +0000
@@ -113,10 +113,13 @@
  * setup_irq calls and each clock_event_device should use its own
  * struct irqrequest.
  */
+
+#if 1
 void __init plat_timer_setup(void)
 {
 	BUG();
 }
+#endif
 
 static __init int cpu_has_mfc0_count_bug(void)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/topology.c linux-2.6.30.9-rsdk/arch/mips/kernel/topology.c
--- linux-2.6.30.9/arch/mips/kernel/topology.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/topology.c	2011-12-05 15:50:14.000000000 +0000
@@ -7,6 +7,7 @@
 
 static DEFINE_PER_CPU(struct cpu, cpu_devices);
 
+extern int prom_putchar(char c);
 static int __init topology_init(void)
 {
 	int i, ret;
@@ -22,7 +23,6 @@
 			printk(KERN_WARNING "topology_init: register_cpu %d "
 			       "failed (%d)\n", i, ret);
 	}
-
 	return 0;
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/traps.c linux-2.6.30.9-rsdk/arch/mips/kernel/traps.c
--- linux-2.6.30.9/arch/mips/kernel/traps.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/traps.c	2011-12-05 15:50:14.000000000 +0000
@@ -48,6 +48,9 @@
 #include <asm/types.h>
 #include <asm/stacktrace.h>
 #include <asm/irq.h>
+#if defined(CONFIG_RTL_819X)
+#include <common/rtl_types.h>
+#endif
 
 extern void check_wait(void);
 extern asmlinkage void r4k_wait(void);
@@ -1241,7 +1244,7 @@
 #define VECTORSPACING 0x100	/* for EI/VI mode */
 
 unsigned long ebase;
-unsigned long exception_handlers[32];
+__DRAM_GEN unsigned long exception_handlers[32];
 unsigned long vi_handlers[64];
 
 /*
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/unaligned.c linux-2.6.30.9-rsdk/arch/mips/kernel/unaligned.c
--- linux-2.6.30.9/arch/mips/kernel/unaligned.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/unaligned.c	2011-12-05 15:50:14.000000000 +0000
@@ -187,9 +187,41 @@
 
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
+#if defined(CONFIG_REALTEK_CPU)
+#if 0//sync from skylark kernel 2.6.19 mips arch
+			".set\tnoat\n"
+			"1:\tlbu\t$1, 0(%2)\n"
+			"  \tnop\n"
+			"  \tsll\t$1, 24\n"
+			"  \tmove\t%0, $1\n"
+			"  \tlbu\t$1, 1(%2)\n"
+			"  \tnop\n"
+			"  \tsll\t$1, 16\n"
+			"  \tor\t%0, $1\n"
+			"2:\tlbu\t$1, 2(%2)\n"
+			"  \tnop\n"
+			"  \tsll\t$1, 8\n"
+			"  \tor\t%0, $1\n"
+			"  \tlbu\t$1, 3(%2)\n"
+			"  \tnop\n"
+			"  \tor\t%0, $1\n"
+#else//sync from jungle kernel 2.6.30 rlx arch
+			"1:  lb    %0,  0(%2)\n"
+	            "    lb    %1,  1(%2)\n"
+	            "    sll   %0,  8\n"
+	            "    or    %0,  %1\n"
+	            "    lb    %1,  2(%2)\n"
+	            "    sll   %0,  8\n"
+	            "    or    %0,  %1\n"
+	            "    lb    %1,  3(%2)\n"
+	            "    sll   %0,  8\n"
+	            "    or    %0,  %1\n"
+#endif
+#else
 			"1:\tlwl\t%0, (%2)\n"
 			"2:\tlwr\t%0, 3(%2)\n\t"
 #endif
+#endif
 #ifdef __LITTLE_ENDIAN
 			"1:\tlwl\t%0, 3(%2)\n"
 			"2:\tlwr\t%0, (%2)\n\t"
@@ -375,9 +407,30 @@
 		value = regs->regs[insn.i_format.rt];
 		__asm__ __volatile__ (
 #ifdef __BIG_ENDIAN
+#if defined(CONFIG_REALTEK_CPU)
+#if 0
+			"1:\tsb\t%1, 3(%2)\n"
+			"  \tsrl\t%1, 8\n"
+			"  \tsb\t%1, 2(%2)\n"
+			"  \tsrl\t%1, 8\n"
+			"2:\tsb\t%1, 1(%2)\n"
+			"  \tsrl\t%1, 8\n"
+			"  \tsb\t%1, 0(%2)\n"
+#else
+			"1:  or   %0, %1, $0\n"
+	            "    sb   %0, 3(%2)\n"
+	            "    srl  %0, 8\n"
+	            "    sb   %0, 2(%2)\n"
+	            "    srl  %0, 8\n"
+	            "    sb   %0, 1(%2)\n"
+	            "    srl  %0, 8\n"
+	            "    sb   %0, 0(%2)\n"							
+#endif
+#else
 			"1:\tswl\t%1,(%2)\n"
 			"2:\tswr\t%1, 3(%2)\n\t"
 #endif
+#endif
 #ifdef __LITTLE_ENDIAN
 			"1:\tswl\t%1, 3(%2)\n"
 			"2:\tswr\t%1, (%2)\n\t"
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/kernel/vmlinux.lds.S linux-2.6.30.9-rsdk/arch/mips/kernel/vmlinux.lds.S
--- linux-2.6.30.9/arch/mips/kernel/vmlinux.lds.S	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/kernel/vmlinux.lds.S	2011-12-05 15:50:14.000000000 +0000
@@ -39,6 +39,62 @@
 		*(.text.*)
 		*(.fixup)
 		*(.gnu.warning)
+#ifdef CONFIG_RTL8192SE
+	/* start of wlan f/w definition */
+	__fw_start = . ;
+	*(.rtl8192sfw.bin)
+	__fw_end = . ;
+	
+	__AGC_TAB_start = . ;
+	*(.AGC_TAB.txt)
+	__AGC_TAB_end = . ;
+
+	__phy_reg_start = . ;
+	*(.phy_reg.txt)
+	__phy_reg_end = . ;
+
+        __phy_reg_MP_start = . ;
+        *(.phy_reg_MP.txt)
+        __phy_reg_MP_end = . ;
+
+	__MACPHY_REG_start = . ;
+	*(.MACPHY_REG.txt)
+	__MACPHY_REG_end = . ;
+
+	__radio_a_start = . ;
+	*(.radio_a.txt)
+	__radio_a_end = . ;                                                       
+
+	__radio_b_start = . ;
+	*(.radio_b.txt)
+	__radio_b_end = . ;
+
+	__PHY_REG_PG_start = .;
+	*(.PHY_REG_PG.txt)
+	__PHY_REG_PG_end = .;
+
+	__PHY_to1T2R_start = .;
+        *(.PHY_to1T2R.txt)
+        __PHY_to1T2R_end = .;
+ 
+        __PHY_to1T2R_b_start = .;
+        *(.PHY_to1T2R_b.txt)
+        __PHY_to1T2R_b_end = .;
+ 
+        __PHY_to1T1R_start = .;
+        *(.PHY_to1T1R.txt)
+        __PHY_to1T1R_end = .;
+ 
+        __PHY_to1T1R_b_start = .;
+        *(.PHY_to1T1R_b.txt)
+        __PHY_to1T1R_b_end = .;
+
+        __radio_a_hp_start = . ;
+        *(.radio_a_hp.txt)
+        __radio_a_hp_end = . ;
+
+	/* end of wlan f/w definition */
+#endif
 	} :text = 0
 	_etext = .;	/* End of text section */
 
@@ -62,6 +118,44 @@
 
 	RODATA
 
+	. = ALIGN(16384);
+	__iram = . ;
+	.iram        :
+	{
+		*(.iram-gen)            /* general usage (essential) */
+		*(.iram-fwd)            /* general packet forwarding used */
+		*(.iram-rtkwlan)        /* realtek wlan driver */
+		*(.iram-l2-fwd)         /* L2 packet forwarding */
+		*(.iram-l34-fwd)        /* L34 packet forwarding */
+		*(.iram-tx)             /* protocol stack TX */
+		*(.iram-extdev)         /* ROMEDRV extension device fwd */
+		*(.iram-crypto)         /* authetication / crypto-engine */
+		*(.iram-voip)           /* voip */
+		*(.iram)                /* other usage */
+		*(.iram.1)
+	}
+
+	. = ALIGN(8192);
+	__dram = . ;
+	__dram_start = . ;
+	.dram        :
+	{
+		*(.dram-gen)            /* general usage (essential) */
+		*(.dram-fwd)            /* general packet forwarding used */
+		*(.dram-l2-fwd)         /* L2 packet forwarding */
+		*(.dram-l34-fwd)        /* L34 packet forwarding */
+		*(.dram-extdev)         /* ROMEDRV extension device fwd */
+		*(.dram-wapi)           /*wapi encryption/decryption used*/
+		*(.dram-rtkwlan)        /* realtek wlan driver */
+		*(.dram-crypto)         /* authetication / crypto-engine */
+		*(.dram-voip)           /* voip */
+		*(.dram-tx)             /* protocol stack TX */
+		*(.dram)                /* other usage */
+		*(.dram.1)
+	}
+	. = ALIGN(8192);
+	__dram_end = . ;
+
 	/* writeable */
 	.data : {	/* Data */
 		. = . + DATAOFFSET;		/* for CONFIG_MAPPED_KERNEL */
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/lib/csum_partial.S linux-2.6.30.9-rsdk/arch/mips/lib/csum_partial.S
--- linux-2.6.30.9/arch/mips/lib/csum_partial.S	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/lib/csum_partial.S	2011-12-05 15:50:14.000000000 +0000
@@ -232,11 +232,37 @@
 	 andi	t0, a1, 2
 
 	/* Still a full word to go  */
+#ifndef CONFIG_REALTEK_CPU
 	ulw	t1, (src)
 	PTR_ADDIU	src, 4
+#else   /* CONFIG_REALTEK_CPU */
 #ifdef USE_DOUBLE
 	dsll	t1, t1, 32			/* clear lower 32bit */
 #endif
+
+/* Replace "ulw" with "lbu"/"sll"/"or" Insts */
+/***** Start of "ulw" replacer ****/
+/* Notes: for LX5181, there is none interlock for "Load" Inst */
+/* So have to wait loading-data validating for ONE Inst-Cycle */
+        .set noat
+        lbu  t1,  0(src)
+        lbu  $at, 1(src)
+        sll  t1,  t1, 24
+        sll  $at, $at,16
+        or   t1,  $at
+
+        lbu  $at, 2(src)
+        nop           
+        sll  $at, $at,8
+        or   t1,  $at
+ 
+        lbu  $at, 3(src)
+        nop           
+        or   t1,  $at
+        .set at
+/***** End of "ulw" replacer ****/
+#endif
+	addiu	src, 4
 	ADDC(sum, t1)
 
 1:	move	t1, zero
@@ -245,7 +271,8 @@
 
 	/* Still a halfword to go  */
 	ulhu	t1, (src)
-	PTR_ADDIU	src, 2
+	/* PTR_ADDIU	src,  */
+	addiu	src, 2
 
 1:	beqz	t0, 1f
 	 sll	t1, t1, 16
@@ -376,6 +403,8 @@
 #define STREST  STOREL
 #define SHIFT_DISCARD SLLV
 #define SHIFT_DISCARD_REVERT SRLV
+#define SHIFT_START 0
+#define SHIFT_INC   8
 #else
 #define LDFIRST LOADL
 #define LDREST  LOADR
@@ -383,6 +412,8 @@
 #define STREST  STORER
 #define SHIFT_DISCARD SRLV
 #define SHIFT_DISCARD_REVERT SLLV
+#define SHIFT_START 8*(NBYTES-1)
+#define SHIFT_INC   -8
 #endif
 
 #define FIRST(unit) ((unit)*NBYTES)
@@ -417,6 +448,7 @@
 	 *
 	 * If len < NBYTES use byte operations.
 	 */
+#ifdef CONFIG_CPU_HAS_ULS
 	sltu	t2, len, NBYTES
 	and	t1, dst, ADDRMASK
 	bnez	t2, .Lcopy_bytes_checklen
@@ -425,6 +457,16 @@
 	bnez	t1, .Ldst_unaligned
 	 nop
 	bnez	t0, .Lsrc_unaligned_dst_aligned
+#else
+    sltu    t2, len, NBYTES
+    and     t1, dst, ADDRMASK
+    and     t0, src, ADDRMASK
+    or      t2, t1  
+    or      t2, t0
+	bnez	t2, .Lcopy_bytes_checklen
+     andi   odd, dst, 0x1			/* odd buffer? */
+#endif
+
 	/*
 	 * use delay slot for fall-through
 	 * src and dst are aligned; need to compute rem
@@ -526,6 +568,7 @@
 	 * wide-issue mips processors because the code has fewer branches and
 	 * more instruction-level parallelism.
 	 */
+#ifdef CONFIG_CPU_HAS_ULS
 #define bits t2
 	beqz	len, .Ldone
 	 ADD	t1, dst, len	# t1 is just past last byte of dst
@@ -689,6 +732,63 @@
 	jr	ra
 	.set noreorder
 
+#else
+
+.Lcopy_bytes_checklen:
+    beqz    len, .Ldone
+     nop
+
+.Lcopy_bytes:
+    move   t2, zero
+    li     t3, SHIFT_START
+    li     t4, NBYTES-1
+
+2:  EXC( lbu     t0, 0(src), .Ll_exc_copy)
+         sub     len, len, 1
+    EXC( sb	     t0, 0(dst), .Ls_exc)
+         addiu   src, src, 1
+         addiu   dst, dst, 1
+
+    sllv   t0, t0, t3
+    ADD    t3, SHIFT_INC
+
+    beqz   len, .Lcopy_bytes_done
+     or    t2, t0
+
+    bnez   t4, 2b
+     sub   t4, t4, 1
+     ADDC(sum, t2)
+    b .Lcopy_bytes
+    nop
+
+.Lcopy_bytes_done:
+	ADDC(sum, t2)
+.Ldone:
+	/* fold checksum */
+	.set	push
+	.set	noat
+	sll	v1, sum, 16
+	addu	sum, v1
+	sltu	v1, sum, v1
+	srl	sum, sum, 16
+	addu	sum, v1
+
+	/* odd buffer alignment? */
+	beqz	odd, 1f
+	 nop
+	sll	v1, sum, 8
+	srl	sum, sum, 8
+	or	sum, v1
+	andi	sum, 0xffff
+	.set	pop
+1:
+	ADDC(sum, psum)
+	jr	ra
+	nop
+#endif
+
+
+
 .Ll_exc_copy:
 	/*
 	 * Copy bytes from src until faulting load address (or until a
@@ -758,3 +858,4 @@
 	 sw	v1, (errptr)
 	.set	pop
 	END(__csum_partial_copy_user)
+
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/lib/delay.c linux-2.6.30.9-rsdk/arch/mips/lib/delay.c
--- linux-2.6.30.9/arch/mips/lib/delay.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/lib/delay.c	2011-12-05 15:50:14.000000000 +0000
@@ -13,7 +13,6 @@
 #include <linux/smp.h>
 
 #include <asm/compiler.h>
-#include <asm/war.h>
 
 inline void __delay(unsigned int loops)
 {
@@ -43,7 +42,7 @@
 {
 	unsigned int lpj = current_cpu_data.udelay_val;
 
-	__delay((us * 0x000010c7 * HZ * lpj) >> 32);
+	__delay((us * 0x000010c7ull * HZ * lpj) >> 32);
 }
 EXPORT_SYMBOL(__udelay);
 
@@ -51,6 +50,6 @@
 {
 	unsigned int lpj = current_cpu_data.udelay_val;
 
-	__delay((us * 0x00000005 * HZ * lpj) >> 32);
+	__delay((ns * 0x00000005ull * HZ * lpj) >> 32);
 }
 EXPORT_SYMBOL(__ndelay);
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/lib/Makefile linux-2.6.30.9-rsdk/arch/mips/lib/Makefile
--- linux-2.6.30.9/arch/mips/lib/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/lib/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -2,6 +2,8 @@
 # Makefile for MIPS-specific library files..
 #
 
+#lib-y	+= csum_partial.o delay.o memcpy-inatomic.o \
+	   strlen_user.o strncpy_user.o strnlen_user.o uncached.o
 lib-y	+= csum_partial.o delay.o memcpy.o memcpy-inatomic.o memset.o \
 	   strlen_user.o strncpy_user.o strnlen_user.o uncached.o
 
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/lib/memcpy-inatomic.S linux-2.6.30.9-rsdk/arch/mips/lib/memcpy-inatomic.S
--- linux-2.6.30.9/arch/mips/lib/memcpy-inatomic.S	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/lib/memcpy-inatomic.S	2011-12-05 15:50:14.000000000 +0000
@@ -14,20 +14,6 @@
  * Mnemonic names for arguments to memcpy/__copy_user
  */
 
-/*
- * Hack to resolve longstanding prefetch issue
- *
- * Prefetching may be fatal on some systems if we're prefetching beyond the
- * end of memory on some systems.  It's also a seriously bad idea on non
- * dma-coherent systems.
- */
-#ifdef CONFIG_DMA_NONCOHERENT
-#undef CONFIG_CPU_HAS_PREFETCH
-#endif
-#ifdef CONFIG_MIPS_MALTA
-#undef CONFIG_CPU_HAS_PREFETCH
-#endif
-
 #include <asm/asm.h>
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
@@ -91,51 +77,6 @@
 	PTR	9b, handler;			\
 	.previous
 
-/*
- * Only on the 64-bit kernel we can made use of 64-bit registers.
- */
-#ifdef CONFIG_64BIT
-#define USE_DOUBLE
-#endif
-
-#ifdef USE_DOUBLE
-
-#define LOAD   ld
-#define LOADL  ldl
-#define LOADR  ldr
-#define STOREL sdl
-#define STORER sdr
-#define STORE  sd
-#define ADD    daddu
-#define SUB    dsubu
-#define SRL    dsrl
-#define SRA    dsra
-#define SLL    dsll
-#define SLLV   dsllv
-#define SRLV   dsrlv
-#define NBYTES 8
-#define LOG_NBYTES 3
-
-/*
- * As we are sharing code base with the mips32 tree (which use the o32 ABI
- * register definitions). We need to redefine the register definitions from
- * the n64 ABI register naming to the o32 ABI register naming.
- */
-#undef t0
-#undef t1
-#undef t2
-#undef t3
-#define t0	$8
-#define t1	$9
-#define t2	$10
-#define t3	$11
-#define t4	$12
-#define t5	$13
-#define t6	$14
-#define t7	$15
-
-#else
-
 #define LOAD   lw
 #define LOADL  lwl
 #define LOADR  lwr
@@ -149,11 +90,8 @@
 #define SRA    sra
 #define SLLV   sllv
 #define SRLV   srlv
-#define NBYTES 4
 #define LOG_NBYTES 2
 
-#endif /* USE_DOUBLE */
-
 #ifdef CONFIG_CPU_LITTLE_ENDIAN
 #define LDFIRST LOADR
 #define LDREST  LOADL
@@ -168,19 +106,13 @@
 #define SHIFT_DISCARD SRLV
 #endif
 
-#define FIRST(unit) ((unit)*NBYTES)
-#define REST(unit)  (FIRST(unit)+NBYTES-1)
+#define FIRST(unit) ((unit)*LONGSIZE)
+#define REST(unit)  (FIRST(unit)+LONGSIZE-1)
 #define UNIT(unit)  FIRST(unit)
 
-#define ADDRMASK (NBYTES-1)
-
 	.text
 	.set	noreorder
-#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	.set	noat
-#else
-	.set	at=v1
-#endif
 
 /*
  * A combined memcpy/__copy_user
@@ -201,100 +133,95 @@
 	 * Issue delays for dcache fills will perturb the schedule, as will
 	 * load queue full replay traps, etc.
 	 *
-	 * If len < NBYTES use byte operations.
+	 * If len < LONGSIZE use byte operations.
 	 */
-	PREF(	0, 0(src) )
-	PREF(	1, 0(dst) )
-	sltu	t2, len, NBYTES
-	and	t1, dst, ADDRMASK
-	PREF(	0, 1*32(src) )
-	PREF(	1, 1*32(dst) )
+#ifdef CONFIG_CPU_HAS_ULS
+	sltu	t2, len, LONGSIZE
+	and	t1, dst, LONGMASK
 	bnez	t2, .Lcopy_bytes_checklen
-	 and	t0, src, ADDRMASK
-	PREF(	0, 2*32(src) )
-	PREF(	1, 2*32(dst) )
+	 and	t0, src, LONGMASK
 	bnez	t1, .Ldst_unaligned
 	 nop
 	bnez	t0, .Lsrc_unaligned_dst_aligned
+#else
+	sltu	t2, len, LONGSIZE
+	and	    t1, dst, LONGMASK
+    and     t0, src, LONGMASK
+    or      t2, t1
+    or      t2, t0
+	bnez	t2, .Lcopy_bytes_checklen
+#endif
 	/*
 	 * use delay slot for fall-through
 	 * src and dst are aligned; need to compute rem
 	 */
 .Lboth_aligned:
 	 SRL	t0, len, LOG_NBYTES+3    	# +3 for 8 units/iter
-	beqz	t0, .Lcleanup_both_aligned	# len < 8*NBYTES
-	 and	rem, len, (8*NBYTES-1)	 	# rem = len % (8*NBYTES)
-	PREF(	0, 3*32(src) )
-	PREF(	1, 3*32(dst) )
+	beqz	t0, .Lcleanup_both_aligned  # len < 8*LONGSIZE
+	 and	rem, len, (8*LONGSIZE-1)    # rem = len % (8*LONGSIZE)
 	.align	4
 1:
 EXC(	LOAD	t0, UNIT(0)(src),	.Ll_exc)
 EXC(	LOAD	t1, UNIT(1)(src),	.Ll_exc_copy)
 EXC(	LOAD	t2, UNIT(2)(src),	.Ll_exc_copy)
 EXC(	LOAD	t3, UNIT(3)(src),	.Ll_exc_copy)
-	SUB	len, len, 8*NBYTES
+	SUB	len, len, 8*LONGSIZE
 EXC(	LOAD	t4, UNIT(4)(src),	.Ll_exc_copy)
 EXC(	LOAD	t7, UNIT(5)(src),	.Ll_exc_copy)
 	STORE	t0, UNIT(0)(dst)
 	STORE	t1, UNIT(1)(dst)
 EXC(	LOAD	t0, UNIT(6)(src),	.Ll_exc_copy)
 EXC(	LOAD	t1, UNIT(7)(src),	.Ll_exc_copy)
-	ADD	src, src, 8*NBYTES
-	ADD	dst, dst, 8*NBYTES
+	ADD	src, src, 8*LONGSIZE
+	ADD	dst, dst, 8*LONGSIZE
 	STORE	t2, UNIT(-6)(dst)
 	STORE	t3, UNIT(-5)(dst)
 	STORE	t4, UNIT(-4)(dst)
 	STORE	t7, UNIT(-3)(dst)
 	STORE	t0, UNIT(-2)(dst)
 	STORE	t1, UNIT(-1)(dst)
-	PREF(	0, 8*32(src) )
-	PREF(	1, 8*32(dst) )
 	bne	len, rem, 1b
 	 nop
 
 	/*
-	 * len == rem == the number of bytes left to copy < 8*NBYTES
+	 * len == rem == the number of bytes left to copy < 8*LONGSIZE
 	 */
 .Lcleanup_both_aligned:
 	beqz	len, .Ldone
-	 sltu	t0, len, 4*NBYTES
+	 sltu	t0, len, 4*LONGSIZE
 	bnez	t0, .Lless_than_4units
-	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
+	 and	rem, len, (LONGSIZE-1)	# rem = len % LONGSIZE
 	/*
-	 * len >= 4*NBYTES
+	 * len >= 4*LONGSIZE
 	 */
 EXC(	LOAD	t0, UNIT(0)(src),	.Ll_exc)
 EXC(	LOAD	t1, UNIT(1)(src),	.Ll_exc_copy)
 EXC(	LOAD	t2, UNIT(2)(src),	.Ll_exc_copy)
 EXC(	LOAD	t3, UNIT(3)(src),	.Ll_exc_copy)
-	SUB	len, len, 4*NBYTES
-	ADD	src, src, 4*NBYTES
+	SUB	len, len, 4*LONGSIZE
+	ADD	src, src, 4*LONGSIZE
 	STORE	t0, UNIT(0)(dst)
 	STORE	t1, UNIT(1)(dst)
 	STORE	t2, UNIT(2)(dst)
 	STORE	t3, UNIT(3)(dst)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, 4*NBYTES
 	beqz	len, .Ldone
-	.set	noreorder
+	 ADD	dst, dst, 4*LONGSIZE
 .Lless_than_4units:
 	/*
-	 * rem = len % NBYTES
+	 * rem = len % LONGSIZE
 	 */
 	beq	rem, len, .Lcopy_bytes
 	 nop
 1:
 EXC(	LOAD	t0, 0(src),		.Ll_exc)
-	ADD	src, src, NBYTES
-	SUB	len, len, NBYTES
+	ADD	src, src, LONGSIZE
+	SUB	len, len, LONGSIZE
 	STORE	t0, 0(dst)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, NBYTES
 	bne	rem, len, 1b
-	.set	noreorder
+	 ADD	dst, dst, LONGSIZE
 
 	/*
-	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
+	 * src and dst are aligned, need to copy rem bytes (rem < LONGSIZE)
 	 * A loop would do only a byte at a time with possible branch
 	 * mispredicts.  Can't do an explicit LOAD dst,mask,or,STORE
 	 * because can't assume read-access to dst.  Instead, use
@@ -304,10 +231,13 @@
 	 * wide-issue mips processors because the code has fewer branches and
 	 * more instruction-level parallelism.
 	 */
+#ifdef CONFIG_CPU_HAS_ULS
+
 #define bits t2
 	beqz	len, .Ldone
 	 ADD	t1, dst, len	# t1 is just past last byte of dst
-	li	bits, 8*NBYTES
+
+	li	bits, 8*LONGSIZE
 	SLL	rem, len, 3	# rem = number of bits to keep
 EXC(	LOAD	t0, 0(src),		.Ll_exc)
 	SUB	bits, bits, rem	# bits = number of bits to discard
@@ -315,19 +245,20 @@
 	STREST	t0, -1(t1)
 	jr	ra
 	 move	len, zero
+
 .Ldst_unaligned:
 	/*
 	 * dst is unaligned
-	 * t0 = src & ADDRMASK
-	 * t1 = dst & ADDRMASK; T1 > 0
-	 * len >= NBYTES
+	 * t0 = src & LONGMASK
+	 * t1 = dst & LONGMASK; T1 > 0
+	 * len >= LONGSIZE
 	 *
 	 * Copy enough bytes to align dst
 	 * Set match = (src and dst have same alignment)
 	 */
 #define match rem
 EXC(	LDFIRST	t3, FIRST(0)(src),	.Ll_exc)
-	ADD	t2, zero, NBYTES
+	ADD	t2, zero, LONGSIZE
 EXC(	LDREST	t3, REST(0)(src),	.Ll_exc_copy)
 	SUB	t2, t2, t1	# t2 = number of bytes copied
 	xor	match, t0, t1
@@ -340,10 +271,8 @@
 
 .Lsrc_unaligned_dst_aligned:
 	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
-	PREF(	0, 3*32(src) )
 	beqz	t0, .Lcleanup_src_unaligned
-	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
-	PREF(	1, 3*32(dst) )
+	 and	rem, len, (4*LONGSIZE-1)   # rem = len % 4*LONGSIZE
 1:
 /*
  * Avoid consecutive LD*'s to the same register since some mips
@@ -353,49 +282,41 @@
  */
 EXC(	LDFIRST	t0, FIRST(0)(src),	.Ll_exc)
 EXC(	LDFIRST	t1, FIRST(1)(src),	.Ll_exc_copy)
-	SUB     len, len, 4*NBYTES
+	SUB     len, len, 4*LONGSIZE
 EXC(	LDREST	t0, REST(0)(src),	.Ll_exc_copy)
 EXC(	LDREST	t1, REST(1)(src),	.Ll_exc_copy)
 EXC(	LDFIRST	t2, FIRST(2)(src),	.Ll_exc_copy)
 EXC(	LDFIRST	t3, FIRST(3)(src),	.Ll_exc_copy)
 EXC(	LDREST	t2, REST(2)(src),	.Ll_exc_copy)
 EXC(	LDREST	t3, REST(3)(src),	.Ll_exc_copy)
-	PREF(	0, 9*32(src) )		# 0 is PREF_LOAD  (not streamed)
-	ADD	src, src, 4*NBYTES
-#ifdef CONFIG_CPU_SB1
-	nop				# improves slotting
-#endif
+	ADD	src, src, 4*LONGSIZE
 	STORE	t0, UNIT(0)(dst)
 	STORE	t1, UNIT(1)(dst)
 	STORE	t2, UNIT(2)(dst)
 	STORE	t3, UNIT(3)(dst)
-	PREF(	1, 9*32(dst) )     	# 1 is PREF_STORE (not streamed)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, 4*NBYTES
 	bne	len, rem, 1b
-	.set	noreorder
+	 ADD	dst, dst, 4*LONGSIZE
 
 .Lcleanup_src_unaligned:
 	beqz	len, .Ldone
-	 and	rem, len, NBYTES-1  # rem = len % NBYTES
+	 and	rem, len, LONGSIZE-1  # rem = len % LONGSIZE
 	beq	rem, len, .Lcopy_bytes
 	 nop
 1:
 EXC(	LDFIRST t0, FIRST(0)(src),	.Ll_exc)
 EXC(	LDREST	t0, REST(0)(src),	.Ll_exc_copy)
-	ADD	src, src, NBYTES
-	SUB	len, len, NBYTES
+	ADD	src, src, LONGSIZE
+	SUB	len, len, LONGSIZE
 	STORE	t0, 0(dst)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, NBYTES
 	bne	len, rem, 1b
-	.set	noreorder
+	 ADD	dst, dst, LONGSIZE
 
 .Lcopy_bytes_checklen:
 	beqz	len, .Ldone
 	 nop
+
 .Lcopy_bytes:
-	/* 0 < len < NBYTES  */
+    /* 0 < len < LONGSIZE*/
 #define COPY_BYTE(N)			\
 EXC(	lb	t0, N(src), .Ll_exc);	\
 	SUB	len, len, 1;		\
@@ -404,16 +325,27 @@
 
 	COPY_BYTE(0)
 	COPY_BYTE(1)
-#ifdef USE_DOUBLE
-	COPY_BYTE(2)
-	COPY_BYTE(3)
-	COPY_BYTE(4)
-	COPY_BYTE(5)
-#endif
-EXC(	lb	t0, NBYTES-2(src), .Ll_exc)
+
+EXC(    lb  t0, LONGSIZE-2(src), .Ll_exc)
 	SUB	len, len, 1
 	jr	ra
-	 sb	t0, NBYTES-2(dst)
+     sb t0, LONGSIZE-2(dst)
+
+#else /* NO ULS */
+
+.Lcopy_bytes_checklen:
+	beqz	len, .Ldone
+     nop
+
+.Lcopy_bytes:
+EXC( lb   t0,  0(src), .Ll_exc)
+     SUB  len, len, 1
+     sb   t0,  0(dst)
+     ADD  src, src, 1
+     bnez len, .Lcopy_bytes
+      ADD  dst, dst, 1
+#endif
+
 .Ldone:
 	jr	ra
 	 nop
@@ -437,10 +369,8 @@
 EXC(	lb	t1, 0(src),	.Ll_exc)
 	ADD	src, src, 1
 	sb	t1, 0(dst)	# can't fault -- we're copy_from_user
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, 1
 	bne	src, t0, 1b
-	.set	noreorder
+	 ADD	dst, dst, 1
 .Ll_exc:
 	LOAD	t0, TI_TASK($28)
 	 nop
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/lib/memcpy.S linux-2.6.30.9-rsdk/arch/mips/lib/memcpy.S
--- linux-2.6.30.9/arch/mips/lib/memcpy.S	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/lib/memcpy.S	2011-12-05 15:50:14.000000000 +0000
@@ -9,7 +9,6 @@
  * Copyright (C) 1999, 2000, 01, 2002 Silicon Graphics, Inc.
  * Copyright (C) 2002 Broadcom, Inc.
  *   memcpy/copy_user author: Mark Vandevoorde
- * Copyright (C) 2007  Maciej W. Rozycki
  *
  * Mnemonic names for arguments to memcpy/__copy_user
  */
@@ -21,7 +20,7 @@
  * end of memory on some systems.  It's also a seriously bad idea on non
  * dma-coherent systems.
  */
-#ifdef CONFIG_DMA_NONCOHERENT
+#if !defined(CONFIG_DMA_COHERENT) || !defined(CONFIG_DMA_IP27)
 #undef CONFIG_CPU_HAS_PREFETCH
 #endif
 #ifdef CONFIG_MIPS_MALTA
@@ -176,11 +175,7 @@
 
 	.text
 	.set	noreorder
-#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	.set	noat
-#else
-	.set	at=v1
-#endif
 
 /*
  * A combined memcpy/__copy_user
@@ -191,7 +186,7 @@
 	.align	5
 LEAF(memcpy)					/* a0=dst a1=src a2=len */
 	move	v0, dst				/* return value */
-.L__memcpy:
+__memcpy:
 FEXPORT(__copy_user)
 	/*
 	 * Note: dst & src may be unaligned, len may be 0
@@ -199,7 +194,6 @@
 	 */
 #define rem t8
 
-	R10KCBARRIER(0(ra))
 	/*
 	 * The "issue break"s below are very approximate.
 	 * Issue delays for dcache fills will perturb the schedule, as will
@@ -207,51 +201,66 @@
 	 *
 	 * If len < NBYTES use byte operations.
 	 */
+#if defined(CONFIG_REALTEK_CPU)
+	PREF(	0, 0(src) )
+	PREF(	1, 0(dst) )
+	sltu	t2, len, NBYTES
+	and	t1, dst, ADDRMASK
+	PREF(	0, 1*32(src) )
+	PREF(	1, 1*32(dst) )
+	bnez	t2, copy_bytes_checklen
+	 and	t0, src, ADDRMASK
+	PREF(	0, 2*32(src) )
+	PREF(	1, 2*32(dst) )
+	bnez	t1, copy_bytes_checklen
+	 nop
+	bnez	t0, copy_bytes_checklen
+#else
 	PREF(	0, 0(src) )
 	PREF(	1, 0(dst) )
 	sltu	t2, len, NBYTES
 	and	t1, dst, ADDRMASK
 	PREF(	0, 1*32(src) )
 	PREF(	1, 1*32(dst) )
-	bnez	t2, .Lcopy_bytes_checklen
+	bnez	t2, copy_bytes_checklen
 	 and	t0, src, ADDRMASK
 	PREF(	0, 2*32(src) )
 	PREF(	1, 2*32(dst) )
-	bnez	t1, .Ldst_unaligned
+	bnez	t1, dst_unaligned
 	 nop
-	bnez	t0, .Lsrc_unaligned_dst_aligned
+	bnez	t0, src_unaligned_dst_aligned
+#endif
 	/*
 	 * use delay slot for fall-through
 	 * src and dst are aligned; need to compute rem
 	 */
-.Lboth_aligned:
+both_aligned:
 	 SRL	t0, len, LOG_NBYTES+3    # +3 for 8 units/iter
-	beqz	t0, .Lcleanup_both_aligned # len < 8*NBYTES
+	beqz	t0, cleanup_both_aligned # len < 8*NBYTES
 	 and	rem, len, (8*NBYTES-1)	 # rem = len % (8*NBYTES)
 	PREF(	0, 3*32(src) )
 	PREF(	1, 3*32(dst) )
 	.align	4
 1:
-	R10KCBARRIER(0(ra))
-EXC(	LOAD	t0, UNIT(0)(src),	.Ll_exc)
-EXC(	LOAD	t1, UNIT(1)(src),	.Ll_exc_copy)
-EXC(	LOAD	t2, UNIT(2)(src),	.Ll_exc_copy)
-EXC(	LOAD	t3, UNIT(3)(src),	.Ll_exc_copy)
+EXC(	LOAD	t0, UNIT(0)(src),	l_exc)
+EXC(	LOAD	t1, UNIT(1)(src),	l_exc_copy)
+EXC(	LOAD	t2, UNIT(2)(src),	l_exc_copy)
+EXC(	LOAD	t3, UNIT(3)(src),	l_exc_copy)
 	SUB	len, len, 8*NBYTES
-EXC(	LOAD	t4, UNIT(4)(src),	.Ll_exc_copy)
-EXC(	LOAD	t7, UNIT(5)(src),	.Ll_exc_copy)
-EXC(	STORE	t0, UNIT(0)(dst),	.Ls_exc_p8u)
-EXC(	STORE	t1, UNIT(1)(dst),	.Ls_exc_p7u)
-EXC(	LOAD	t0, UNIT(6)(src),	.Ll_exc_copy)
-EXC(	LOAD	t1, UNIT(7)(src),	.Ll_exc_copy)
+EXC(	LOAD	t4, UNIT(4)(src),	l_exc_copy)
+EXC(	LOAD	t7, UNIT(5)(src),	l_exc_copy)
+EXC(	STORE	t0, UNIT(0)(dst),	s_exc_p8u)
+EXC(	STORE	t1, UNIT(1)(dst),	s_exc_p7u)
+EXC(	LOAD	t0, UNIT(6)(src),	l_exc_copy)
+EXC(	LOAD	t1, UNIT(7)(src),	l_exc_copy)
 	ADD	src, src, 8*NBYTES
 	ADD	dst, dst, 8*NBYTES
-EXC(	STORE	t2, UNIT(-6)(dst),	.Ls_exc_p6u)
-EXC(	STORE	t3, UNIT(-5)(dst),	.Ls_exc_p5u)
-EXC(	STORE	t4, UNIT(-4)(dst),	.Ls_exc_p4u)
-EXC(	STORE	t7, UNIT(-3)(dst),	.Ls_exc_p3u)
-EXC(	STORE	t0, UNIT(-2)(dst),	.Ls_exc_p2u)
-EXC(	STORE	t1, UNIT(-1)(dst),	.Ls_exc_p1u)
+EXC(	STORE	t2, UNIT(-6)(dst),	s_exc_p6u)
+EXC(	STORE	t3, UNIT(-5)(dst),	s_exc_p5u)
+EXC(	STORE	t4, UNIT(-4)(dst),	s_exc_p4u)
+EXC(	STORE	t7, UNIT(-3)(dst),	s_exc_p3u)
+EXC(	STORE	t0, UNIT(-2)(dst),	s_exc_p2u)
+EXC(	STORE	t1, UNIT(-1)(dst),	s_exc_p1u)
 	PREF(	0, 8*32(src) )
 	PREF(	1, 8*32(dst) )
 	bne	len, rem, 1b
@@ -260,46 +269,43 @@
 	/*
 	 * len == rem == the number of bytes left to copy < 8*NBYTES
 	 */
-.Lcleanup_both_aligned:
-	beqz	len, .Ldone
+cleanup_both_aligned:
+	beqz	len, done
 	 sltu	t0, len, 4*NBYTES
-	bnez	t0, .Lless_than_4units
+	bnez	t0, less_than_4units
 	 and	rem, len, (NBYTES-1)	# rem = len % NBYTES
 	/*
 	 * len >= 4*NBYTES
 	 */
-EXC(	LOAD	t0, UNIT(0)(src),	.Ll_exc)
-EXC(	LOAD	t1, UNIT(1)(src),	.Ll_exc_copy)
-EXC(	LOAD	t2, UNIT(2)(src),	.Ll_exc_copy)
-EXC(	LOAD	t3, UNIT(3)(src),	.Ll_exc_copy)
+EXC(	LOAD	t0, UNIT(0)(src),	l_exc)
+EXC(	LOAD	t1, UNIT(1)(src),	l_exc_copy)
+EXC(	LOAD	t2, UNIT(2)(src),	l_exc_copy)
+EXC(	LOAD	t3, UNIT(3)(src),	l_exc_copy)
 	SUB	len, len, 4*NBYTES
 	ADD	src, src, 4*NBYTES
-	R10KCBARRIER(0(ra))
-EXC(	STORE	t0, UNIT(0)(dst),	.Ls_exc_p4u)
-EXC(	STORE	t1, UNIT(1)(dst),	.Ls_exc_p3u)
-EXC(	STORE	t2, UNIT(2)(dst),	.Ls_exc_p2u)
-EXC(	STORE	t3, UNIT(3)(dst),	.Ls_exc_p1u)
-	.set	reorder				/* DADDI_WAR */
+EXC(	STORE	t0, UNIT(0)(dst),	s_exc_p4u)
+EXC(	STORE	t1, UNIT(1)(dst),	s_exc_p3u)
+EXC(	STORE	t2, UNIT(2)(dst),	s_exc_p2u)
+EXC(	STORE	t3, UNIT(3)(dst),	s_exc_p1u)
+	beqz	len, done
 	ADD	dst, dst, 4*NBYTES
-	beqz	len, .Ldone
-	.set	noreorder
-.Lless_than_4units:
+less_than_4units:
 	/*
 	 * rem = len % NBYTES
 	 */
-	beq	rem, len, .Lcopy_bytes
+	beq	rem, len, copy_bytes
 	 nop
 1:
-	R10KCBARRIER(0(ra))
-EXC(	LOAD	t0, 0(src),		.Ll_exc)
+EXC(	LOAD	t0, 0(src),		l_exc)
 	ADD	src, src, NBYTES
 	SUB	len, len, NBYTES
-EXC(	STORE	t0, 0(dst),		.Ls_exc_p1u)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, NBYTES
+EXC(	STORE	t0, 0(dst),		s_exc_p1u)
 	bne	rem, len, 1b
-	.set	noreorder
+	 ADD	dst, dst, NBYTES
+
+#if defined(CONFIG_REALTEK_CPU)
 
+#else
 	/*
 	 * src and dst are aligned, need to copy rem bytes (rem < NBYTES)
 	 * A loop would do only a byte at a time with possible branch
@@ -312,17 +318,17 @@
 	 * more instruction-level parallelism.
 	 */
 #define bits t2
-	beqz	len, .Ldone
+	beqz	len, done
 	 ADD	t1, dst, len	# t1 is just past last byte of dst
 	li	bits, 8*NBYTES
 	SLL	rem, len, 3	# rem = number of bits to keep
-EXC(	LOAD	t0, 0(src),		.Ll_exc)
+EXC(	LOAD	t0, 0(src),		l_exc)
 	SUB	bits, bits, rem	# bits = number of bits to discard
 	SHIFT_DISCARD t0, t0, bits
-EXC(	STREST	t0, -1(t1),		.Ls_exc)
+EXC(	STREST	t0, -1(t1),		s_exc)
 	jr	ra
 	 move	len, zero
-.Ldst_unaligned:
+dst_unaligned:
 	/*
 	 * dst is unaligned
 	 * t0 = src & ADDRMASK
@@ -333,23 +339,22 @@
 	 * Set match = (src and dst have same alignment)
 	 */
 #define match rem
-EXC(	LDFIRST	t3, FIRST(0)(src),	.Ll_exc)
+EXC(	LDFIRST	t3, FIRST(0)(src),	l_exc)
 	ADD	t2, zero, NBYTES
-EXC(	LDREST	t3, REST(0)(src),	.Ll_exc_copy)
+EXC(	LDREST	t3, REST(0)(src),	l_exc_copy)
 	SUB	t2, t2, t1	# t2 = number of bytes copied
 	xor	match, t0, t1
-	R10KCBARRIER(0(ra))
-EXC(	STFIRST t3, FIRST(0)(dst),	.Ls_exc)
-	beq	len, t2, .Ldone
+EXC(	STFIRST t3, FIRST(0)(dst),	s_exc)
+	beq	len, t2, done
 	 SUB	len, len, t2
 	ADD	dst, dst, t2
-	beqz	match, .Lboth_aligned
+	beqz	match, both_aligned
 	 ADD	src, src, t2
 
-.Lsrc_unaligned_dst_aligned:
+src_unaligned_dst_aligned:
 	SRL	t0, len, LOG_NBYTES+2    # +2 for 4 units/iter
 	PREF(	0, 3*32(src) )
-	beqz	t0, .Lcleanup_src_unaligned
+	beqz	t0, cleanup_src_unaligned
 	 and	rem, len, (4*NBYTES-1)   # rem = len % 4*NBYTES
 	PREF(	1, 3*32(dst) )
 1:
@@ -359,59 +364,65 @@
  * It's OK to load FIRST(N+1) before REST(N) because the two addresses
  * are to the same unit (unless src is aligned, but it's not).
  */
-	R10KCBARRIER(0(ra))
-EXC(	LDFIRST	t0, FIRST(0)(src),	.Ll_exc)
-EXC(	LDFIRST	t1, FIRST(1)(src),	.Ll_exc_copy)
+EXC(	LDFIRST	t0, FIRST(0)(src),	l_exc)
+EXC(	LDFIRST	t1, FIRST(1)(src),	l_exc_copy)
 	SUB     len, len, 4*NBYTES
-EXC(	LDREST	t0, REST(0)(src),	.Ll_exc_copy)
-EXC(	LDREST	t1, REST(1)(src),	.Ll_exc_copy)
-EXC(	LDFIRST	t2, FIRST(2)(src),	.Ll_exc_copy)
-EXC(	LDFIRST	t3, FIRST(3)(src),	.Ll_exc_copy)
-EXC(	LDREST	t2, REST(2)(src),	.Ll_exc_copy)
-EXC(	LDREST	t3, REST(3)(src),	.Ll_exc_copy)
+EXC(	LDREST	t0, REST(0)(src),	l_exc_copy)
+EXC(	LDREST	t1, REST(1)(src),	l_exc_copy)
+EXC(	LDFIRST	t2, FIRST(2)(src),	l_exc_copy)
+EXC(	LDFIRST	t3, FIRST(3)(src),	l_exc_copy)
+EXC(	LDREST	t2, REST(2)(src),	l_exc_copy)
+EXC(	LDREST	t3, REST(3)(src),	l_exc_copy)
 	PREF(	0, 9*32(src) )		# 0 is PREF_LOAD  (not streamed)
 	ADD	src, src, 4*NBYTES
 #ifdef CONFIG_CPU_SB1
 	nop				# improves slotting
 #endif
-EXC(	STORE	t0, UNIT(0)(dst),	.Ls_exc_p4u)
-EXC(	STORE	t1, UNIT(1)(dst),	.Ls_exc_p3u)
-EXC(	STORE	t2, UNIT(2)(dst),	.Ls_exc_p2u)
-EXC(	STORE	t3, UNIT(3)(dst),	.Ls_exc_p1u)
+EXC(	STORE	t0, UNIT(0)(dst),	s_exc_p4u)
+EXC(	STORE	t1, UNIT(1)(dst),	s_exc_p3u)
+EXC(	STORE	t2, UNIT(2)(dst),	s_exc_p2u)
+EXC(	STORE	t3, UNIT(3)(dst),	s_exc_p1u)
 	PREF(	1, 9*32(dst) )     	# 1 is PREF_STORE (not streamed)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, 4*NBYTES
 	bne	len, rem, 1b
-	.set	noreorder
+	 ADD	dst, dst, 4*NBYTES
 
-.Lcleanup_src_unaligned:
-	beqz	len, .Ldone
+cleanup_src_unaligned:
+	beqz	len, done
 	 and	rem, len, NBYTES-1  # rem = len % NBYTES
-	beq	rem, len, .Lcopy_bytes
+	beq	rem, len, copy_bytes
 	 nop
 1:
-	R10KCBARRIER(0(ra))
-EXC(	LDFIRST t0, FIRST(0)(src),	.Ll_exc)
-EXC(	LDREST	t0, REST(0)(src),	.Ll_exc_copy)
+EXC(	LDFIRST t0, FIRST(0)(src),	l_exc)
+EXC(	LDREST	t0, REST(0)(src),	l_exc_copy)
 	ADD	src, src, NBYTES
 	SUB	len, len, NBYTES
-EXC(	STORE	t0, 0(dst),		.Ls_exc_p1u)
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, NBYTES
+EXC(	STORE	t0, 0(dst),		s_exc_p1u)
 	bne	len, rem, 1b
-	.set	noreorder
+	 ADD	dst, dst, NBYTES
+#endif
 
-.Lcopy_bytes_checklen:
-	beqz	len, .Ldone
+copy_bytes_checklen:
+	beqz	len, done
+	 nop
+copy_bytes:
+#if defined(CONFIG_REALTEK_CPU)
+1:
+	beqz	len, done
+	nop
+EXC(	lb  t0, 0(src), l_exc)
+	SUB len, len, 1
+EXC(	sb      t0, 0(dst), s_exc_p1)
+	ADD	dst,    dst, 1
+	ADD src,        src, 1
+	bnez	len, 1b
 	 nop
-.Lcopy_bytes:
+#else
 	/* 0 < len < NBYTES  */
-	R10KCBARRIER(0(ra))
 #define COPY_BYTE(N)			\
-EXC(	lb	t0, N(src), .Ll_exc);	\
+EXC(	lb	t0, N(src), l_exc);	\
 	SUB	len, len, 1;		\
-	beqz	len, .Ldone;		\
-EXC(	 sb	t0, N(dst), .Ls_exc_p1)
+	beqz	len, done;		\
+EXC(	 sb	t0, N(dst), s_exc_p1)
 
 	COPY_BYTE(0)
 	COPY_BYTE(1)
@@ -421,16 +432,17 @@
 	COPY_BYTE(4)
 	COPY_BYTE(5)
 #endif
-EXC(	lb	t0, NBYTES-2(src), .Ll_exc)
+EXC(	lb	t0, NBYTES-2(src), l_exc)
 	SUB	len, len, 1
 	jr	ra
-EXC(	 sb	t0, NBYTES-2(dst), .Ls_exc_p1)
-.Ldone:
+EXC(	 sb	t0, NBYTES-2(dst), s_exc_p1)
+#endif
+done:
 	jr	ra
 	 nop
 	END(memcpy)
 
-.Ll_exc_copy:
+l_exc_copy:
 	/*
 	 * Copy bytes from src until faulting load address (or until a
 	 * lb faults)
@@ -445,14 +457,12 @@
 	 nop
 	LOAD	t0, THREAD_BUADDR(t0)
 1:
-EXC(	lb	t1, 0(src),	.Ll_exc)
+EXC(	lb	t1, 0(src),	l_exc)
 	ADD	src, src, 1
 	sb	t1, 0(dst)	# can't fault -- we're copy_from_user
-	.set	reorder				/* DADDI_WAR */
-	ADD	dst, dst, 1
 	bne	src, t0, 1b
-	.set	noreorder
-.Ll_exc:
+	 ADD	dst, dst, 1
+l_exc:
 	LOAD	t0, TI_TASK($28)
 	 nop
 	LOAD	t0, THREAD_BUADDR(t0)	# t0 is just past last good address
@@ -469,33 +479,20 @@
 	 * Clear len bytes starting at dst.  Can't call __bzero because it
 	 * might modify len.  An inefficient loop for these rare times...
 	 */
-	.set	reorder				/* DADDI_WAR */
+	beqz	len, done
 	SUB	src, len, 1
-	beqz	len, .Ldone
-	.set	noreorder
 1:	sb	zero, 0(dst)
 	ADD	dst, dst, 1
-#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	bnez	src, 1b
 	 SUB	src, src, 1
-#else
-	.set	push
-	.set	noat
-	li	v1, 1
-	bnez	src, 1b
-	 SUB	src, src, v1
-	.set	pop
-#endif
 	jr	ra
 	 nop
 
 
 #define SEXC(n)							\
-	.set	reorder;			/* DADDI_WAR */	\
-.Ls_exc_p ## n ## u:						\
-	ADD	len, len, n*NBYTES;				\
+s_exc_p ## n ## u:			\
 	jr	ra;						\
-	.set	noreorder
+	 ADD	len, len, n*NBYTES
 
 SEXC(8)
 SEXC(7)
@@ -506,12 +503,10 @@
 SEXC(2)
 SEXC(1)
 
-.Ls_exc_p1:
-	.set	reorder				/* DADDI_WAR */
-	ADD	len, len, 1
+s_exc_p1:
 	jr	ra
-	.set	noreorder
-.Ls_exc:
+	 ADD	len, len, 1
+s_exc:
 	jr	ra
 	 nop
 
@@ -522,44 +517,38 @@
 	sltu	t0, a1, t0			# dst + len <= src -> memcpy
 	sltu	t1, a0, t1			# dst >= src + len -> memcpy
 	and	t0, t1
-	beqz	t0, .L__memcpy
+	beqz	t0, __memcpy
 	 move	v0, a0				/* return value */
-	beqz	a2, .Lr_out
+	beqz	a2, r_out
 	END(memmove)
 
 	/* fall through to __rmemcpy */
 LEAF(__rmemcpy)					/* a0=dst a1=src a2=len */
 	 sltu	t0, a1, a0
-	beqz	t0, .Lr_end_bytes_up		# src >= dst
+	beqz	t0, r_end_bytes_up		# src >= dst
 	 nop
 	ADD	a0, a2				# dst = dst + len
 	ADD	a1, a2				# src = src + len
 
-.Lr_end_bytes:
-	R10KCBARRIER(0(ra))
+r_end_bytes:
 	lb	t0, -1(a1)
 	SUB	a2, a2, 0x1
 	sb	t0, -1(a0)
 	SUB	a1, a1, 0x1
-	.set	reorder				/* DADDI_WAR */
+	bnez	a2, r_end_bytes
 	SUB	a0, a0, 0x1
-	bnez	a2, .Lr_end_bytes
-	.set	noreorder
 
-.Lr_out:
+r_out:
 	jr	ra
 	 move	a2, zero
 
-.Lr_end_bytes_up:
-	R10KCBARRIER(0(ra))
+r_end_bytes_up:
 	lb	t0, (a1)
 	SUB	a2, a2, 0x1
 	sb	t0, (a0)
 	ADD	a1, a1, 0x1
-	.set	reorder				/* DADDI_WAR */
+	bnez	a2, r_end_bytes_up
 	ADD	a0, a0, 0x1
-	bnez	a2, .Lr_end_bytes_up
-	.set	noreorder
 
 	jr	ra
 	 move	a2, zero
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/lib/memset.S linux-2.6.30.9-rsdk/arch/mips/lib/memset.S
--- linux-2.6.30.9/arch/mips/lib/memset.S	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/lib/memset.S	2011-12-05 15:50:14.000000000 +0000
@@ -5,20 +5,11 @@
  *
  * Copyright (C) 1998, 1999, 2000 by Ralf Baechle
  * Copyright (C) 1999, 2000 Silicon Graphics, Inc.
- * Copyright (C) 2007  Maciej W. Rozycki
  */
 #include <asm/asm.h>
 #include <asm/asm-offsets.h>
 #include <asm/regdef.h>
 
-#if LONGSIZE == 4
-#define LONG_S_L swl
-#define LONG_S_R swr
-#else
-#define LONG_S_L sdl
-#define LONG_S_R sdr
-#endif
-
 #define EX(insn,reg,addr,handler)			\
 9:	insn	reg, addr;				\
 	.section __ex_table,"a"; 			\
@@ -34,7 +25,6 @@
 	EX(LONG_S, \val, (\offset +  5 * LONGSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset +  6 * LONGSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset +  7 * LONGSIZE)(\dst), \fixup)
-#if LONGSIZE == 4
 	EX(LONG_S, \val, (\offset +  8 * LONGSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset +  9 * LONGSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset + 10 * LONGSIZE)(\dst), \fixup)
@@ -43,7 +33,6 @@
 	EX(LONG_S, \val, (\offset + 13 * LONGSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset + 14 * LONGSIZE)(\dst), \fixup)
 	EX(LONG_S, \val, (\offset + 15 * LONGSIZE)(\dst), \fixup)
-#endif
 	.endm
 
 /*
@@ -60,94 +49,90 @@
 	 move		v0, a0			/* result */
 
 	andi		a1, 0xff		/* spread fillword */
-	LONG_SLL		t1, a1, 8
+	sll		t1, a1, 8
 	or		a1, t1
-	LONG_SLL		t1, a1, 16
-#if LONGSIZE == 8
-	or		a1, t1
-	LONG_SLL		t1, a1, 32
-#endif
+	sll		t1, a1, 16
 	or		a1, t1
 1:
 
 FEXPORT(__bzero)
 	sltiu		t0, a2, LONGSIZE	/* very small region? */
-	bnez		t0, .Lsmall_memset
+	bnez		t0, small_memset
 	 andi		t0, a0, LONGMASK	/* aligned? */
 
-#ifndef CONFIG_CPU_DADDI_WORKAROUNDS
 	beqz		t0, 1f
 	 PTR_SUBU	t0, LONGSIZE		/* alignment in bytes */
-#else
-	.set		noat
-	li		AT, LONGSIZE
-	beqz		t0, 1f
-	 PTR_SUBU	t0, AT			/* alignment in bytes */
-	.set		at
-#endif
 
-	R10KCBARRIER(0(ra))
+#if defined(CONFIG_REALTEK_CPU)
+0:
+	EX(sb, a1, 0(a0), first_fixup)
+	addiu	a0, 1
+	subu	a2, 1
+	andi	t0, a0, LONGMASK
+	bnez 	t0, 0b
+	nop
+#else
 #ifdef __MIPSEB__
-	EX(LONG_S_L, a1, (a0), .Lfirst_fixup)	/* make word/dword aligned */
+	EX(swl, a1, (a0), first_fixup)		/* make word aligned */
 #endif
 #ifdef __MIPSEL__
-	EX(LONG_S_R, a1, (a0), .Lfirst_fixup)	/* make word/dword aligned */
+	EX(swr, a1, (a0), first_fixup)		/* make word aligned */
 #endif
 	PTR_SUBU	a0, t0			/* long align ptr */
 	PTR_ADDU	a2, t0			/* correct size */
+#endif
 
 1:	ori		t1, a2, 0x3f		/* # of full blocks */
 	xori		t1, 0x3f
-	beqz		t1, .Lmemset_partial	/* no block to fill */
-	 andi		t0, a2, 0x40-LONGSIZE
+	beqz		t1, memset_partial	/* no block to fill */
+	 andi		t0, a2, 0x3c
 
 	PTR_ADDU	t1, a0			/* end address */
 	.set		reorder
 1:	PTR_ADDIU	a0, 64
-	R10KCBARRIER(0(ra))
-	f_fill64 a0, -64, a1, .Lfwd_fixup
+	f_fill64 a0, -64, a1, fwd_fixup
 	bne		t1, a0, 1b
 	.set		noreorder
 
-.Lmemset_partial:
-	R10KCBARRIER(0(ra))
+memset_partial:
 	PTR_LA		t1, 2f			/* where to start */
-#if LONGSIZE == 4
 	PTR_SUBU	t1, t0
-#else
-	.set		noat
-	LONG_SRL		AT, t0, 1
-	PTR_SUBU	t1, AT
-	.set		at
-#endif
 	jr		t1
 	 PTR_ADDU	a0, t0			/* dest ptr */
 
 	.set		push
 	.set		noreorder
 	.set		nomacro
-	f_fill64 a0, -64, a1, .Lpartial_fixup	/* ... but first do longs ... */
+	f_fill64 a0, -64, a1, partial_fixup	/* ... but first do longs ... */
 2:	.set		pop
 	andi		a2, LONGMASK		/* At most one long to go */
 
 	beqz		a2, 1f
+#if defined(CONFIG_REALTEK_CPU)
+	nop
+byte_write:  /* fill bytewise */
+    EX(sb, a1, 0(a0), last_fixup)
+    addiu   a0, 1
+    subu    a2, 1
+    bnez    a2, byte_write 
+    nop
+#else
 	 PTR_ADDU	a0, a2			/* What's left */
-	R10KCBARRIER(0(ra))
 #ifdef __MIPSEB__
-	EX(LONG_S_R, a1, -1(a0), .Llast_fixup)
+	EX(swr, a1, -1(a0), last_fixup)
 #endif
 #ifdef __MIPSEL__
-	EX(LONG_S_L, a1, -1(a0), .Llast_fixup)
+	EX(swl, a1, -1(a0), last_fixup)
+#endif
 #endif
 1:	jr		ra
 	 move		a2, zero
 
-.Lsmall_memset:
+small_memset:
 	beqz		a2, 2f
 	 PTR_ADDU	t1, a0, a2
 
 1:	PTR_ADDIU	a0, 1			/* fill bytewise */
-	R10KCBARRIER(0(ra))
 	bne		t1, a0, 1b
 	 sb		a1, -1(a0)
 
@@ -155,11 +140,11 @@
 	 move		a2, zero
 	END(memset)
 
-.Lfirst_fixup:
+first_fixup:
 	jr	ra
 	 nop
 
-.Lfwd_fixup:
+fwd_fixup:
 	PTR_L		t0, TI_TASK($28)
 	LONG_L		t0, THREAD_BUADDR(t0)
 	andi		a2, 0x3f
@@ -167,7 +152,7 @@
 	jr		ra
 	 LONG_SUBU	a2, t0
 
-.Lpartial_fixup:
+partial_fixup:
 	PTR_L		t0, TI_TASK($28)
 	LONG_L		t0, THREAD_BUADDR(t0)
 	andi		a2, LONGMASK
@@ -175,6 +160,6 @@
 	jr		ra
 	 LONG_SUBU	a2, t0
 
-.Llast_fixup:
+last_fixup:
 	jr		ra
 	 andi		v1, a2, LONGMASK
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/Makefile linux-2.6.30.9-rsdk/arch/mips/Makefile
--- linux-2.6.30.9/arch/mips/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -17,30 +17,17 @@
 #
 # Select the object file format to substitute into the linker script.
 #
-ifdef CONFIG_CPU_LITTLE_ENDIAN
-32bit-tool-archpref	= mipsel
-64bit-tool-archpref	= mips64el
-32bit-bfd		= elf32-tradlittlemips
-64bit-bfd		= elf64-tradlittlemips
-32bit-emul		= elf32ltsmip
-64bit-emul		= elf64ltsmip
-else
 32bit-tool-archpref	= mips
 64bit-tool-archpref	= mips64
 32bit-bfd		= elf32-tradbigmips
 64bit-bfd		= elf64-tradbigmips
 32bit-emul		= elf32btsmip
 64bit-emul		= elf64btsmip
-endif
 
 ifdef CONFIG_32BIT
 tool-archpref		= $(32bit-tool-archpref)
 UTS_MACHINE		:= mips
 endif
-ifdef CONFIG_64BIT
-tool-archpref		= $(64bit-tool-archpref)
-UTS_MACHINE		:= mips64
-endif
 
 ifneq ($(SUBARCH),$(ARCH))
   ifeq ($(CROSS_COMPILE),)
@@ -113,7 +100,7 @@
 #
 # CPU-dependent compiler/assembler options for optimization.
 #
-cflags-$(CONFIG_CPU_R3000)	+= -march=r3000
+cflags-$(CONFIG_CPU_R3000)	+= -march=5181
 cflags-$(CONFIG_CPU_TX39XX)	+= -march=r3900
 cflags-$(CONFIG_CPU_R6000)	+= -march=r6000 -Wa,--trap
 cflags-$(CONFIG_CPU_R4300)	+= -march=r4300 -Wa,--trap
@@ -167,7 +154,6 @@
 libs-$(CONFIG_CFE)		+= arch/mips/fw/cfe/
 libs-$(CONFIG_SNIPROM)		+= arch/mips/fw/sni/
 libs-y				+= arch/mips/fw/lib/
-libs-$(CONFIG_SIBYTE_CFE)	+= arch/mips/sibyte/cfe/
 
 #
 # Board-dependent options and extra files
@@ -176,118 +162,11 @@
 #
 # Acer PICA 61, Mips Magnum 4000 and Olivetti M700.
 #
-core-$(CONFIG_MACH_JAZZ)	+= arch/mips/jazz/
-cflags-$(CONFIG_MACH_JAZZ)	+= -I$(srctree)/arch/mips/include/asm/mach-jazz
-load-$(CONFIG_MACH_JAZZ)	+= 0xffffffff80080000
-
-#
 # Common Alchemy Au1x00 stuff
 #
-core-$(CONFIG_SOC_AU1X00)	+= arch/mips/alchemy/common/
-cflags-$(CONFIG_SOC_AU1X00)	+= -I$(srctree)/arch/mips/include/asm/mach-au1x00
-
-#
-# AMD Alchemy Pb1000 eval board
-#
-core-$(CONFIG_MIPS_PB1000)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_PB1000)	+= -I$(srctree)/arch/mips/include/asm/mach-pb1x00
-load-$(CONFIG_MIPS_PB1000)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Pb1100 eval board
-#
-core-$(CONFIG_MIPS_PB1100)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_PB1100)	+= -I$(srctree)/arch/mips/include/asm/mach-pb1x00
-load-$(CONFIG_MIPS_PB1100)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Pb1500 eval board
-#
-core-$(CONFIG_MIPS_PB1500)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_PB1500)	+= -I$(srctree)/arch/mips/include/asm/mach-pb1x00
-load-$(CONFIG_MIPS_PB1500)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Pb1550 eval board
-#
-core-$(CONFIG_MIPS_PB1550)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_PB1550)	+= -I$(srctree)/arch/mips/include/asm/mach-pb1x00
-load-$(CONFIG_MIPS_PB1550)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Pb1200 eval board
-#
-core-$(CONFIG_MIPS_PB1200)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_PB1200)	+= -I$(srctree)/arch/mips/include/asm/mach-pb1x00
-load-$(CONFIG_MIPS_PB1200)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Db1000 eval board
-#
-core-$(CONFIG_MIPS_DB1000)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_DB1000)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_DB1000)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Db1100 eval board
-#
-core-$(CONFIG_MIPS_DB1100)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_DB1100)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_DB1100)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Db1500 eval board
-#
-core-$(CONFIG_MIPS_DB1500)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_DB1500)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_DB1500)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Db1550 eval board
-#
-core-$(CONFIG_MIPS_DB1550)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_DB1550)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_DB1550)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Db1200 eval board
-#
-core-$(CONFIG_MIPS_DB1200)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_DB1200)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_DB1200)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Bosporus eval board
-#
-core-$(CONFIG_MIPS_BOSPORUS)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_BOSPORUS)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_BOSPORUS)	+= 0xffffffff80100000
-
-#
-# AMD Alchemy Mirage eval board
-#
-core-$(CONFIG_MIPS_MIRAGE)	+= arch/mips/alchemy/devboards/
-cflags-$(CONFIG_MIPS_MIRAGE)	+= -I$(srctree)/arch/mips/include/asm/mach-db1x00
-load-$(CONFIG_MIPS_MIRAGE)	+= 0xffffffff80100000
-
-#
-# 4G-Systems eval board
-#
-libs-$(CONFIG_MIPS_MTX1)	+= arch/mips/alchemy/mtx-1/
-load-$(CONFIG_MIPS_MTX1)	+= 0xffffffff80100000
-
-#
-# MyCable eval board
-#
-libs-$(CONFIG_MIPS_XXS1500)	+= arch/mips/alchemy/xxs1500/
-load-$(CONFIG_MIPS_XXS1500)	+= 0xffffffff80100000
 
 #
 # Cobalt Server
-#
-core-$(CONFIG_MIPS_COBALT)	+= arch/mips/cobalt/
-cflags-$(CONFIG_MIPS_COBALT)	+= -I$(srctree)/arch/mips/include/asm/mach-cobalt
-load-$(CONFIG_MIPS_COBALT)	+= 0xffffffff80080000
 
 #
 # DECstation family
@@ -300,17 +179,9 @@
 #
 # Wind River PPMC Board (4KC + GT64120)
 #
-core-$(CONFIG_WR_PPMC)		+= arch/mips/gt64120/wrppmc/
-cflags-$(CONFIG_WR_PPMC)		+= -I$(srctree)/arch/mips/include/asm/mach-wrppmc
-load-$(CONFIG_WR_PPMC)		+= 0xffffffff80100000
-
 #
 # lemote fulong mini-PC board
 #
-core-$(CONFIG_LEMOTE_FULONG) +=arch/mips/lemote/lm2e/
-load-$(CONFIG_LEMOTE_FULONG) +=0xffffffff80100000
-cflags-$(CONFIG_LEMOTE_FULONG) += -I$(srctree)/arch/mips/include/asm/mach-lemote
-
 #
 # MIPS Malta board
 #
@@ -319,6 +190,15 @@
 load-$(CONFIG_MIPS_MALTA)	+= 0xffffffff80100000
 all-$(CONFIG_MIPS_MALTA)	:= vmlinux.bin
 
+core-$(CONFIG_RTL_8196B)         += arch/mips/rtl8196b/
+cflags-$(CONFIG_RTL_8196B)       += -I$(srctree)/arch/mips/include/asm/mach-realtek/rtl8196b -fno-builtin -D__KERNEL__
+cflags-$(CONFIG_RTL_8196B)       += -march=5181
+load-$(CONFIG_RTL_8196B)         += 0xffffffff80000000
+
+core-$(CONFIG_RTL_8196C)         += arch/mips/rtl8196c/
+cflags-$(CONFIG_RTL_8196C)       += -I$(srctree)/arch/mips/include/asm/mach-realtek/rtl8196c -fno-builtin -D__KERNEL__
+cflags-$(CONFIG_RTL_8196C)       += -march=4181
+load-$(CONFIG_RTL_8196C)         += 0xffffffff80000000
 #
 # MIPS SIM
 #
@@ -344,87 +224,13 @@
 #
 # Basler eXcite
 #
-core-$(CONFIG_BASLER_EXCITE)	+= arch/mips/basler/excite/
-cflags-$(CONFIG_BASLER_EXCITE)	+= -I$(srctree)/arch/mips/include/asm/mach-excite
-load-$(CONFIG_BASLER_EXCITE)	+= 0x80100000
-
 #
 # LASAT platforms
 #
-core-$(CONFIG_LASAT)		+= arch/mips/lasat/
-cflags-$(CONFIG_LASAT)		+= -I$(srctree)/arch/mips/include/asm/mach-lasat
-load-$(CONFIG_LASAT)		+= 0xffffffff80000000
 
 #
 # Common VR41xx
 #
-core-$(CONFIG_MACH_VR41XX)	+= arch/mips/vr41xx/common/
-cflags-$(CONFIG_MACH_VR41XX)	+= -I$(srctree)/arch/mips/include/asm/mach-vr41xx
-
-#
-# ZAO Networks Capcella (VR4131)
-#
-load-$(CONFIG_ZAO_CAPCELLA)	+= 0xffffffff80000000
-
-#
-# Victor MP-C303/304 (VR4122)
-#
-load-$(CONFIG_VICTOR_MPC30X)	+= 0xffffffff80001000
-
-#
-# IBM WorkPad z50 (VR4121)
-#
-core-$(CONFIG_IBM_WORKPAD)	+= arch/mips/vr41xx/ibm-workpad/
-load-$(CONFIG_IBM_WORKPAD)	+= 0xffffffff80004000
-
-#
-# CASIO CASSIPEIA E-55/65 (VR4111)
-#
-core-$(CONFIG_CASIO_E55)	+= arch/mips/vr41xx/casio-e55/
-load-$(CONFIG_CASIO_E55)	+= 0xffffffff80004000
-
-#
-# TANBAC VR4131 multichip module(TB0225) and TANBAC VR4131DIMM(TB0229) (VR4131)
-#
-load-$(CONFIG_TANBAC_TB022X)	+= 0xffffffff80000000
-
-# NXP STB225
-core-$(CONFIG_SOC_PNX833X)		+= arch/mips/nxp/pnx833x/common/
-cflags-$(CONFIG_SOC_PNX833X)	+= -Iarch/mips/include/asm/mach-pnx833x
-libs-$(CONFIG_NXP_STB220)		+= arch/mips/nxp/pnx833x/stb22x/
-load-$(CONFIG_NXP_STB220)		+= 0xffffffff80001000
-libs-$(CONFIG_NXP_STB225)		+= arch/mips/nxp/pnx833x/stb22x/
-load-$(CONFIG_NXP_STB225)		+= 0xffffffff80001000
-
-#
-# Common NXP PNX8550
-#
-core-$(CONFIG_SOC_PNX8550)	+= arch/mips/nxp/pnx8550/common/
-cflags-$(CONFIG_SOC_PNX8550)	+= -I$(srctree)/arch/mips/include/asm/mach-pnx8550
-
-#
-# NXP PNX8550 JBS board
-#
-libs-$(CONFIG_PNX8550_JBS)	+= arch/mips/nxp/pnx8550/jbs/
-#cflags-$(CONFIG_PNX8550_JBS)	+= -I$(srctree)/arch/mips/include/asm/mach-pnx8550
-load-$(CONFIG_PNX8550_JBS)	+= 0xffffffff80060000
-
-# NXP PNX8550 STB810 board
-#
-libs-$(CONFIG_PNX8550_STB810)	+= arch/mips/nxp/pnx8550/stb810/
-load-$(CONFIG_PNX8550_STB810)	+= 0xffffffff80060000
-
-#
-# Common NEC EMMAXXX
-#
-core-$(CONFIG_SOC_EMMA2RH)	+= arch/mips/emma/common/
-cflags-$(CONFIG_SOC_EMMA2RH)	+= -I$(srctree)/arch/mips/include/asm/mach-emma2rh
-
-#
-# NEC EMMA2RH Mark-eins
-#
-core-$(CONFIG_NEC_MARKEINS)	+= arch/mips/emma/markeins/
-load-$(CONFIG_NEC_MARKEINS)	+= 0xffffffff88100000
 
 #
 # SGI IP22 (Indy/Indigo2)
@@ -435,14 +241,6 @@
 # current variable will break so for 64-bit kernels we have to raise the start
 # address by 8kb.
 #
-core-$(CONFIG_SGI_IP22)		+= arch/mips/sgi-ip22/
-cflags-$(CONFIG_SGI_IP22)	+= -I$(srctree)/arch/mips/include/asm/mach-ip22
-ifdef CONFIG_32BIT
-load-$(CONFIG_SGI_IP22)		+= 0xffffffff88002000
-endif
-ifdef CONFIG_64BIT
-load-$(CONFIG_SGI_IP22)		+= 0xffffffff88004000
-endif
 
 #
 # SGI-IP27 (Origin200/2000)
@@ -451,18 +249,6 @@
 # symmon, 0xc00000000001c000 for production kernels.  Note that the value must
 # be 16kb aligned or the handling of the current variable will break.
 #
-ifdef CONFIG_SGI_IP27
-core-$(CONFIG_SGI_IP27)		+= arch/mips/sgi-ip27/
-cflags-$(CONFIG_SGI_IP27)	+= -I$(srctree)/arch/mips/include/asm/mach-ip27
-ifdef CONFIG_MAPPED_KERNEL
-load-$(CONFIG_SGI_IP27)		+= 0xc00000004001c000
-OBJCOPYFLAGS			:= --change-addresses=0x3fffffff80000000
-dataoffset-$(CONFIG_SGI_IP27)	+= 0x01000000
-else
-load-$(CONFIG_SGI_IP27)		+= 0xa80000000001c000
-OBJCOPYFLAGS			:= --change-addresses=0x57ffffff80000000
-endif
-endif
 
 #
 # SGI IP28 (Indigo2 R10k)
@@ -477,9 +263,6 @@
       $(error gcc doesn't support needed option -mr10k-cache-barrier=store)
   endif
 endif
-core-$(CONFIG_SGI_IP28)		+= arch/mips/sgi-ip22/
-cflags-$(CONFIG_SGI_IP28)	+= -mr10k-cache-barrier=store -I$(srctree)/arch/mips/include/asm/mach-ip28
-load-$(CONFIG_SGI_IP28)		+= 0xa800000020004000
 
 #
 # SGI-IP32 (O2)
@@ -489,9 +272,6 @@
 # a multiple of the kernel stack size or the handling of the current variable
 # will break.
 #
-core-$(CONFIG_SGI_IP32)		+= arch/mips/sgi-ip32/
-cflags-$(CONFIG_SGI_IP32)	+= -I$(srctree)/arch/mips/include/asm/mach-ip32
-load-$(CONFIG_SGI_IP32)		+= 0xffffffff80004000
 
 #
 # Sibyte SB1250/BCM1480 SOC
@@ -500,25 +280,6 @@
 # the sequence; but it is built as an object so that modules don't get
 # removed (as happens, even if they have __initcall/module_init)
 #
-core-$(CONFIG_SIBYTE_BCM112X)	+= arch/mips/sibyte/sb1250/
-core-$(CONFIG_SIBYTE_BCM112X)	+= arch/mips/sibyte/common/
-cflags-$(CONFIG_SIBYTE_BCM112X)	+= -I$(srctree)/arch/mips/include/asm/mach-sibyte \
-			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1250_112x_ALL
-
-core-$(CONFIG_SIBYTE_SB1250)	+= arch/mips/sibyte/sb1250/
-core-$(CONFIG_SIBYTE_SB1250)	+= arch/mips/sibyte/common/
-cflags-$(CONFIG_SIBYTE_SB1250)	+= -I$(srctree)/arch/mips/include/asm/mach-sibyte \
-			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1250_112x_ALL
-
-core-$(CONFIG_SIBYTE_BCM1x55)	+= arch/mips/sibyte/bcm1480/
-core-$(CONFIG_SIBYTE_BCM1x55)	+= arch/mips/sibyte/common/
-cflags-$(CONFIG_SIBYTE_BCM1x55)	+= -I$(srctree)/arch/mips/include/asm/mach-sibyte \
-			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1480_ALL
-
-core-$(CONFIG_SIBYTE_BCM1x80)	+= arch/mips/sibyte/bcm1480/
-core-$(CONFIG_SIBYTE_BCM1x80)	+= arch/mips/sibyte/common/
-cflags-$(CONFIG_SIBYTE_BCM1x80)	+= -I$(srctree)/arch/mips/include/asm/mach-sibyte \
-			-DSIBYTE_HDR_FEATURES=SIBYTE_HDR_FMASK_1480_ALL
 
 #
 # Sibyte BCM91120x (Carmel) board
@@ -528,80 +289,17 @@
 # Sibyte SWARM board
 # Sibyte BCM91x80 (BigSur) board
 #
-core-$(CONFIG_SIBYTE_CARMEL)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_CARMEL)	:= 0xffffffff80100000
-core-$(CONFIG_SIBYTE_CRHINE)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_CRHINE)	:= 0xffffffff80100000
-core-$(CONFIG_SIBYTE_CRHONE)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_CRHONE)	:= 0xffffffff80100000
-core-$(CONFIG_SIBYTE_RHONE)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_RHONE)	:= 0xffffffff80100000
-core-$(CONFIG_SIBYTE_SENTOSA)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_SENTOSA)	:= 0xffffffff80100000
-core-$(CONFIG_SIBYTE_SWARM)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_SWARM)	:= 0xffffffff80100000
-core-$(CONFIG_SIBYTE_BIGSUR)	+= arch/mips/sibyte/swarm/
-load-$(CONFIG_SIBYTE_BIGSUR)	:= 0xffffffff80100000
 
 #
 # Broadcom BCM47XX boards
 #
-core-$(CONFIG_BCM47XX)		+= arch/mips/bcm47xx/
-cflags-$(CONFIG_BCM47XX)	+= -I$(srctree)/arch/mips/include/asm/mach-bcm47xx
-load-$(CONFIG_BCM47XX)		:= 0xffffffff80001000
-
 #
 # SNI RM
 #
-core-$(CONFIG_SNI_RM)		+= arch/mips/sni/
-cflags-$(CONFIG_SNI_RM)		+= -I$(srctree)/arch/mips/include/asm/mach-rm
-ifdef CONFIG_CPU_LITTLE_ENDIAN
-load-$(CONFIG_SNI_RM)		+= 0xffffffff80600000
-else
-load-$(CONFIG_SNI_RM)		+= 0xffffffff80030000
-endif
-all-$(CONFIG_SNI_RM)		:= vmlinux.ecoff
-
-#
-# Common TXx9
-#
-core-$(CONFIG_MACH_TX39XX)	+= arch/mips/txx9/generic/
-cflags-$(CONFIG_MACH_TX39XX) += -I$(srctree)/arch/mips/include/asm/mach-tx39xx
-load-$(CONFIG_MACH_TX39XX)	+= 0xffffffff80050000
-core-$(CONFIG_MACH_TX49XX)	+= arch/mips/txx9/generic/
-cflags-$(CONFIG_MACH_TX49XX) += -I$(srctree)/arch/mips/include/asm/mach-tx49xx
-load-$(CONFIG_MACH_TX49XX)	+= 0xffffffff80100000
-
-#
-# Toshiba JMR-TX3927 board
-#
-core-$(CONFIG_TOSHIBA_JMR3927)	+= arch/mips/txx9/jmr3927/
-
-#
-# Routerboard 532 board
-#
-core-$(CONFIG_MIKROTIK_RB532)	+= arch/mips/rb532/
-cflags-$(CONFIG_MIKROTIK_RB532) += -I$(srctree)/arch/mips/include/asm/mach-rc32434
-load-$(CONFIG_MIKROTIK_RB532)	+= 0xffffffff80101000
-
-#
-# Toshiba RBTX49XX boards
-#
-core-$(CONFIG_TOSHIBA_RBTX4927)	+= arch/mips/txx9/rbtx4927/
-core-$(CONFIG_TOSHIBA_RBTX4938) += arch/mips/txx9/rbtx4938/
-core-$(CONFIG_TOSHIBA_RBTX4939) += arch/mips/txx9/rbtx4939/
 
 #
 # Cavium Octeon
 #
-core-$(CONFIG_CPU_CAVIUM_OCTEON)	+= arch/mips/cavium-octeon/
-cflags-$(CONFIG_CPU_CAVIUM_OCTEON)	+= -I$(srctree)/arch/mips/include/asm/mach-cavium-octeon
-core-$(CONFIG_CPU_CAVIUM_OCTEON)	+= arch/mips/cavium-octeon/executive/
-ifdef CONFIG_CAVIUM_OCTEON_2ND_KERNEL
-load-$(CONFIG_CPU_CAVIUM_OCTEON)	+= 0xffffffff84100000
-else
-load-$(CONFIG_CPU_CAVIUM_OCTEON) 	+= 0xffffffff81100000
-endif
 
 cflags-y			+= -I$(srctree)/arch/mips/include/asm/mach-generic
 drivers-$(CONFIG_PCI)		+= arch/mips/pci/
@@ -728,7 +426,7 @@
 
 archclean:
 	@$(MAKE) $(clean)=arch/mips/boot
-	@$(MAKE) $(clean)=arch/mips/lasat
+	#@$(MAKE) $(clean)=arch/mips/lasat
 
 define archhelp
 	echo '  install              - install kernel into $(INSTALL_PATH)'
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/mm/c-r3k.c linux-2.6.30.9-rsdk/arch/mips/mm/c-r3k.c
--- linux-2.6.30.9/arch/mips/mm/c-r3k.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/mm/c-r3k.c	2011-12-05 15:50:14.000000000 +0000
@@ -25,6 +25,24 @@
 
 static unsigned long icache_size, dcache_size;		/* Size in bytes */
 static unsigned long icache_lsize, dcache_lsize;	/* Size in bytes */
+#ifdef CONFIG_RTL865XC 
+/* For Realtek RTL865XC Network platform series */
+#define _ICACHE_SIZE		(16 * 1024)		/* 16K bytes */
+#define _DCACHE_SIZE		(8 * 1024)		/* 8K bytes */
+#define _CACHE_LINE_SIZE	4			/* 4 words */
+extern void (*_dma_cache_wback_inv)(unsigned long start, unsigned long size);
+#elif defined(CONFIG_RTL_819X)
+/* For Realtek RTL865XC Network platform series */
+#define _ICACHE_SIZE		(16 * 1024)		/* 16K bytes */
+#define _DCACHE_SIZE		(8 * 1024)		/* 8K bytes */
+#define _CACHE_LINE_SIZE	4			/* 4 words */
+extern void (*_dma_cache_wback_inv)(unsigned long start, unsigned long size);
+#elif defined (CONFIG_RTL865XB)
+/* For Realtek RTL865XB Network platform series */
+#define _ICACHE_SIZE	(4 * 1024)			/* 4K bytes */
+#define _DCACHE_SIZE	(4 * 1024)			/* 4K bytes */
+#define _CACHE_LIN
+#endif
 
 unsigned long __cpuinit r3k_cache_size(unsigned long ca_flags)
 {
@@ -92,6 +110,17 @@
 
 static void __cpuinit r3k_probe_cache(void)
 {
+#if defined(CONFIG_RTL865XB)
+   dcache_size = 4 << 10;
+   dcache_lsize = 16;
+   icache_size = 4 << 10;
+   icache_lsize = 16;
+#elif defined(CONFIG_RTL8652) || defined(CONFIG_RTL_819X)
+   dcache_size = 8 << 10;
+   dcache_lsize = 16;
+   icache_size = 16 << 10;
+   icache_lsize = 16;
+#else
 	dcache_size = r3k_cache_size(ST0_ISC);
 	if (dcache_size)
 		dcache_lsize = r3k_cache_lsize(ST0_ISC);
@@ -99,10 +128,46 @@
 	icache_size = r3k_cache_size(ST0_ISC|ST0_SWC);
 	if (icache_size)
 		icache_lsize = r3k_cache_lsize(ST0_ISC|ST0_SWC);
+#endif
 }
 
+static void r3k_flush_dcache_range(unsigned long start, unsigned long end);
 static void r3k_flush_icache_range(unsigned long start, unsigned long end)
 {
+#if defined(CONFIG_RTL865XB) || defined(CONFIG_RTL8652) || defined(CONFIG_RTL_819X)
+	unsigned long flags;
+        /*
+                Flush data cache at first in write-back platform.
+ 
+                Ghhuang (2007/3/9):
+ 
+                RD-Center suggest that we need to flush D-cache entries which
+                might match to same address as I-cache ... when we flush
+                I-cache.
+                ( Maybe some data is treated as data/instruction, both. )
+		
+		Hf_shi copy from RTL8651C Platform
+        */
+	r3k_flush_dcache_range(start, end);
+
+	flags = read_c0_status();
+	write_c0_status((ST0_ISC|ST0_SWC|flags)&~ST0_IEC);
+
+	__asm__ volatile(
+		"mtc0 $0,$20\n\t"
+		"nop\n\t"
+		"li $8,2\n\t"
+		"mtc0 $8,$20\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"mtc0 $0,$20\n\t"
+		"nop"
+		: /* no output */
+		: /* no input */
+			);
+
+	write_c0_status(flags);
+#else
 	unsigned long size, i, flags;
 	volatile unsigned char *p;
 
@@ -156,10 +221,99 @@
 	}
 
 	write_c0_status(flags);
+#endif
 }
 
 static void r3k_flush_dcache_range(unsigned long start, unsigned long end)
 {
+#if defined(CONFIG_RTL865XB)
+	unsigned long flags;
+
+	flags = read_c0_status();
+	write_c0_status((ST0_ISC|ST0_SWC|flags)&~ST0_IEC);
+
+	__asm__ volatile(
+		"mtc0 $0,$20\n\t"
+		"nop\n\t"
+		"li $8,1\n\t"
+		"mtc0 $8,$20\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"mtc0 $0,$20\n\t"
+		"nop"
+		: /* no output */
+		: /* no input */
+			);
+	write_c0_status(flags);
+#elif defined(CONFIG_RTL8652) || defined(CONFIG_RTL_819X)
+
+#if 0
+	unsigned long flags;
+
+	flags = read_c0_status();
+	write_c0_status((flags)&~ST0_IEC);
+
+	__asm__ volatile(
+		"mtc0 $0,$20\n\t"
+		"nop\n\t"
+		"li $8,512\n\t"
+		"mtc0 $8,$20\n\t"
+		"nop\n\t"
+		"nop\n\t"
+		"mtc0 $0,$20\n\t"
+		"nop"
+		: /* no output */
+		: /* no input */
+			);
+
+	write_c0_status(flags);
+#else
+	unsigned long size, i, flags;
+	volatile unsigned char *p;
+	start = start & (~0xF);
+	size = end - start;
+	#ifdef CONFIG_RTL_819X
+	size += 64; //jason, flush one more cache line for CPU write-buffer issue
+	#endif	
+	if (size > dcache_size || KSEGX(start) != KSEG0) {
+		start = KSEG0;
+		size = dcache_size;
+		#ifdef CONFIG_RTL_819X
+		size += 64; //jason, flush one more cache line for CPU write-buffer issue
+		#endif
+
+	}
+	p = (char *)start;
+
+	flags = read_c0_status();
+	write_c0_status((flags)&~ST0_IEC);
+
+	for (i = 0; i < size; i += 0x080) {
+		asm ( 	"cache\t0x15, 0x000(%0)\n\t"
+			"cache\t0x15, 0x010(%0)\n\t"
+			"cache\t0x15, 0x020(%0)\n\t"
+			"cache\t0x15, 0x030(%0)\n\t"
+			"cache\t0x15, 0x040(%0)\n\t"
+			"cache\t0x15, 0x050(%0)\n\t"
+			"cache\t0x15, 0x060(%0)\n\t"
+			"cache\t0x15, 0x070(%0)\n\t"
+			: : "r" (p) );
+		p += 0x080;
+	}
+
+	write_c0_status(flags);
+	__asm__ __volatile__(			\
+		".set	push\n\t"		\
+		".set	noreorder\n\t"		\
+		"lw	$0,%0\n\t"		\
+		"nop\n\t"			\
+		".set	pop"			\
+		: /* no output */		\
+		: "m" (*(int *)CKSEG1)		\
+		: "memory");
+#endif
+
+#else
 	unsigned long size, i, flags;
 	volatile unsigned char *p;
 
@@ -213,6 +367,7 @@
 	}
 
 	write_c0_status(flags);
+#endif
 }
 
 static inline void r3k_flush_cache_all(void)
@@ -291,9 +446,14 @@
 
 	write_c0_status((ST0_ISC|ST0_SWC|flags)&~ST0_IEC);
 
+#if defined(CONFIG_RTL8652) || defined(CONFIG_RTL_819X)
+	asm ( 	"cache\t0x15, 0x000(%0)\n\t"
+		: : "r" (addr) );
+#else
 	asm( 	"sb\t$0, 0x000(%0)\n\t"
 		"sb\t$0, 0x004(%0)\n\t"
 		: : "r" (addr) );
+#endif
 
 	write_c0_status(flags);
 }
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/mm/init.c linux-2.6.30.9-rsdk/arch/mips/mm/init.c
--- linux-2.6.30.9/arch/mips/mm/init.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/mm/init.c	2011-12-05 15:50:14.000000000 +0000
@@ -319,20 +319,11 @@
 {
 	unsigned long max_zone_pfns[MAX_NR_ZONES];
 	unsigned long lastpfn;
-
 	pagetable_init();
-
 #ifdef CONFIG_HIGHMEM
 	kmap_init();
 #endif
 	kmap_coherent_init();
-
-#ifdef CONFIG_ZONE_DMA
-	max_zone_pfns[ZONE_DMA] = MAX_DMA_PFN;
-#endif
-#ifdef CONFIG_ZONE_DMA32
-	max_zone_pfns[ZONE_DMA32] = MAX_DMA32_PFN;
-#endif
 	max_zone_pfns[ZONE_NORMAL] = max_low_pfn;
 	lastpfn = max_low_pfn;
 #ifdef CONFIG_HIGHMEM
@@ -347,7 +338,6 @@
 		lastpfn = max_low_pfn;
 	}
 #endif
-
 	free_area_init_nodes(max_zone_pfns);
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/arch/mips/mm/tlbex.c linux-2.6.30.9-rsdk/arch/mips/mm/tlbex.c
--- linux-2.6.30.9/arch/mips/mm/tlbex.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/arch/mips/mm/tlbex.c	2011-12-05 15:50:14.000000000 +0000
@@ -187,7 +187,7 @@
 
 	memcpy((void *)ebase, tlb_handler, 0x80);
 
-	dump_handler((u32 *)ebase, 32);
+	//dump_handler((u32 *)ebase, 32);
 }
 
 /*
@@ -263,6 +263,7 @@
 		return;
 	}
 
+	printk("---%s(%d),cpu_type(%d)\n",__FUNCTION__,__LINE__,current_cpu_type());
 	switch (current_cpu_type()) {
 	case CPU_R4000PC:
 	case CPU_R4000SC:
@@ -759,7 +760,7 @@
 
 	memcpy((void *)ebase, final_handler, 0x100);
 
-	dump_handler((u32 *)ebase, 64);
+	//dump_handler((u32 *)ebase, 64);
 }
 
 /*
@@ -1010,7 +1011,7 @@
 	pr_debug("Wrote TLB load handler fastpath (%u instructions).\n",
 		 (unsigned int)(p - handle_tlbl));
 
-	dump_handler(handle_tlbl, ARRAY_SIZE(handle_tlbl));
+	//dump_handler(handle_tlbl, ARRAY_SIZE(handle_tlbl));
 }
 
 static void __cpuinit build_r3000_tlb_store_handler(void)
@@ -1040,7 +1041,7 @@
 	pr_debug("Wrote TLB store handler fastpath (%u instructions).\n",
 		 (unsigned int)(p - handle_tlbs));
 
-	dump_handler(handle_tlbs, ARRAY_SIZE(handle_tlbs));
+	//dump_handler(handle_tlbs, ARRAY_SIZE(handle_tlbs));
 }
 
 static void __cpuinit build_r3000_tlb_modify_handler(void)
@@ -1070,7 +1071,7 @@
 	pr_debug("Wrote TLB modify handler fastpath (%u instructions).\n",
 		 (unsigned int)(p - handle_tlbm));
 
-	dump_handler(handle_tlbm, ARRAY_SIZE(handle_tlbm));
+	//dump_handler(handle_tlbm, ARRAY_SIZE(handle_tlbm));
 }
 
 /*
@@ -1155,7 +1156,7 @@
 	pr_debug("Wrote TLB load handler fastpath (%u instructions).\n",
 		 (unsigned int)(p - handle_tlbl));
 
-	dump_handler(handle_tlbl, ARRAY_SIZE(handle_tlbl));
+	//dump_handler(handle_tlbl, ARRAY_SIZE(handle_tlbl));
 }
 
 static void __cpuinit build_r4000_tlb_store_handler(void)
@@ -1186,7 +1187,7 @@
 	pr_debug("Wrote TLB store handler fastpath (%u instructions).\n",
 		 (unsigned int)(p - handle_tlbs));
 
-	dump_handler(handle_tlbs, ARRAY_SIZE(handle_tlbs));
+	//dump_handler(handle_tlbs, ARRAY_SIZE(handle_tlbs));
 }
 
 static void __cpuinit build_r4000_tlb_modify_handler(void)
@@ -1218,7 +1219,7 @@
 	pr_debug("Wrote TLB modify handler fastpath (%u instructions).\n",
 		 (unsigned int)(p - handle_tlbm));
 
-	dump_handler(handle_tlbm, ARRAY_SIZE(handle_tlbm));
+	//dump_handler(handle_tlbm, ARRAY_SIZE(handle_tlbm));
 }
 
 void __cpuinit build_tlb_refill_handler(void)
diff -uNr --ignore-all-space linux-2.6.30.9/crypto/api.c linux-2.6.30.9-rsdk/crypto/api.c
--- linux-2.6.30.9/crypto/api.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/crypto/api.c	2011-12-05 15:50:14.000000000 +0000
@@ -611,5 +611,22 @@
 }
 EXPORT_SYMBOL_GPL(crypto_has_alg);
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+int crypto_alg_available(const char *name, u32 flags)
+{
+       int ret = 0;
+       struct crypto_alg *alg = crypto_alg_mod_lookup(name, 0,
+                                                      CRYPTO_ALG_ASYNC);
+       
+       if (!IS_ERR(alg)) {
+               crypto_mod_put(alg);
+               ret = 1;
+       }
+       
+       return ret;
+}
+EXPORT_SYMBOL_GPL(crypto_alg_available);
+#endif
+
 MODULE_DESCRIPTION("Cryptographic core API");
 MODULE_LICENSE("GPL");
diff -uNr --ignore-all-space linux-2.6.30.9/crypto/digest.c linux-2.6.30.9-rsdk/crypto/digest.c
--- linux-2.6.30.9/crypto/digest.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/crypto/digest.c	2011-12-05 15:50:14.000000000 +0000
@@ -24,6 +24,56 @@
 
 #include "internal.h"
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+void crypto_digest_init(struct crypto_tfm *tfm)
+{
+       struct crypto_hash *hash = crypto_hash_cast(tfm);
+       struct hash_desc desc = { .tfm = hash, .flags = tfm->crt_flags };
+
+       crypto_hash_init(&desc);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_init);
+
+void crypto_digest_update(struct crypto_tfm *tfm,
+                         struct scatterlist *sg, unsigned int nsg)
+{
+       struct crypto_hash *hash = crypto_hash_cast(tfm);
+       struct hash_desc desc = { .tfm = hash, .flags = tfm->crt_flags };
+       unsigned int nbytes = 0;
+       unsigned int i;
+
+       for (i = 0; i < nsg; i++)
+               nbytes += sg[i].length;
+
+       crypto_hash_update(&desc, sg, nbytes);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_update);
+
+void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
+{
+       struct crypto_hash *hash = crypto_hash_cast(tfm);
+       struct hash_desc desc = { .tfm = hash, .flags = tfm->crt_flags };
+
+       crypto_hash_final(&desc, out);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_final);
+
+void crypto_digest_digest(struct crypto_tfm *tfm,
+                         struct scatterlist *sg, unsigned int nsg, u8 *out)
+{
+       struct crypto_hash *hash = crypto_hash_cast(tfm);
+       struct hash_desc desc = { .tfm = hash, .flags = tfm->crt_flags };
+       unsigned int nbytes = 0;
+       unsigned int i;
+
+       for (i = 0; i < nsg; i++)
+               nbytes += sg[i].length;
+
+       crypto_hash_digest(&desc, sg, nbytes, out);
+}
+EXPORT_SYMBOL_GPL(crypto_digest_digest);
+#endif
+
 static int init(struct hash_desc *desc)
 {
 	struct crypto_tfm *tfm = crypto_hash_tfm(desc->tfm);
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/char/Makefile linux-2.6.30.9-rsdk/drivers/char/Makefile
--- linux-2.6.30.9/drivers/char/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/char/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -8,6 +8,7 @@
 FONTMAPFILE = cp437.uni
 
 obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o tty_buffer.o tty_port.o
+EXTRA_CFLAGS += -I.
 
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
@@ -97,6 +98,8 @@
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_RTL_819X)		+= rtl_gpio.o
+obj-$(CONFIG_RTL_NFBI_MDIO)	+= rtl_mdio/
 
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/char/pty.c linux-2.6.30.9-rsdk/drivers/char/pty.c
--- linux-2.6.30.9/drivers/char/pty.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/char/pty.c	2011-12-05 15:50:14.000000000 +0000
@@ -27,6 +27,7 @@
 #include <linux/uaccess.h>
 #include <linux/bitops.h>
 #include <linux/devpts_fs.h>
+#include <linux/smp_lock.h>
 
 #include <asm/system.h>
 
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/media/video/Makefile linux-2.6.30.9-rsdk/drivers/media/video/Makefile
--- linux-2.6.30.9/drivers/media/video/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/media/video/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -31,6 +31,7 @@
 obj-$(CONFIG_VIDEO_TVAUDIO) += tvaudio.o
 obj-$(CONFIG_VIDEO_TDA7432) += tda7432.o
 obj-$(CONFIG_VIDEO_TDA9875) += tda9875.o
+
 obj-$(CONFIG_VIDEO_SAA6588) += saa6588.o
 obj-$(CONFIG_VIDEO_SAA5246A) += saa5246a.o
 obj-$(CONFIG_VIDEO_SAA5249) += saa5249.o
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/media/video/uvc/uvc_video.c linux-2.6.30.9-rsdk/drivers/media/video/uvc/uvc_video.c
--- linux-2.6.30.9/drivers/media/video/uvc/uvc_video.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/media/video/uvc/uvc_video.c	2011-12-05 15:50:14.000000000 +0000
@@ -531,6 +531,14 @@
 		if (urb->iso_frame_desc[i].status < 0) {
 			uvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "
 				"lost (%d).\n", urb->iso_frame_desc[i].status);
+			
+			//Start to avoid to flicking images with isochronous by jason
+			if (buf) {
+				buf->state = UVC_BUF_STATE_QUEUED;
+				buf->buf.bytesused = 0;
+				i = urb->number_of_packets;
+			}		
+			//End to avoid to flicking images with isochronous by jason
 			continue;
 		}
 
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/mtd/chips/Kconfig linux-2.6.30.9-rsdk/drivers/mtd/chips/Kconfig
--- linux-2.6.30.9/drivers/mtd/chips/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/mtd/chips/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -240,6 +240,12 @@
 	  This allows MTD support to work with flash memory which is also
 	  used for XIP purposes.  If you're not sure what this is all about
 	  then say N.
+config RTL819X_SPI_FLASH
+        bool "RTL819x SPI flash support"
+        depends on MTD
+        help
+          Support SPI flash for MX25L,SST series
+
 
 endmenu
 
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/mtd/chips/Makefile linux-2.6.30.9-rsdk/drivers/mtd/chips/Makefile
--- linux-2.6.30.9/drivers/mtd/chips/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/mtd/chips/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -13,3 +13,4 @@
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
 obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
+obj-$(CONFIG_RTL819X_SPI_FLASH) += rtl819x/
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/mtd/devices/doc2001.c linux-2.6.30.9-rsdk/drivers/mtd/devices/doc2001.c
--- linux-2.6.30.9/drivers/mtd/devices/doc2001.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/mtd/devices/doc2001.c	2011-12-05 15:50:14.000000000 +0000
@@ -10,8 +10,11 @@
 #include <asm/errno.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/bitops.h>
@@ -20,6 +23,48 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/doc2000.h>
 
+#ifdef CONFIG_RTL_819X
+/*porting for RTL865xC-RTL8190 SDK by alva_zhang@2007.11*/
+#include <linux/config.h>
+#include <linux/mtd/partitions.h>
+
+#define CALL_APP_TO_LOAD_DEFAULT	// call user program to load default
+extern int flash_hw_start;
+#define noCONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 3
+extern int flash_hw_start, flash_hw_len, flash_ds_start, flash_ds_len, flash_write_flag;
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+#define RTL_BOOTCODE_END (0x6000)
+static struct mtd_partition rtl8196_partitions[ ] = {
+        {
+                name:         "boot+cfg+linux",
+                size:           (CONFIG_RTL_ROOT_IMAGE_OFFSET - 0),
+                offset:         0x00000000,
+        },
+        {
+                name:           "root fs",
+                   size:        (CONFIG_RTL_FLASH_SIZE - CONFIG_RTL_ROOT_IMAGE_OFFSET),
+                offset:         (CONFIG_RTL_ROOT_IMAGE_OFFSET),
+        }
+};
+#else
+static struct mtd_partition rtl8196_partitions[ ] = {
+        {
+                name:         "boot+cfg+linux",
+                size:           0xF0000,
+                offset:         0x00000000,
+        },
+        {
+                name:           "root fs",
+                   size:        0x110000,
+                offset:         0xF0000,
+        }
+};
+#endif
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+#endif /*#ifdef CONFIG_RTL_819X */
+
+
 /* #define ECC_DEBUG */
 
 /* I have no idea why some DoC chips can not use memcop_form|to_io().
@@ -32,12 +77,29 @@
 		    size_t *retlen, u_char *buf);
 static int doc_write(struct mtd_info *mtd, loff_t to, size_t len,
 		     size_t *retlen, const u_char *buf);
+
+#ifdef CONFIG_RTL_819X
+/* Do nothing here*/
+#else
 static int doc_read_oob(struct mtd_info *mtd, loff_t ofs,
 			struct mtd_oob_ops *ops);
 static int doc_write_oob(struct mtd_info *mtd, loff_t ofs,
 			 struct mtd_oob_ops *ops);
+#endif
+
 static int doc_erase (struct mtd_info *mtd, struct erase_info *instr);
 
+#ifdef CONFIG_RTL_819X
+/*porting for RTL865xC-RTL8190 SDK by alva_zhang@2007.11*/
+static int erase_one_block(struct DiskOnChip *this, __u32 addr, __u32 len);
+#endif
+
+#ifdef CONFIG_RTL_819X
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+int find_section_boundary(struct mtd_info *mtd,unsigned int start, unsigned int end, unsigned int *rstart, unsigned *rend);
+#endif
+#endif
+
 static struct mtd_info *docmillist = NULL;
 
 /* Perform the required delay cycles by reading from the NOP register */
@@ -149,6 +211,10 @@
 	DoC_Delay(docptr, 4);
 }
 
+#ifdef CONFIG_RTL_819X
+/*porting for RTL865xC-RTL8190 SDK by alva_zhang@2007.11*/
+/* Do nothing here*/
+#else
 /* DoC_SelectChip: Select a given flash chip within the current floor */
 static int DoC_SelectChip(void __iomem * docptr, int chip)
 {
@@ -281,6 +347,7 @@
 	printk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",
 	       this->numchips ,this->totlen >> 20);
 }
+#endif /*#ifdef CONFIG_RTL_819X */
 
 static int DoCMil_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)
 {
@@ -318,9 +385,16 @@
 void DoCMil_init(struct mtd_info *mtd)
 {
 	struct DiskOnChip *this = mtd->priv;
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 	struct DiskOnChip *old = NULL;
+#endif
 
 	/* We must avoid being called twice for the same device. */
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 	if (docmillist)
 		old = docmillist->priv;
 
@@ -337,17 +411,31 @@
 		else
 			old = NULL;
 	}
+#endif /*CONFIG_RTL_819X*/
 
 	mtd->name = "DiskOnChip Millennium";
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 	printk(KERN_NOTICE "DiskOnChip Millennium found at address 0x%lX\n",
 	       this->physadr);
+#endif
+
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+#ifdef CONFIG_RTL_819X
+#else
+	mtd->ecctype = MTD_ECC_RS_DiskOnChip;
+#endif
 
-	mtd->type = MTD_NANDFLASH;
-	mtd->flags = MTD_CAP_NANDFLASH;
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else	
 	mtd->size = 0;
 
 	/* FIXME: erase size is not always 8KiB */
 	mtd->erasesize = 0x2000;
+#endif
 
 	mtd->writesize = 512;
 	mtd->oobsize = 16;
@@ -357,10 +445,19 @@
 	mtd->unpoint = NULL;
 	mtd->read = doc_read;
 	mtd->write = doc_write;
+
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else		
 	mtd->read_oob = doc_read_oob;
 	mtd->write_oob = doc_write_oob;
+#endif
+
 	mtd->sync = NULL;
 
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else	
 	this->totlen = 0;
 	this->numchips = 0;
 	this->curfloor = -1;
@@ -368,6 +465,7 @@
 
 	/* Ident all the chips present. */
 	DoC_ScanChips(this);
+#endif
 
 	if (!this->totlen) {
 		kfree(mtd);
@@ -376,15 +474,199 @@
 		this->nextdoc = docmillist;
 		docmillist = mtd;
 		mtd->size  = this->totlen;
+//#ifdef CONFIG_RTK_MTD_ROOT
+#ifdef CONFIG_RTL_819X
+		add_mtd_partitions(mtd, rtl8196_partitions,  NB_OF(rtl8196_partitions));
+#else
 		add_mtd_device(mtd);
+#endif
 		return;
 	}
 }
 EXPORT_SYMBOL_GPL(DoCMil_init);
 
+#ifdef CONFIG_RTL_819X 
+static int doc_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const u_char *buf, u_char *eccbuf)
+{
+	int i,ret;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr =(unsigned long) this->virtadr;
+	unsigned int ofs;
+	unsigned short val,val1;
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	unsigned int rstart,rend;
+	unsigned int start,end;
+#endif
+// david ------------
+unsigned long timeo, offset;
+unsigned long flags; 
+//-------------------
+
+	/* Don't allow write past end of device */
+	if (to >= this->totlen)
+	{
+// david
+//		printk("write to >= total len\n");
+	printk(KERN_WARNING "write to >= total len\n");
+		return -EINVAL;
+	}
+	DEBUG(MTD_DEBUG_LEVEL1,"going to write len=0x%x,to =0x%x\n", (int)len, (int)to);
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	start=to;
+	end=0xFFFFFFF;
+	if(flash_write_flag & 1)
+	{
+		if(0 == start)
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_HW_SETTING_OFFSET )
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		end=CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+	}
+			
+	if(flash_write_flag & 2 )
+	{
+		if(0 == start)
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_DEFAULT_SETTING_OFFSET )
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		
+		end = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+	}
+			
+	if( flash_write_flag & 4 )
+	{
+		if(0 == start)
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_CURRENT_SETTING_OFFSET )
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;	
+		end = CONFIG_RTL_WEB_PAGES_OFFSET;
+	}
+	find_section_boundary(mtd,start,end,&rstart,&rend);
+
+#endif
+
+	*retlen = len;
+	ofs = docptr + to;
+	for(i=0; i< len; i+=2)
+	{
+// david -----------------------------------------------------
+#if 0
+		val = *(unsigned short *)buf;
+
+		*(volatile unsigned short *)(0xbfc00000 + 0x555 * 2)= 0xaa;
+		*(volatile unsigned short *)(0xbfc00000 + 0x2aa * 2)= 0x55;
+		*(volatile unsigned short *)(0xbfc00000 + 0x555 * 2)= 0xa0;
+		*(volatile unsigned short *)(ofs )= val;
+
+	       	j=0xfffff1;
+        	do{
+                	val1=*(volatile unsigned short *)(ofs);
+  	            	if( ((val1^val) & 0x80)==0 )
+ 				break;
+
+       		}while(j--!=1);
+		if (j <= 2)
+			printk("program fails\n");
+#else
+
+//		if ( ofs < (docptr+CONFIG_MTD_DOCPROBE_ADDRESS) )
+//			goto next_word;
+
+		offset = (to >> this->chipshift)*(1 << this->chipshift);
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+		if(ofs <(docptr+rstart))
+			goto next_word;
+		if(ofs >= (docptr+rend))
+		{
+			return 0;
+		}
+#else
+#if !defined(COMPACK_SETTING) && !defined(NO_CHECK_REGION)
+		if ( flash_write_flag != 0x8000
+//#ifdef CONFIG_RTK_MTD_ROOT
+#ifdef CONFIG_RTL_819X
+			|| offset < (rtl8196_partitions[0].size+ rtl8196_partitions[0].offset)
+#endif
+			)
+		{
+
+			if ( (flash_write_flag & 1) && (ofs < (docptr+flash_hw_start)) )
+				goto next_word;
+
+			if ( (flash_write_flag & 2) && (ofs < (docptr+flash_ds_start)) )
+				goto next_word;
+
+			if ( (flash_write_flag & 4) && (ofs < (docptr+flash_ds_start+flash_ds_len)) )
+				goto next_word;
+		}
+#endif // COMPACK_SETTING && NO_CHECK_REGION
+#endif //CONFIG_RTL_FLASH_MAPPING_ENABLE
+		val = *(unsigned short *)buf;
+
+		mtd_save_flags(flags);mtd_cli(); // david
+		
+		*(volatile unsigned short *)(0xbfc00000 + offset + 0x555 * 2)= 0xaa;
+		*(volatile unsigned short *)(0xbfc00000 + offset + 0x2aa * 2)= 0x55;
+		*(volatile unsigned short *)(0xbfc00000 + offset + 0x555 * 2)= 0xa0;
+		*(volatile unsigned short *)(ofs )= val;
+		
+		mtd_restore_flags(flags); // david
+
+		timeo = jiffies + (HZ * 50);
+        	do{    		
+#if 0
+			val1=*(volatile unsigned short *)(ofs);
+			if ( val1 == val )
+				break;
+#endif
+			unsigned short val2;
+      	
+			val2=*(volatile unsigned short *)(ofs);
+			val1=*(volatile unsigned short *)(ofs);	
+			
+			if (((val1^val2) & 0x40) != 0)
+				continue;	 	        
+	 	        if (((val1^val) & 0x80) != 0)
+ 				continue;
+ 			if ( val1 == val )		
+				break;
+//--------------	      	    	
+		} while ( !time_after(jiffies, timeo) );
+
+		if ( time_after(jiffies, timeo)) {
+			printk(KERN_WARNING "program timeout!");
+			printk(KERN_WARNING " write: %x, read:%x, addr: %x\n", val, val1, ofs);
+			return -1;
+		}
+
+#ifndef COMPACK_SETTING
+next_word:
+#endif
+
+#endif
+//---------------------------------------------------------
+		ofs += 2;
+		buf += 2;
+	
+	}
+
+	ret = 0 ;
+//	printk("in doc_write_ecc ret=%08x\n", ret);
+	return ret;
+}
+#endif /* #ifdef CONFIG_RTL_819X  */
+
 static int doc_read (struct mtd_info *mtd, loff_t from, size_t len,
 		     size_t *retlen, u_char *buf)
 {
+#ifdef CONFIG_RTL_819X 
+static int doc_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf, u_char *eccbuf);
+/* Just a special case of doc_read_ecc */
+	return doc_read_ecc(mtd, from, len, retlen, buf, NULL);
+#else
 	int i, ret;
 	volatile char dummy;
 	unsigned char syndrome[6], eccbuf[6];
@@ -491,11 +773,49 @@
 	WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
 
 	return ret;
+
+#endif /* #ifdef CONFIG_RTL_819X  */
 }
 
+#ifdef CONFIG_RTL_819X 
+static int doc_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf, u_char *eccbuf)
+{
+	int i;
+	unsigned short tmp;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr+from;
+
+	/* Don't allow read past end of device */
+	if (from >= this->totlen)
+		return -EINVAL;
+	for(i=0; i< len; i+=2)
+	{
+		tmp = *(volatile unsigned short *)(docptr);
+		*(unsigned short *)buf = tmp;
+		buf += 2;
+		docptr +=2;
+	}
+	if (len & 0x01)
+	{
+		tmp = *(volatile unsigned long *)(docptr);
+        *(unsigned char *)buf = (tmp >> 8) & 0xff;
+	}
+
+	/* Let the caller know we completed it */
+	*retlen = len;
+
+	return 0;
+}
+#endif /*#ifdef CONFIG_RTL_819X */
+
 static int doc_write (struct mtd_info *mtd, loff_t to, size_t len,
 		      size_t *retlen, const u_char *buf)
 {
+#ifdef CONFIG_RTL_819X 
+       char eccbuf[6];
+	return doc_write_ecc(mtd, to, len, retlen, buf, eccbuf);
+#else
 	int i,ret = 0;
 	char eccbuf[6];
 	volatile char dummy;
@@ -617,8 +937,12 @@
 	*retlen = len;
 
 	return ret;
+#endif /*#ifdef CONFIG_RTL_819X  */
 }
 
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 static int doc_read_oob(struct mtd_info *mtd, loff_t ofs,
 			struct mtd_oob_ops *ops)
 {
@@ -753,9 +1077,229 @@
 
 	return ret;
 }
+#endif /*#ifdef CONFIG_RTL_819X  */
+
+#ifdef CONFIG_RTL_819X
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+int find_section_boundary(struct mtd_info *mtd,unsigned int start, unsigned int end, unsigned int *rstart, unsigned *rend)
+{
+	int i = 0;
+	int j = 0;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+	while ((i < mtd->numeraseregions) &&
+		(start >= regions[i].offset)) {
+		i++;
+	}
+	i--;
+
+	j = 1;
+	while((j <= regions[i].numblocks) &&
+		(start >= (regions[i].offset+regions[i].erasesize*j))) {
+		j++;
+	}
+	*rstart=(regions[i].offset+regions[i].erasesize*(j-1));
+	
+	i=0;
+	while ((i < mtd->numeraseregions) &&
+		(end >= regions[i].offset)) {
+		 i++;
+	}
+	i--;
+
+	j = 1;
+	while((j <= regions[i].numblocks) &&
+		(end >= (regions[i].offset+regions[i].erasesize*j))) {
+		j++;
+	}
+	*rend=(regions[i].offset+regions[i].erasesize*j);
+	
+}
+#endif
+#endif
 
 int doc_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
+#ifdef CONFIG_RTL_819X 
+
+struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long adr, len;
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
+	unsigned int rstart,rend;
+        unsigned int start,end;
+#endif
+	int i;
+	int first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	DEBUG(MTD_DEBUG_LEVEL1, "going to erase sector addr=%08x,len=%08x\n",
+		instr->addr, instr->len);
+
+	if (instr->addr > mtd->size) {
+		printk(KERN_WARNING "Erase addr greater than max size (0x%x > 0x%x)\n",
+			instr->addr, mtd->size );
+		return -EINVAL;
+	}
+
+	if ((instr->len + instr->addr) > mtd->size) {
+		printk(KERN_WARNING "Erase size greater than max size (0x%x + 0x%x > 0x%x)\n",
+		       instr->addr, instr->len, mtd->size );
+		return -EINVAL;
+	}
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+        /* Skip all erase regions which are ended before the start of
+           the requested erase. Actually, to save on the calculations,
+           we skip to the first erase region which starts after the
+           start of the requested erase, and then go back one.
+        */
+
+        while ((i < mtd->numeraseregions) &&
+	       (instr->addr >= regions[i].offset)) {
+               i++;
+	}
+        i--;
+
+	/* OK, now i is pointing at the erase region in which this
+	 * erase request starts. Check the start of the requested
+	 * erase range is aligned with the erase size which is in
+	 * effect here.
+	 */
+
+	if (instr->addr & (regions[i].erasesize-1)) {
+		return -EINVAL;
+	}
+
+	/* Remember the erase region we start on. */
+
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while ((i < mtd->numeraseregions) &&
+	       ((instr->addr + instr->len) >= regions[i].offset)) {
+                i++;
+	}
+
+	/* As before, drop back one to point at the region in which
+	 * the address actually falls.
+	 */
+
+	i--;
+
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1)) {
+                return -EINVAL;
+	}
+
+
+	adr = instr->addr;
+	len = instr->len;
+
+	i = first;
+	instr->state = MTD_ERASING;
+
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	start=adr;
+	end=0xFFFFFFF;
+	if(flash_write_flag & 1)
+	{
+		if(0 == start)
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_HW_SETTING_OFFSET )
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		end = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+	}
+			
+       if(flash_write_flag & 2 )
+       {
+    		if(0 == start)
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_DEFAULT_SETTING_OFFSET )
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		end = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+    	}
+			
+    	if(flash_write_flag & 4 )
+   	{
+   		if(0 == start)
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_CURRENT_SETTING_OFFSET )
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+		
+		end = CONFIG_RTL_WEB_PAGES_OFFSET;
+   	}
+
+	find_section_boundary(mtd,start,end,&rstart,&rend);
+
+	//printk("line[%d] rstart 0x%x rend 0x%x\n",__LINE__,rstart,rend);
+	
+	/*don't erase bootcode*/
+	if(rstart < RTL_BOOTCODE_END)
+		rstart = RTL_BOOTCODE_END;
+	
+	//printk("line[%d] rstart 0x%x rend 0x%x\n",__LINE__,rstart,rend);
+#endif
+
+	while (len) {
+//		if (adr >= CONFIG_MTD_DOCPROBE_ADDRESS) {
+
+#if defined(COMPACK_SETTING) || defined(NO_CHECK_REGION)
+		if ( erase_one_block(this, adr, regions[i].erasesize) )
+			return -1;
+
+#else
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	   if(adr >= rstart)
+#else
+		if ( ((flash_write_flag & 1) && (adr == flash_hw_start)) ||
+				((flash_write_flag & 2) &&(adr >= flash_ds_start && adr < (flash_ds_start+flash_ds_len))) 
+				|| ((flash_write_flag & 4) && (adr >= (flash_ds_start+flash_ds_len))) 
+//#ifdef CONFIG_RTK_MTD_ROOT
+#ifdef CONFIG_RTL_819X
+				|| (adr >= (rtl8196_partitions[0].size+ rtl8196_partitions[0].offset))
+#endif			
+				|| (flash_write_flag == 0x8000)
+				) 
+#endif	
+		{
+			if ( erase_one_block(this, adr, regions[i].erasesize) )
+				return -1;
+		}
+			
+#endif // COMPACK_SETTING || NO_CHECK_REGION
+
+		adr += regions[i].erasesize;
+		if (len < regions[i].erasesize)
+			len = 0;
+		else
+			len -= regions[i].erasesize;
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+		if(rend <= adr)
+		{
+			/*no need to erase other block*/
+			len=0;
+		}
+#endif
+		if ( adr >= (regions[i].offset + regions[i].erasesize*regions[i].numblocks))
+			i++;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback) {
+		instr->callback(instr);
+	}
+
+	return 0;
+#else
 	volatile char dummy;
 	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
@@ -809,7 +1353,52 @@
 	mtd_erase_callback(instr);
 
 	return 0;
+
+#endif /*#ifdef CONFIG_RTL_819X */
+}
+
+#ifdef CONFIG_RTL_819X 
+static int erase_one_block(struct DiskOnChip *this, __u32 addr, __u32 len)
+{
+	unsigned long timeo;
+	unsigned long docptr = this->virtadr;
+	__u32 ofs, offset;
+	unsigned long flags; // david
+
+
+	DEBUG(MTD_DEBUG_LEVEL1, "Erase sector, addr=0x%x, docptr=0x%x, len=0x%x\n",
+		(int)addr, (int)docptr, (int)len);
+
+	// issue erase command!
+	ofs = docptr + addr;
+
+	offset = (addr >> this->chipshift)*(1 << this->chipshift);
+
+	mtd_save_flags(flags);mtd_cli(); // david
+	*(volatile unsigned short *)(docptr + offset + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(docptr + offset + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(docptr + offset + 0x555 * 2) = 0x80;
+	*(volatile unsigned short *)(docptr + offset + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(docptr + offset + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(ofs ) = 0x30;
+	mtd_restore_flags(flags); // david
+
+	timeo = jiffies + (HZ * 40);
+
+	while (1) {
+     		if ((*(volatile unsigned short *)(ofs))==0xffff) {
+			DEBUG(MTD_DEBUG_LEVEL1, "Erase success!\n");
+			break;
+		}
+		if (time_after(jiffies, timeo)) {
+			printk(KERN_WARNING "Erase timeout!\n");
+			return -1;
+		}		
+		udelay(1);
+     	}
+	return 0;
 }
+#endif /*#ifdef CONFIG_RTL_819X */
 
 /****************************************************************************
  *
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/mtd/devices/docprobe.c linux-2.6.30.9-rsdk/drivers/mtd/devices/docprobe.c
--- linux-2.6.30.9/drivers/mtd/devices/docprobe.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/mtd/devices/docprobe.c	2011-12-05 15:50:14.000000000 +0000
@@ -36,7 +36,7 @@
    <linux-mtd@lists.infradead.org>.
 */
 #define DOC_SINGLE_DRIVER
-
+#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -56,10 +56,68 @@
 #define CONFIG_MTD_DOCPROBE_ADDRESS 0
 #endif
 
+#ifdef CONFIG_RTL_819X
+// david ----------------------
+/* MXIC */
+#define MANUFACTURER_MXIC	0x00C2
+#define MX29LV800B		0x225B
+#define MX29LV160AB		0x2249
+#define MX29LV320AB		0x22A8
+#define MX29LV640AB		0x22CB
+
+/*AMD*/
+#define MANUFACTURER_AMD	0x0001
+#define AM29LV800BB		0x225B
+#define AM29LV160DB		0x2249
+#define AM29LV320DB		0x22F9
+
+/*ST*/
+#define MANUFACTURER_ST		0x0020
+#define M29W160DB		0X2249
+
+/* ESMT */
+#define MANUFACTURER_ESMT	0x008C
+#define F49L160BA		0x2249
+
+/* SAMSUNG */
+#define MANUFACTURER_SAMSUNG	0x00EC
+#define K8D1716UBC		0x2277
+
+/* ESI */
+#define MANUFACTURER_ESI	0x004A
+#define ES29LV320D		0x22F9
+
+/* EON */
+#define MANUFACTURER_EON	0x007F
+#define EN29LV160A		0x2249
+
+#ifdef CONFIG_RTL8196B
+#define FLASH_BASE 0xbd000000
+#else
+#define FLASH_BASE 0xbe000000
+#endif
+
+struct flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const u_long size;
+	const int shift;  // shift number of chip size
+	const int numeraseregions;
+	const struct mtd_erase_region_info regions[4];
+};
+
+static int probeChip(struct DiskOnChip *doc, struct mtd_info *mtd);
+//-----------------------------
+#endif /*#ifdef CONFIG_RTL_819X*/
+
+//static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
+//module_param(doc_config_location, ulong, 0);
+//MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
-static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
-module_param(doc_config_location, ulong, 0);
-MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
+#ifdef CONFIG_RTL_819X
+ /* Do nothing here*/
+#else
 
 static unsigned long __initdata doc_locations[] = {
 #if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
@@ -76,6 +134,13 @@
 	0xe0000, 0xe2000, 0xe4000, 0xe6000,
 	0xe8000, 0xea000, 0xec000, 0xee000,
 #endif /*  CONFIG_MTD_DOCPROBE_HIGH */
+#elif defined(__PPC__)
+	0xe4000000,
+#elif defined(CONFIG_MOMENCO_OCELOT)
+	0x2f000000,
+        0xff000000,
+#elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
+        0xff000000,
 #else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
@@ -217,8 +282,9 @@
 #endif
 	return 0;
 }
+#endif /*#ifdef CONFIG_RTL_819X*/
 
-static int docfound;
+//static int docfound;
 
 extern void DoC2k_init(struct mtd_info *);
 extern void DoCMil_init(struct mtd_info *);
@@ -229,11 +295,18 @@
 	void __iomem *docptr;
 	struct DiskOnChip *this;
 	struct mtd_info *mtd;
-	int ChipID;
+	//int ChipID;
 	char namebuf[15];
 	char *name = namebuf;
+
+	
+	char *im_funcname = NULL;
+	char *im_modname = NULL;
+	
+	
 	void (*initroutine)(struct mtd_info *) = NULL;
 
+#ifndef CONFIG_RTL_819X
 	docptr = ioremap(physadr, DOC_IOREMAP_LEN);
 
 	if (!docptr)
@@ -302,8 +375,286 @@
 		kfree(mtd);
 	}
 	iounmap(docptr);
+#else
+      docptr = FLASH_BASE;
+      //-----------------------------
+
+
+	mtd = kmalloc(sizeof(struct DiskOnChip) + sizeof(struct mtd_info), GFP_KERNEL);
+
+	if (!mtd) {
+			printk(KERN_WARNING "Cannot allocate memory for data structures. Dropping.\n");
+			iounmap((void *)docptr);
+			return;
+}
+
+	this = (struct DiskOnChip *)(&mtd[1]);
+
+	memset((char *)mtd,0, sizeof(struct mtd_info));
+	memset((char *)this, 0, sizeof(struct DiskOnChip));
+
+	mtd->priv = this;
+	this->virtadr = docptr;
+	this->physadr = physadr;
+	this->ChipID = DOC_ChipID_DocMil;
+
+	name="Millennium";
+	im_funcname = "DoCMil_init";
+	im_modname = "doc2001";
+
+	if ( probeChip(this, mtd) == 0) // david added,
+		initroutine = &DoCMil_init;
+
+	if (initroutine) {
+		(*initroutine)(mtd);
+		return;
+	}
+	printk(KERN_NOTICE "Cannot find driver for DiskOnChip %s at 0x%lX\n", name, physadr);
+	iounmap((void *)docptr);
+
+#endif /*#ifdef CONFIG_RTL_819X*/
+}
+
+#ifdef CONFIG_RTL_819X
+// david -------------------------------------------------------------------
+static int probeChip(struct DiskOnChip *doc, struct mtd_info *mtd)
+{
+	/* Keep this table on the stack so that it gets deallocated after the
+	 * probe is done.
+	 */
+	const struct flash_info table[] = {
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV800B,
+		name: "MXIC MX29LV800B",
+		size: 0x00100000,
+		shift: 20,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV160AB,
+		name: "MXIC MX29LV160AB",
+		size: 0x00200000,
+		shift: 21,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV320AB,
+		name: "MXIC MX29LV320AB",
+		size: 0x00400000,
+		shift: 22,
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 63 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		shift: 20,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		size: 0x00200000,
+		shift: 21,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV320DB,
+		name: "AMD AM29LV320DB",
+		size: 0x00400000,
+		shift: 22,
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 63 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		size: 0x00200000,
+		shift: 21,/*21 bit=> that is 2 MByte size*/
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV640AB,
+		name: "MXIC MX29LV640AB",
+		size: 0x00800000,
+		shift: 23,/*22 bit=> that is 8 MByte size*/
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:   8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 127 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_SAMSUNG,
+		dev_id: K8D1716UBC,
+		name: "SAMSUNG K8D1716UBC",
+		size: 0x00200000,
+		shift: 21,/*21 bit=> that is 2 MByte size*/
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_ESMT,
+		dev_id: F49L160BA,
+		name: "ESMT F49L160BA",
+		size: 0x00200000,
+		shift: 21,/*21 bit=> that is 2 MByte size*/
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_ESI,
+		dev_id: ES29LV320D,
+		name: "ESI ES29LV320D",
+		size: 0x00400000,
+		shift: 22,/*22 bit=> that is 4 MByte size*/
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 63 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_EON,
+		dev_id: EN29LV160A,
+		name: "EON EN29LV160A",
+		size: 0x00200000,
+		shift: 21,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}
+	};
+
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr;
+	__u16 mfid, devid;
+	int i, j, k, interleave=1, chipsize;
+
+	// issue reset and auto-selection command
+	*(volatile unsigned short *)(FLASH_BASE) = 0xf0;
+
+	*(volatile unsigned short *)(FLASH_BASE + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(FLASH_BASE + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(FLASH_BASE + 0x555 * 2) = 0x90;
+
+	mfid = *((volatile unsigned short *)docptr);
+	devid = *((volatile unsigned short *)(docptr + 1*2));
+
+        *(volatile unsigned short *)(FLASH_BASE) = 0xf0;
+
+	for (i=0; i< sizeof(table)/sizeof(table[0]); i++) {
+		if ( mfid==table[i].mfr_id && devid==table[i].dev_id)
+			break;
+	}
+	if ( i == sizeof(table)/sizeof(table[0]) )
+		return -1;
+
+	// Look for 2nd flash
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size) = 0xf0;
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size + 0x555 * 2) = 0x90;
+
+	mfid = *((volatile unsigned short *)(docptr + table[i].size));
+	devid = *((volatile unsigned short *)(docptr + table[i].size + 1*2));
+
+	*(volatile unsigned short *)(FLASH_BASE+table[i].size) = 0xf0;
+	if ( mfid==table[i].mfr_id && devid==table[i].dev_id) {
+		interleave++;
+	}
+
+	printk(KERN_NOTICE "Found %d x %ldM Byte %s at 0x%lx\n",
+		interleave, (table[i].size)/(1024*1024), table[i].name, docptr);
+
+	mtd->size = table[i].size*interleave;
+	mtd->numeraseregions = table[i].numeraseregions*interleave;
+
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) *
+				    mtd->numeraseregions*interleave, GFP_KERNEL);
+	if (!mtd->eraseregions) {
+		printk(KERN_WARNING "Failed to allocate "
+		       "memory for MTD erase region info\n");
+		kfree(mtd);
+		return -1;
 }
 
+	for (k=0, chipsize=0; interleave>0; interleave--, chipsize+=table[i].size) {
+		for (j=0; j<table[i].numeraseregions; j++, k++) {
+			mtd->eraseregions[k].offset = table[i].regions[j].offset+chipsize;
+			mtd->eraseregions[k].erasesize = table[i].regions[j].erasesize;
+			mtd->eraseregions[k].numblocks = table[i].regions[j].numblocks;
+			if (mtd->erasesize < mtd->eraseregions[k].erasesize)
+				mtd->erasesize = mtd->eraseregions[k].erasesize;
+		}
+	}
+
+	this->totlen = mtd->size;
+	this->numchips = interleave;
+	this->chipshift = table[i].shift;
+
+	return 0;
+}
+//---------------------------------------------------------------------------
+#endif /*#ifdef CONFIG_RTL_819X */
+
 
 /****************************************************************************
  *
@@ -313,6 +664,14 @@
 
 static int __init init_doc(void)
 {
+#ifdef CONFIG_RTL_819X
+      printk(KERN_NOTICE "RealTek E-Flash System Driver. (C) 2002 RealTek Corp.\n");
+	DoC_Probe(CONFIG_MTD_DOCPROBE_ADDRESS);
+	/* So it looks like we've been used and we get unloaded */
+//	MOD_INC_USE_COUNT;
+//	MOD_DEC_USE_COUNT;
+	return 0;
+#else
 	int i;
 
 	if (doc_config_location) {
@@ -328,6 +687,7 @@
 	if (!docfound)
 		printk(KERN_INFO "No recognised DiskOnChip devices found\n");
 	return -EAGAIN;
+#endif	
 }
 
 module_init(init_doc);
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/mtd/maps/Makefile linux-2.6.30.9-rsdk/drivers/mtd/maps/Makefile
--- linux-2.6.30.9/drivers/mtd/maps/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/mtd/maps/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -62,3 +62,4 @@
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
+obj-$(CONFIG_RTL819X_SPI_FLASH) += rtl819x_flash.o
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/mtd/mtdblock.c linux-2.6.30.9-rsdk/drivers/mtd/mtdblock.c
--- linux-2.6.30.9/drivers/mtd/mtdblock.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/mtd/mtdblock.c	2011-12-05 15:50:14.000000000 +0000
@@ -18,6 +18,26 @@
 #include <linux/mtd/blktrans.h>
 #include <linux/mutex.h>
 
+#include <linux/config.h>
+
+#ifdef CONFIG_RTL_819X
+// david ---------------
+//#define CONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 3
+
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+int flash_write_flag=0;		// 1: hw setting 2: default setting, 4: current setting, 8: system image
+#else
+int flash_hw_start=0x6000;	// hw setting start address
+int flash_hw_len=0x2000;	// hw setting length
+int flash_ds_start=0x8000;	// default & current setting start address
+int flash_ds_len=0x8000;	// default & current setting length
+
+int flash_write_flag=0;		// 1: hw setting 2: default setting, 4: current setting, 8: system image
+#endif
+#endif /*#ifdef CONFIG_RTL_819X */
+
 
 static struct mtdblk_dev {
 	struct mtd_info *mtd;
@@ -134,6 +154,58 @@
 	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: write on \"%s\" at 0x%lx, size 0x%x\n",
 		mtd->name, pos, len);
 
+	
+#ifdef CONFIG_RTL_819X
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	/*since len is normal 0x200 less than every section*/
+	if(flash_write_flag != 0x8000) 
+	{
+		flash_write_flag = 0;
+		if ( pos >= CONFIG_RTL_HW_SETTING_OFFSET && pos < CONFIG_RTL_DEFAULT_SETTING_OFFSET ) {
+			flash_write_flag |= 1;
+			if ((pos+len) > CONFIG_RTL_DEFAULT_SETTING_OFFSET ) {
+				flash_write_flag |= 2;
+				if ((pos+len) > CONFIG_RTL_CURRENT_SETTING_OFFSET )
+					flash_write_flag |= 4;
+			}
+		}
+		if ( pos >= CONFIG_RTL_DEFAULT_SETTING_OFFSET && pos < CONFIG_RTL_CURRENT_SETTING_OFFSET ) {
+			flash_write_flag |= 2;
+			if ((pos+len) > CONFIG_RTL_CURRENT_SETTING_OFFSET ) {
+				flash_write_flag |= 4;
+			}
+		}
+		else if ( pos >= CONFIG_RTL_CURRENT_SETTING_OFFSET && pos < CONFIG_RTL_WEB_PAGES_OFFSET ){
+			flash_write_flag |= 4;
+		}
+	}
+#else
+// david --------------
+	if ( flash_write_flag != 0x8000) 
+	{
+		flash_write_flag = 0;
+		if (pos >= flash_hw_start && pos < (flash_hw_start+flash_hw_len) ) {
+			flash_write_flag |= 1;
+			if ((len - flash_hw_len) > 0) {
+				flash_write_flag |= 2;
+				if ((len - flash_ds_len -flash_hw_len) > 0)
+					flash_write_flag |= 4;
+			}
+		}
+		if (pos >= flash_ds_start && pos < (flash_ds_start+flash_ds_len) ) {
+			flash_write_flag |= 2;
+			if ((len - flash_ds_len) > 0) {
+				flash_write_flag |= 4;
+			}
+		}
+		else if ( pos >= (flash_ds_start+flash_ds_len) ){
+			flash_write_flag |= 4;
+		}
+	}
+//---------------------
+#endif //CONFIG_RTL_FLASH_MAPPING_ENABLE
+#endif
+
 	if (!sect_size)
 		return mtd->write(mtd, pos, len, &retlen, buf);
 
@@ -343,7 +415,6 @@
 
 	dev->mtd = mtd;
 	dev->devnum = mtd->index;
-
 	dev->size = mtd->size >> 9;
 	dev->tr = tr;
 
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/Kconfig linux-2.6.30.9-rsdk/drivers/net/Kconfig
--- linux-2.6.30.9/drivers/net/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -27,7 +27,7 @@
 if NETDEVICES
 
 config COMPAT_NET_DEV_OPS
-       default y
+       default n
        bool "Enable older network device API compatibility"
        ---help---
           This option enables kernel compatibility with older network devices
@@ -2146,6 +2146,22 @@
 
 	  If in doubt, say Y.
 
+config R8168
+    tristate "Realtek 8168 gigabit ethernet support"
+    depends on PCI
+    select CRC32
+    default y
+    ---help---
+      Say Y here if you have a Realtek 8168 PCI Gigabit Ethernet adapter.
+
+      To compile this driver as a module, choose M here: the module
+      will be called r8168.  This is recommended.
+
+config R8168_NAPI
+    bool "NAPI support"
+    depends on R8168
+    default y
+
 config SB1250_MAC
 	tristate "SB1250 Gigabit Ethernet support"
 	depends on SIBYTE_SB1xxx_SOC
@@ -2987,19 +3003,31 @@
 	  module; it is called bsd_comp and will show up in the directory
 	  modules once you have said "make modules". If unsure, say N.
 
-config PPP_MPPE
-       tristate "PPP MPPE compression (encryption) (EXPERIMENTAL)"
-       depends on PPP && EXPERIMENTAL
-       select CRYPTO
+config PPP_MPPE_MPPC
+       tristate "Microsoft PPP compression/encryption (MPPC/MPPE)"
+       depends on PPP
        select CRYPTO_SHA1
        select CRYPTO_ARC4
-       select CRYPTO_ECB
        ---help---
-         Support for the MPPE Encryption protocol, as employed by the
-	 Microsoft Point-to-Point Tunneling Protocol.
+         Support for the Microsoft Point-To-Point Compression (RFC2118) and 
+         Microsoft Point-To-Point Encryption (RFC3078). These protocols are
+         supported by Microsoft Windows and wide range of "hardware" access
+         servers. MPPE is common protocol in Virtual Private Networks. According
+         to RFC3078, MPPE supports 40, 56 and 128-bit key lengths. Depending on
+         PPP daemon configuration on both ends of the link, following scenarios
+         are possible:
+               - only compression (MPPC) is used,
+               - only encryption (MPPE) is used,
+               - compression and encryption (MPPC+MPPE) are used.
+
+         Please note that Hi/Fn (http://www.hifn.com) holds patent on MPPC so
+         you should check if this patent is valid in your country in order to
+         avoid legal problems.
+
+         For more information please visit http://mppe-mppc.alphacron.de
 
-	 See http://pptpclient.sourceforge.net/ for information on
-	 configuring PPTP clients and servers to utilize this method.
+         To compile this driver as a module, choose M here. The module will
+         be called ppp_mppe_mppc.ko.
 
 config PPPOE
 	tristate "PPP over Ethernet (EXPERIMENTAL)"
@@ -3155,4 +3183,5 @@
 	  This is the virtual network driver for virtio.  It can be used with
           lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.
 
+source "drivers/net/rtl819x/Kconfig"
 endif # NETDEVICES
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/Makefile linux-2.6.30.9-rsdk/drivers/net/Makefile
--- linux-2.6.30.9/drivers/net/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -142,7 +142,7 @@
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
 obj-$(CONFIG_PPP_DEFLATE) += ppp_deflate.o
 obj-$(CONFIG_PPP_BSDCOMP) += bsd_comp.o
-obj-$(CONFIG_PPP_MPPE) += ppp_mppe.o
+obj-$(CONFIG_PPP_MPPE_MPPC) += ppp_mppe_mppc.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 obj-$(CONFIG_PPPOL2TP) += pppox.o pppol2tp.o
 
@@ -218,6 +218,7 @@
 obj-$(CONFIG_NET_NETX) += netx-eth.o
 obj-$(CONFIG_DL2K) += dl2k.o
 obj-$(CONFIG_R8169) += r8169.o
+obj-$(CONFIG_R8168) += r8168/
 obj-$(CONFIG_AMD8111_ETH) += amd8111e.o
 obj-$(CONFIG_IBMVETH) += ibmveth.o
 obj-$(CONFIG_S2IO) += s2io.o
@@ -271,3 +272,11 @@
 obj-$(CONFIG_SFC) += sfc/
 
 obj-$(CONFIG_WIMAX) += wimax/
+
+obj-$(CONFIG_RTL_819X_SWCORE) += rtl819x/built-in.o
+subdir-$(CONFIG_RTL_819X_SWCORE) += rtl819x
+
+obj-$(CONFIG_RTK_VLAN_SUPPORT) += rtk_vlan.o
+
+#DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
+#EXTRA_CFLAGS += -I$(DIR_RTLASIC)
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/ppp_generic.c linux-2.6.30.9-rsdk/drivers/net/ppp_generic.c
--- linux-2.6.30.9/drivers/net/ppp_generic.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/ppp_generic.c	2011-12-05 15:50:14.000000000 +0000
@@ -42,6 +42,9 @@
 #include <linux/tcp.h>
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#include <linux/smp_lock.h>
+#endif
 #include <linux/rwsem.h>
 #include <linux/stddef.h>
 #include <linux/device.h>
@@ -53,6 +56,48 @@
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 
+#ifdef CONFIG_RTL_PPPOE_HWACC
+#include <linux/if_pppox.h>
+#endif
+
+#include <net/rtl/rtl_types.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/rtl_nic.h>
+#endif
+
+#include <net/rtl/rtl865x_netif.h>
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+#include <net/rtl/rtl865x_ppp.h>
+#endif
+
+#if defined (CONFIG_RTL_HW_QOS_SUPPORT)	// sync from voip customer for multiple ppp
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
+
+#if defined(NAT_SPEEDUP)||defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	#define FAST_PPTP
+	#define FAST_L2TP
+#endif
+
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+enum SE_TYPE
+{
+	/*1:if_ether, 2:pppoe,3:pptp,4:l2tp*/
+	SE_ETHER = 1,
+	SE_PPPOE = 2,
+	SE_PPTP = 3,
+	SE_L2TP = 4,
+};
+#else
+enum SE_TYPE
+{
+	SE_PPPOE = 1,
+	SE_PPTP = 2,
+	SE_L2TP = 3,
+};
+#endif /*CONFIG_RTL865X_LAYERED_DRIVER*/
+
+
 #define PPP_VERSION	"2.4.2"
 
 /*
@@ -88,10 +133,18 @@
 	int		dead;		/* unit/channel has been shut down */
 };
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#define PF_TO_X(pf, X)         ((X *)((char *)(pf) - offsetof(X, file)))
+#else
 #define PF_TO_X(pf, X)		container_of(pf, X, file)
+#endif
 
 #define PF_TO_PPP(pf)		PF_TO_X(pf, struct ppp)
 #define PF_TO_CHANNEL(pf)	PF_TO_X(pf, struct channel)
+//#if defined(CONFIG_PPP_MPPE_MPPC)
+//#undef ROUNDUP
+//#define ROUNDUP(n, x)          (((n) + (x) - 1) / (x))
+//#endif
 
 /*
  * Data structure describing one ppp unit.
@@ -107,6 +160,9 @@
 	spinlock_t	rlock;		/* lock for receive side 58 */
 	spinlock_t	wlock;		/* lock for transmit side 5c */
 	int		mru;		/* max receive unit 60 */
+#if defined(CONFIG_PPP_MPPE_MPPC)
+	int             mru_alloc;      /* MAX(1500,MRU) for dev_alloc_skb() */
+#endif
 	unsigned int	flags;		/* control bits 64 */
 	unsigned int	xstate;		/* transmit state bits 68 */
 	unsigned int	rstate;		/* receive state bits 6c */
@@ -130,6 +186,7 @@
 	u32		minseq;		/* MP: min of most recent seqnos */
 	struct sk_buff_head mrq;	/* MP: receive reconstruction queue */
 #endif /* CONFIG_PPP_MULTILINK */
+	struct net_device_stats stats;	/* statistics */
 #ifdef CONFIG_PPP_FILTER
 	struct sock_filter *pass_filter;	/* filter for packets to pass */
 	struct sock_filter *active_filter;/* filter for pkts to reset idle */
@@ -138,6 +195,67 @@
 	struct net	*ppp_net;	/* the net we belong to */
 };
 
+#ifdef FAST_PPTP
+#define MPPE_CCOUNT(p) ((((p)[2] & 0x0f) << 8) + (p)[3])
+typedef struct {
+    unsigned i;
+    unsigned j;
+    unsigned char S[256];
+} arcfour_context;
+
+
+#define MPPE_MAX_KEY_LEN       16      /* largest key length (128-bit) */	/* reference from ppp_mppe.h*/
+
+
+#if defined(CONFIG_PPP_MPPE_MPPC)
+typedef struct ppp_mppe_state {		/* reference from ppp_mppe_mppc.c	*/
+    struct crypto_tfm *arc4_tfm;
+    u8		master_key[MPPE_MAX_KEY_LEN];
+    u8		session_key[MPPE_MAX_KEY_LEN];
+    u8		mppc;		/* do we use compression (MPPC)? */
+    u8		mppe;		/* do we use encryption (MPPE)? */
+    u8		keylen;		/* key length in bytes */
+    u8		bitkeylen;	/* key length in bits */
+    u16		ccount;		/* coherency counter */
+    u16		bits;		/* MPPC/MPPE control bits */
+    u8		stateless;	/* do we use stateless mode? */
+    u8		nextflushed;	/* set A bit in the next outgoing packet;
+				   used only by compressor*/
+    u8		flushexpected;	/* drop packets until A bit is received;
+				   used only by decompressor*/
+    u8		*hist;		/* MPPC history */
+    u16		*hash;		/* Hash table; used only by compressor */
+    u16		histptr;	/* history "cursor" */
+    int		unit;
+    int		debug;
+    int		mru;
+    struct compstat stats;
+}ppp_mppe_state;
+#else
+typedef struct ppp_mppe_state {			/* reference from ppp_mppe.c	*/
+	struct crypto_blkcipher *arc4;
+	struct crypto_hash *sha1;
+	unsigned char *sha1_digest;
+	unsigned char master_key[MPPE_MAX_KEY_LEN];
+	unsigned char session_key[MPPE_MAX_KEY_LEN];
+	unsigned keylen;	/* key length in bytes             */
+	/* NB: 128-bit == 16, 40-bit == 8! */
+	/* If we want to support 56-bit,   */
+	/* the unit has to change to bits  */
+	unsigned char bits;	/* MPPE control bits */
+	unsigned ccount;	/* 12-bit coherency count (seqno)  */
+	unsigned stateful;	/* stateful mode flag */
+	int discard;		/* stateful mode packet loss flag */
+	int sanity_errors;	/* take down LCP if too many */
+	int unit;
+	int debug;
+	struct compstat stats;
+} ppp_mppe_state;
+#endif
+
+#endif
+
+
 /*
  * Bits in flags: SC_NO_TCP_CCID, SC_CCP_OPEN, SC_CCP_UP, SC_LOOP_TRAFFIC,
  * SC_MULTILINK, SC_MP_SHORTSEQ, SC_MP_XSHORTSEQ, SC_COMP_TCP, SC_REJ_COMP_TCP,
@@ -145,9 +263,15 @@
  * Bits in rstate: SC_DECOMP_RUN, SC_DC_ERROR, SC_DC_FERROR.
  * Bits in xstate: SC_COMP_RUN
  */
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#define SC_FLAG_BITS	(SC_NO_TCP_CCID|SC_CCP_OPEN|SC_CCP_UP|SC_LOOP_TRAFFIC \
+			 |SC_MULTILINK|SC_MP_SHORTSEQ|SC_MP_XSHORTSEQ \
+			 |SC_COMP_TCP|SC_REJ_COMP_TCP)
+#else
 #define SC_FLAG_BITS	(SC_NO_TCP_CCID|SC_CCP_OPEN|SC_CCP_UP|SC_LOOP_TRAFFIC \
 			 |SC_MULTILINK|SC_MP_SHORTSEQ|SC_MP_XSHORTSEQ \
 			 |SC_COMP_TCP|SC_REJ_COMP_TCP|SC_MUST_COMP)
+#endif
 
 /*
  * Private data structure for each channel.
@@ -169,6 +293,12 @@
 	u32		lastseq;	/* MP: last sequence # received */
 	int     speed;		/* speed of the corresponding ppp channel*/
 #endif /* CONFIG_PPP_MULTILINK */
+#ifdef CONFIG_RTL_PPPOE_HWACC
+	u8		pppoe;
+	u8		rsv1;
+	u16		rsv2;
+#endif /* CONFIG_RTL865X_HW_TABLES */
+
 };
 
 /*
@@ -235,13 +365,31 @@
 static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
 			struct file *file, unsigned int cmd, unsigned long arg);
 static void ppp_xmit_process(struct ppp *ppp);
+#ifdef FAST_PPTP
+static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw);
+#else
 static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb);
+#endif
+
 static void ppp_push(struct ppp *ppp);
 static void ppp_channel_push(struct channel *pch);
 static void ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb,
 			      struct channel *pch);
 static void ppp_receive_error(struct ppp *ppp);
+#ifdef FAST_PPTP
+struct sk_buff *ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw);
+#ifdef CONFIG_FAST_PATH_MODULE
+int (*FastPath_hook9)( void )=NULL;
+int (*FastPath_hook10)(struct sk_buff *skb)=NULL;
+EXPORT_SYMBOL(FastPath_hook9);
+EXPORT_SYMBOL(FastPath_hook10);
+EXPORT_SYMBOL(ppp_receive_nonmp_frame);
+#endif
+
+#else
 static void ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb);
+#endif
+
 static struct sk_buff *ppp_decompress_frame(struct ppp *ppp,
 					    struct sk_buff *skb);
 #ifdef CONFIG_PPP_MULTILINK
@@ -558,7 +706,7 @@
 static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct ppp_file *pf = file->private_data;
-	struct ppp *ppp;
+	struct ppp *ppp = NULL;
 	int err = -EFAULT, val, val2, i;
 	struct ppp_idle idle;
 	struct npioctl npi;
@@ -611,11 +759,77 @@
 		case PPPIOCCONNECT:
 			if (get_user(unit, p))
 				break;
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2	// sync from voip customer for multiple ppp
+			#if defined (CONFIG_RTL_HW_QOS_SUPPORT)
+			rtl865x_qosRearrangeRule();
+			#endif
+#endif
 			err = ppp_connect_channel(pch, unit);
+#ifdef CONFIG_RTL_PPPOE_HWACC
+ 			if(err == 0 && pch->pppoe==TRUE)
+			{
+				struct sock *sk = (struct sock *) pch->chan->private;
+				struct pppox_sock *po = pppox_sk(sk);
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+				{
+					struct sock *sk = (struct sock *) pch->chan->private;
+					struct pppox_sock *po = pppox_sk(sk);
+					struct net_device *local_dev = po->pppoe_dev;
+
+					rtl865x_attachMasterNetif(pch->ppp->dev->name, local_dev->name);
+					//add the netif mapping table
+					rtl_add_ps_drv_netif_mapping(pch->ppp->dev,pch->ppp->dev->name);	// sync from voip customer for multiple ppp
+				}
+				rtl865x_addPpp(pch->ppp->dev->name , (ether_addr_t*)po->pppoe_pa.remote, po->pppoe_pa.sid, SE_PPPOE);
+#endif
+#else
+				rtl865x_addPppSession(pch->ppp->dev->name , (ether_addr_t*)po->pppoe_pa.remote, po->pppoe_pa.sid, SE_PPPOE);
+#endif
+			}
+#endif
+
+
+		#ifdef FAST_PPTP // sync from voip customer for multiple ppp
+			{
+				extern void set_pptp_device(char *ppp_device);
+				extern int fast_pptp_fw;
+				if (err==0 && fast_pptp_fw)
+					set_pptp_device(pch->ppp->dev->name);
+			}
+		#endif
+
+		#ifdef FAST_L2TP // sync from voip customer for multiple ppp
+			{
+				extern void set_l2tp_device(char *ppp_device);
+				if (err==0)
+					set_l2tp_device(pch->ppp->dev->name);
+			}
+		#endif
+
 			break;
 
 		case PPPIOCDISCONN:
 			err = ppp_disconnect_channel(pch);
+#ifdef CONFIG_RTL_PPPOE_HWACC
+			if (err == 0 && pch->pppoe==TRUE)
+			{
+				pch->pppoe = FALSE;
+
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+
+				rtl865x_detachMasterNetif(ppp->dev->name);
+				//del the netif mapping table
+				rtl_del_ps_drv_netif_mapping(pch->ppp->dev);
+				rtl865x_delPppbyIfName(ppp->dev->name);
+#endif
+#else
+				rtl865x_delPppSession(ppp->dev->name,  SE_PPPOE);
+#endif
+			}
+#endif
+
 			break;
 
 		default:
@@ -642,7 +856,13 @@
 	case PPPIOCSMRU:
 		if (get_user(val, p))
 			break;
+#if defined(CONFIG_PPP_MPPE_MPPC)
+             ppp->mru_alloc = ppp->mru = val;
+       	if (ppp->mru_alloc < PPP_MRU)
+           		ppp->mru_alloc = PPP_MRU;   /* increase for broken peers */
+#else
 		ppp->mru = val;
+#endif
 		err = 0;
 		break;
 
@@ -689,6 +909,33 @@
 		break;
 
 	case PPPIOCGIDLE:
+#ifdef FAST_L2TP
+		{
+			extern int fast_l2tp_fw;
+			unsigned long get_fast_l2tp_lastxmit(void);
+		 	unsigned long fastl2tp_lastxmit;
+			if(fast_l2tp_fw)
+			{
+				fastl2tp_lastxmit = get_fast_l2tp_lastxmit();
+				if(ppp->last_xmit < fastl2tp_lastxmit)
+					ppp->last_xmit = fastl2tp_lastxmit;
+			}
+		}
+#endif
+#ifdef FAST_PPTP
+		{
+			extern int fast_pptp_fw;
+			extern unsigned long get_fastpptp_lastxmit(void);
+			unsigned long fastpptp_lastxmit;
+			if(fast_pptp_fw)
+			{
+				fastpptp_lastxmit = get_fastpptp_lastxmit();
+				if(ppp->last_xmit < fastpptp_lastxmit)
+					ppp->last_xmit = fastpptp_lastxmit;
+			}
+		}
+#endif
+
 		idle.xmit_idle = (jiffies - ppp->last_xmit) / HZ;
 		idle.recv_idle = (jiffies - ppp->last_recv) / HZ;
 		if (copy_to_user(argp, &idle, sizeof(idle)))
@@ -788,6 +1035,15 @@
 	return err;
 }
 
+struct net_device_stats *get_ppp_stats(struct ppp *ppp)
+{
+	return (&ppp->stats);
+}
+
+#ifdef CONFIG_FAST_PATH_MODULE
+EXPORT_SYMBOL(get_ppp_stats);
+#endif
+
 static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
 			struct file *file, unsigned int cmd, unsigned long arg)
 {
@@ -951,13 +1207,114 @@
 /*
  * Network interface unit routines.
  */
-static int
-ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+ #if defined(FAST_L2TP)
+extern int fast_l2tp_to_wan(struct sk_buff *skb);
+extern int check_for_fast_l2tp_to_wan(struct sk_buff *skb);
+extern void event_ppp_dev_down(const char * name);
+#endif
+#if defined(FAST_PPTP) || defined(FAST_L2TP)
+int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#endif
+
 {
 	struct ppp *ppp = netdev_priv(dev);
 	int npi, proto;
 	unsigned char *pp;
 
+#ifdef FAST_PPTP
+	int is_fast_fw=0;
+   #if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	extern int fast_pptp_fw;
+	#ifdef CONFIG_FAST_PATH_MODULE
+	if((FastPath_hook9!=NULL) &&(FastPath_hook10!=NULL))
+	{
+		if (FastPath_hook9()) {
+			if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L')
+			{
+				is_fast_fw=1;
+				memset(skb->cb, '\x0', 3);
+			}
+			else {
+				extern int fast_pptp_to_wan(struct sk_buff *skb);
+				if (FastPath_hook10(skb))
+					return 0;
+			}
+		}
+	}
+	#else
+	if (fast_pptp_fw) {
+		if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L')
+		{
+			is_fast_fw=1;
+			memset(skb->cb, '\x0', 3);
+		}
+		else {
+			extern int is_pptp_device(char *ppp_device);	// sync from voip customer for multiple ppp
+			extern int fast_pptp_to_wan(struct sk_buff *skb);
+			if (is_pptp_device(ppp->dev->name) && fast_pptp_to_wan(skb))	// sync from voip customer for multiple ppp
+				return 0;
+		}
+	}
+	#endif
+   #else
+	if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L')
+		is_fast_fw=1;
+   #endif
+#endif
+
+#if 0
+#ifdef FAST_L2TP
+#ifndef FAST_PPTP
+		int is_fast_fw=0;
+#endif
+
+#ifdef CONFIG_RTL_IPTABLES_FAST_PATH
+#if 0//def CONFIG_FAST_PATH_MODULE
+		if((FastPath_hook9!=NULL) &&(FastPath_hook10!=NULL))
+		{
+			if (FastPath_hook9()) {
+			if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L') {
+				is_fast_fw = 1;
+				memset(skb->cb, '\x0', 3);
+			}
+			else {
+				//extern int fast_pptp_to_wan(struct sk_buff *skb);
+#ifdef CONFIG_RTL865X_HW_PPTPL2TP
+				if (!accelerate && FastPath_hook10(skb))
+					return 0;
+#else
+				if (FastPath_hook10(skb))
+					return 0;
+#endif /* CONFIG_RTL865X_HW_PPTPL2TP */
+			}
+			}
+		}
+#else
+		extern int fast_l2tp_fw;
+		if (fast_l2tp_fw) {
+			if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L') {
+				is_fast_fw = 1;
+				memset(skb->cb, '\x0', 3);
+			}
+			else {
+				extern int is_l2tp_device(char *ppp_device);
+				extern int fast_l2tp_to_wan(struct sk_buff *skb);
+				if (is_l2tp_device(ppp->dev->name)&&fast_l2tp_to_wan(skb))
+					return 0;
+			}
+		}
+#endif
+#else
+		if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L') {
+			is_fast_fw = 1;
+			memset(skb->cb, '\x0', 3);
+		}
+#endif
+#endif
+#endif
+
 	npi = ethertype_to_npindex(ntohs(skb->protocol));
 	if (npi < 0)
 		goto outf;
@@ -985,9 +1342,37 @@
 	pp[0] = proto >> 8;
 	pp[1] = proto;
 
+#ifdef FAST_PPTP
+	if (is_fast_fw)
+		ppp_send_frame(ppp, skb, 1);
+	else {
+#ifdef FAST_L2TP
+			skb_pull(skb,2);
+			extern int is_l2tp_device(char *ppp_device);	// sync from voip customer for multiple ppp
+			if (is_l2tp_device(ppp->dev->name) && (check_for_fast_l2tp_to_wan(skb)==1) && (fast_l2tp_to_wan(skb) == 1)) // sync from voip customer for multiple ppp
+			{
+				/* Note: if pkt go here, l2tp dial-on-demand will not be triggered,
+				so some risk exist here! -- 2010/04/25 zj */
+				return 0;
+			}
+			else
+			{
+				pp = skb_push(skb, 2);
+				proto = npindex_to_proto[npi];
+				pp[0] = proto >> 8;
+				pp[1] = proto;
+			}
+#endif
+		netif_stop_queue(dev);
+		skb_queue_tail(&ppp->file.xq, skb);
+		ppp_xmit_process(ppp);
+	}
+#else
 	netif_stop_queue(dev);
 	skb_queue_tail(&ppp->file.xq, skb);
 	ppp_xmit_process(ppp);
+#endif
+
 	return 0;
 
  outf:
@@ -1050,7 +1435,11 @@
 	dev->hard_header_len = PPP_HDRLEN;
 	dev->mtu = PPP_MTU;
 	dev->addr_len = 0;
+#if defined(CONFIG_RTL_819X)
+	dev->tx_queue_len = 64;
+#else
 	dev->tx_queue_len = 3;
+#endif
 	dev->type = ARPHRD_PPP;
 	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
 	dev->features |= NETIF_F_NETNS_LOCAL;
@@ -1074,7 +1463,12 @@
 		ppp_push(ppp);
 		while (!ppp->xmit_pending
 		       && (skb = skb_dequeue(&ppp->file.xq)))
+#ifdef FAST_PPTP
+			ppp_send_frame(ppp, skb, 0);
+#else
 			ppp_send_frame(ppp, skb);
+#endif
+
 		/* If there's no work left to do, tell the core net
 		   code that we can accept some more. */
 		if (!ppp->xmit_pending && !skb_peek(&ppp->file.xq))
@@ -1083,6 +1477,7 @@
 	ppp_xmit_unlock(ppp);
 }
 
+#if !defined(CONFIG_PPP_MPPE_MPPC)
 static inline struct sk_buff *
 pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)
 {
@@ -1132,14 +1527,19 @@
 	}
 	return new_skb;
 }
+#endif
 
 /*
  * Compress and send a frame.
  * The caller should have locked the xmit path,
  * and xmit_pending should be 0.
  */
-static void
-ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
+#ifdef FAST_PPTP
+static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw)
+#else
+static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
+#endif
+
 {
 	int proto = PPP_PROTO(skb);
 	struct sk_buff *new_skb;
@@ -1175,6 +1575,13 @@
 	++ppp->dev->stats.tx_packets;
 	ppp->dev->stats.tx_bytes += skb->len - 2;
 
+#if defined(FAST_PPTP) && defined(NAT_SPEEDUP)
+{
+	extern void update_fast_pptp_state(void);
+ 	update_fast_pptp_state();
+}
+#endif
+
 	switch (proto) {
 	case PPP_IP:
 		if (!ppp->vj || (ppp->flags & SC_COMP_TCP) == 0)
@@ -1213,12 +1620,69 @@
 	case PPP_CCP:
 		/* peek at outbound CCP frames */
 		ppp_ccp_peek(ppp, skb, 0);
+#if defined(CONFIG_PPP_MPPE_MPPC)
+               if (CCP_CODE(skb->data+2) == CCP_RESETACK
+                   && (ppp->xcomp->compress_proto == CI_MPPE
+                       || ppp->xcomp->compress_proto == CI_LZS)) {
+                   --ppp->dev->stats.tx_packets;
+                   ppp->dev->stats.tx_bytes -= skb->len - 2;
+                   kfree_skb(skb);
+                   return;
+               }
+#endif
 		break;
 	}
 
 	/* try to do packet compression */
 	if ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state
 	    && proto != PPP_LCP && proto != PPP_CCP) {
+#if defined(CONFIG_PPP_MPPE_MPPC)
+               int comp_ovhd = 0;
+               /*
+                * because of possible data expansion when MPPC or LZS
+                * is used, allocate compressor's buffer 12.5% bigger
+                * than MTU
+                */
+               if (ppp->xcomp->compress_proto == CI_MPPE)
+                   comp_ovhd = ((ppp->dev->mtu * 9) / 8) + 1 + MPPE_OVHD;
+               else if (ppp->xcomp->compress_proto == CI_LZS)
+                   comp_ovhd = ((ppp->dev->mtu * 9) / 8) + 1 + LZS_OVHD;
+               new_skb = alloc_skb(ppp->dev->mtu + ppp->dev->hard_header_len
+                                   + comp_ovhd, GFP_ATOMIC);
+               if (new_skb == 0) {
+                       printk(KERN_ERR "PPP: no memory (comp pkt)\n");
+                        goto drop;
+                }
+               if (ppp->dev->hard_header_len > PPP_HDRLEN)
+                       skb_reserve(new_skb,
+                                   ppp->dev->hard_header_len - PPP_HDRLEN);
+
+               /* compressor still expects A/C bytes in hdr */
+               len = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,
+                                          new_skb->data, skb->len + 2,
+                                          ppp->dev->mtu + PPP_HDRLEN);
+               if (len > 0 && (ppp->flags & SC_CCP_UP)) {
+                       kfree_skb(skb);
+                       skb = new_skb;
+                       skb_put(skb, len);
+                       skb_pull(skb, 2);       /* pull off A/C bytes */
+               } else if (len == 0) {
+                       /* didn't compress, or CCP not up yet */
+                       kfree_skb(new_skb);
+               } else {
+                       /*
+                        * (len < 0)
+                        * MPPE requires that we do not send unencrypted
+                        * frames.  The compressor will return -1 if we
+                        * should drop the frame.  We cannot simply test
+                        * the compress_proto because MPPE and MPPC share
+                        * the same number.
+                        */
+                       printk(KERN_ERR "ppp: compressor dropped pkt\n");
+                       kfree_skb(new_skb);
+                        goto drop;
+               }
+#else
 		if (!(ppp->flags & SC_CCP_UP) && (ppp->flags & SC_MUST_COMP)) {
 			if (net_ratelimit())
 				printk(KERN_ERR "ppp: compression required but down - pkt dropped.\n");
@@ -1227,6 +1691,7 @@
 		skb = pad_compress_skb(ppp, skb);
 		if (!skb)
 			goto drop;
+#endif
 	}
 
 	/*
@@ -1242,6 +1707,9 @@
 	}
 
 	ppp->xmit_pending = skb;
+#ifdef FAST_PPTP
+	if (!is_fast_fw)
+#endif
 	ppp_push(ppp);
 	return;
 
@@ -1637,7 +2105,11 @@
 			ppp_receive_mp_frame(ppp, skb, pch);
 		else
 #endif /* CONFIG_PPP_MULTILINK */
+#ifdef FAST_PPTP
+			ppp_receive_nonmp_frame(ppp, skb, 0);
+#else
 			ppp_receive_nonmp_frame(ppp, skb);
+#endif
 		return;
 	}
 
@@ -1657,12 +2129,38 @@
 		slhc_toss(ppp->vj);
 }
 
-static void
-ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)
+#ifdef FAST_PPTP
+struct sk_buff *ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw)
+#else
+static void ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)
+#endif
+
 {
 	struct sk_buff *ns;
 	int proto, len, npi;
 
+//brad add for pptp mppe rx out of order
+#ifdef FAST_PPTP
+	if(is_fast_fw){
+		ppp_mppe_state *state;
+		unsigned int curr_ccount=0;
+			if((skb->data[2] & 0x10) == 0x10){
+					state = (ppp_mppe_state *) ppp->rc_state;
+					curr_ccount = MPPE_CCOUNT(skb->data);
+					if(state->ccount < 4096 && state->ccount != 0 ){
+						if(curr_ccount < state->ccount && curr_ccount > 0){
+								kfree_skb(skb);
+								return NULL;
+							}
+					}else if(curr_ccount == 4095 && state->ccount == 0){
+								kfree_skb(skb);
+								return NULL;
+
+					}
+			}
+		}
+#endif
+
 	/*
 	 * Decompress the frame, if compressed.
 	 * Note that some decompressors need to see uncompressed frames
@@ -1672,8 +2170,10 @@
 	    && (ppp->rstate & (SC_DC_FERROR | SC_DC_ERROR)) == 0)
 		skb = ppp_decompress_frame(ppp, skb);
 
+#if !defined(CONFIG_PPP_MPPE_MPPC)
 	if (ppp->flags & SC_MUST_COMP && ppp->rstate & SC_DC_FERROR)
 		goto err;
+#endif
 
 	proto = PPP_PROTO(skb);
 	switch (proto) {
@@ -1737,6 +2237,12 @@
 
 	npi = proto_to_npindex(proto);
 	if (npi < 0) {
+#ifdef FAST_PPTP
+		if (is_fast_fw) {
+			kfree_skb(skb);
+			return NULL;
+		}
+#endif
 		/* control or unknown frame - pass it to pppd */
 		skb_queue_tail(&ppp->file.rq, skb);
 		/* limit queue length by dropping old frames */
@@ -1786,14 +2292,30 @@
 			skb->dev = ppp->dev;
 			skb->protocol = htons(npindex_to_ethertype[npi]);
 			skb_reset_mac_header(skb);
+#ifdef FAST_PPTP
+			if (is_fast_fw)
+				return skb;
+			else
+#endif
+#if defined(CONFIG_RTL_819X)&&defined(RX_TASKLET)
+			netif_receive_skb(skb);
+#else
 			netif_rx(skb);
+#endif
 		}
 	}
+#ifdef FAST_PPTP
+	return NULL;
+#else
 	return;
+#endif
 
  err:
 	kfree_skb(skb);
 	ppp_receive_error(ppp);
+#ifdef FAST_PPTP
+	return NULL;
+#endif
 }
 
 static struct sk_buff *
@@ -1814,10 +2336,18 @@
 
 		switch(ppp->rcomp->compress_proto) {
 		case CI_MPPE:
+#if defined(CONFIG_PPP_MPPE_MPPC)
+			obuff_size = ppp->mru_alloc + PPP_HDRLEN + 1;
+#else
 			obuff_size = ppp->mru + PPP_HDRLEN + 1;
+#endif
 			break;
 		default:
+#if defined(CONFIG_PPP_MPPE_MPPC)
+			obuff_size = ppp->mru_alloc + PPP_HDRLEN;
+#else
 			obuff_size = ppp->mru + PPP_HDRLEN;
+#endif
 			break;
 		}
 
@@ -1854,7 +2384,18 @@
 	return skb;
 
  err:
+ #if defined(CONFIG_PPP_MPPE_MPPC)
+       if (ppp->rcomp->compress_proto != CI_MPPE
+           && ppp->rcomp->compress_proto != CI_LZS) {
+           /*
+            * If decompression protocol isn't MPPE/MPPC or LZS, we set
+            * SC_DC_ERROR flag and wait for CCP_RESETACK
+            */
 	ppp->rstate |= SC_DC_ERROR;
+       }
+ #else
+	ppp->rstate |= SC_DC_ERROR;
+ #endif
 	ppp_receive_error(ppp);
 	return skb;
 }
@@ -1943,7 +2484,11 @@
 
 	/* Pull completed packets off the queue and receive them. */
 	while ((skb = ppp_mp_reconstruct(ppp)))
+#ifdef FAST_PPTP
+		ppp_receive_nonmp_frame(ppp, skb, 0);
+#else
 		ppp_receive_nonmp_frame(ppp, skb);
+#endif
 
 	return;
 
@@ -2169,6 +2714,19 @@
 	return unit;
 }
 
+#ifdef CONFIG_RTL_PPPOE_HWACC
+/*
+ * Mark the pppoe type for a channel
+ */
+void ppp_channel_pppoe(struct ppp_channel *chan)
+{
+	struct channel *pch = chan->ppp;
+
+	pch->pppoe = TRUE;
+}
+#endif
+
+
 /*
  * Disconnect a channel from the generic layer.
  * This must be called in process context.
@@ -2541,6 +3099,9 @@
 	ppp = netdev_priv(dev);
 	ppp->dev = dev;
 	ppp->mru = PPP_MRU;
+#if defined(CONFIG_PPP_MPPE_MPPC)
+	ppp->mru_alloc = PPP_MRU;
+#endif
 	init_ppp_file(&ppp->file, INTERFACE);
 	ppp->file.hdrlen = PPP_HDRLEN - 2;	/* don't count proto bytes */
 	for (i = 0; i < NUM_NP; ++i)
@@ -2633,6 +3194,10 @@
 static void ppp_shutdown_interface(struct ppp *ppp)
 {
 	struct ppp_net *pn;
+#ifdef CONFIG_RTL_PPPOE_HWACC
+	char dev_name[IFNAMSIZ];
+	memcpy(dev_name, ppp->dev->name, IFNAMSIZ);
+#endif
 
 	pn = ppp_pernet(ppp->ppp_net);
 	mutex_lock(&pn->all_ppp_mutex);
@@ -2649,6 +3214,33 @@
 	unit_put(&pn->units_idr, ppp->file.index);
 	ppp->file.dead = 1;
 	ppp->owner = NULL;
+
+#if defined(FAST_L2TP)
+	{
+		extern int fast_l2tp_fw;
+		if(fast_l2tp_fw)
+			event_ppp_dev_down(dev_name);
+	}
+#endif
+
+#ifdef CONFIG_RTL_PPPOE_HWACC
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+#if 1
+	rtl865x_detachMasterNetif(dev_name);
+#endif
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2	// sync from voip customer for multiple ppp
+	#if defined (CONFIG_RTL_HW_QOS_SUPPORT)
+	rtl865x_qosFlushMarkRuleByDev(dev_name);
+	#endif
+#endif
+	rtl865x_delPppbyIfName(dev_name);
+#endif
+#else
+	rtl865x_delPppSession(dev_name,  SE_PPPOE);
+#endif
+#endif
+
 	wake_up_interruptible(&ppp->file.rwait);
 
 	mutex_unlock(&pn->all_ppp_mutex);
@@ -2892,6 +3484,12 @@
 module_init(ppp_init);
 module_exit(ppp_cleanup);
 
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	#if defined(CONFIG_FAST_PATH_MODULE)
+	EXPORT_SYMBOL(ppp_start_xmit);
+	#endif
+#endif
+
 EXPORT_SYMBOL(ppp_register_net_channel);
 EXPORT_SYMBOL(ppp_register_channel);
 EXPORT_SYMBOL(ppp_unregister_channel);
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/pppoe.c linux-2.6.30.9-rsdk/drivers/net/pppoe.c
--- linux-2.6.30.9/drivers/net/pppoe.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/pppoe.c	2011-12-05 15:50:14.000000000 +0000
@@ -699,6 +699,10 @@
 		if (error)
 			goto err_put;
 
+#ifdef CONFIG_RTL_PPPOE_HWACC
+		ppp_channel_pppoe(&po->chan);
+#endif
+
 		sk->sk_state = PPPOX_CONNECTED;
 	}
 
@@ -908,6 +912,9 @@
  * xmit function for internal use.
  *
  ***********************************************************************/
+ #if defined(CONFIG_NET_SCHED)
+ extern int gQosEnabled;
+ #endif
 static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb)
 {
 	struct pppox_sock *po = pppox_sk(sk);
@@ -943,7 +950,17 @@
 	dev_hard_header(skb, dev, ETH_P_PPP_SES,
 			po->pppoe_pa.remote, NULL, data_len);
 
+	/*Improve pppoe wantype throughput when QoS disabled.*/
+#if defined(CONFIG_NET_SCHED)
+	if (gQosEnabled) 
+	{
 	dev_queue_xmit(skb);
+	}
+	else
+#endif
+	{
+		skb->dev->netdev_ops->ndo_start_xmit(skb,skb->dev);
+	}
 
 	return 1;
 
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/tg3.c linux-2.6.30.9-rsdk/drivers/net/tg3.c
--- linux-2.6.30.9/drivers/net/tg3.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/tg3.c	2011-12-05 15:50:14.000000000 +0000
@@ -6242,6 +6242,11 @@
 				      PCI_EXP_DEVSTA_URD);
 	}
 
+    /* tonywu */
+    pci_write_config_word(tp->pdev, tp->pcie_cap + PCI_EXP_DEVCTL, 0);
+    pcie_set_readrq(tp->pdev, 128);
+    /* tonywu */
+
 	tg3_restore_pci_state(tp);
 
 	tp->tg3_flags &= ~TG3_FLAG_CHIP_RESETTING;
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/wireless/Kconfig linux-2.6.30.9-rsdk/drivers/net/wireless/Kconfig
--- linux-2.6.30.9/drivers/net/wireless/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/wireless/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -434,6 +434,12 @@
 
 	  Thanks to Realtek for their support!
 
+config RTL8192SE_mac80211
+	tristate "Realtek 8192SE wireless chip support"
+	depends on MAC80211 && WLAN_80211
+	---help---
+	  This is a driver for RTL8192SE that support mac80211 
+
 config ADM8211
 	tristate "ADMtek ADM8211 support"
 	depends on MAC80211 && PCI && WLAN_80211 && EXPERIMENTAL
@@ -483,17 +489,8 @@
 	  To compile this driver as a module, choose M here: the module
 	  will be called mwl8k.  If unsure, say N.
 
-source "drivers/net/wireless/p54/Kconfig"
-source "drivers/net/wireless/ath5k/Kconfig"
-source "drivers/net/wireless/ath9k/Kconfig"
-source "drivers/net/wireless/ar9170/Kconfig"
-source "drivers/net/wireless/ipw2x00/Kconfig"
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
-source "drivers/net/wireless/b43/Kconfig"
-source "drivers/net/wireless/b43legacy/Kconfig"
-source "drivers/net/wireless/zd1211rw/Kconfig"
-source "drivers/net/wireless/rt2x00/Kconfig"
-source "drivers/net/wireless/orinoco/Kconfig"
+source "drivers/net/wireless/rtl8192cd/Kconfig"
 
 endmenu
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/net/wireless/Makefile linux-2.6.30.9-rsdk/drivers/net/wireless/Makefile
--- linux-2.6.30.9/drivers/net/wireless/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/net/wireless/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -2,8 +2,6 @@
 # Makefile for the Linux Wireless network device drivers.
 #
 
-obj-$(CONFIG_IPW2100) += ipw2x00/
-obj-$(CONFIG_IPW2200) += ipw2x00/
 
 obj-$(CONFIG_STRIP) += strip.o
 obj-$(CONFIG_ARLAN) += arlan.o 
@@ -24,16 +22,9 @@
 obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
 
-obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
 
-obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_B43)		+= b43/
-obj-$(CONFIG_B43LEGACY)		+= b43legacy/
-obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
-obj-$(CONFIG_RTL8180)		+= rtl818x/
-obj-$(CONFIG_RTL8187)		+= rtl818x/
 
 # 16-bit wireless PCMCIA client drivers
 obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
@@ -51,12 +42,7 @@
 obj-$(CONFIG_MWL8K)	+= mwl8k.o
 
 obj-$(CONFIG_IWLWIFI)	+= iwlwifi/
-obj-$(CONFIG_RT2X00)	+= rt2x00/
 
-obj-$(CONFIG_P54_COMMON)	+= p54/
 
-obj-$(CONFIG_ATH5K)	+= ath5k/
-obj-$(CONFIG_ATH9K)	+= ath9k/
-obj-$(CONFIG_AR9170_USB)	+= ar9170/
 
-obj-$(CONFIG_MAC80211_HWSIM)	+= mac80211_hwsim.o
+obj-$(CONFIG_RTL8192CD)         += rtl8192cd/
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/pci/access.c linux-2.6.30.9-rsdk/drivers/pci/access.c
--- linux-2.6.30.9/drivers/pci/access.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/pci/access.c	2011-12-05 15:50:14.000000000 +0000
@@ -38,6 +38,46 @@
 	spin_unlock_irqrestore(&pci_lock, flags);			\
 	return res;							\
 }
+#ifdef CONFIG_RTL8198_REVISION_B
+int pci_bus_read_config_word
+	(struct pci_bus *bus, unsigned int devfn, int pos, u16 *value)
+{									
+	int res;							
+	unsigned long flags;						
+	u32 data = 0;							
+	if (PCI_word_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	
+	spin_lock_irqsave(&pci_lock, flags);	
+
+	int swap[4]={0,8,16,24};	int diff = pos&0x3;
+	res = bus->ops->read(bus, devfn, (pos&0xFFFFC), 4, &data);	
+	*value =(u16)( (data>>(swap[diff]))&0xffff);
+
+
+	
+	
+	//*value = (type)data;						
+	spin_unlock_irqrestore(&pci_lock, flags);			
+	return res;							
+}
+int pci_bus_read_config_byte
+	(struct pci_bus *bus, unsigned int devfn, int pos, u8 *value)
+{									
+	int res;							
+	unsigned long flags;						
+	u32 data = 0;							
+	if (PCI_word_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	
+	spin_lock_irqsave(&pci_lock, flags);	
+
+	int swap[4]={0,8,16,24};	int diff = pos&0x3;
+	res = bus->ops->read(bus, devfn, (pos&0xFFFFC), 4, &data);	
+	*value =(u8)( (data>>(swap[diff]))&0xff);
+	//*value = (type)data;						
+	spin_unlock_irqrestore(&pci_lock, flags);			
+	return res;							
+}
+
+#endif
+
 
 #define PCI_OP_WRITE(size,type,len) \
 int pci_bus_write_config_##size \
@@ -52,8 +92,11 @@
 	return res;							\
 }
 
+#ifndef CONFIG_RTL8198_REVISION_B
 PCI_OP_READ(byte, u8, 1)
+
 PCI_OP_READ(word, u16, 2)
+#endif
 PCI_OP_READ(dword, u32, 4)
 PCI_OP_WRITE(byte, u8, 1)
 PCI_OP_WRITE(word, u16, 2)
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/scsi/scsi_lib.c linux-2.6.30.9-rsdk/drivers/scsi/scsi_lib.c
--- linux-2.6.30.9/drivers/scsi/scsi_lib.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/scsi/scsi_lib.c	2011-12-05 15:50:14.000000000 +0000
@@ -1626,7 +1626,7 @@
 
 	host_dev = scsi_get_device(shost);
 	if (host_dev && host_dev->dma_mask)
-		bounce_limit = *host_dev->dma_mask;
+		bounce_limit = *(host_dev->dma_mask);
 
 	return bounce_limit;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/serial/8250.c linux-2.6.30.9-rsdk/drivers/serial/8250.c
--- linux-2.6.30.9/drivers/serial/8250.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/serial/8250.c	2011-12-05 15:50:14.000000000 +0000
@@ -44,10 +44,6 @@
 
 #include "8250.h"
 
-#ifdef CONFIG_SPARC
-#include "suncore.h"
-#endif
-
 /*
  * Configuration:
  *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
@@ -117,13 +113,6 @@
 
 #define UART_NR	CONFIG_SERIAL_8250_NR_UARTS
 
-#ifdef CONFIG_SERIAL_8250_RSA
-
-#define PORT_RSA_MAX 4
-static unsigned long probe_rsa[PORT_RSA_MAX];
-static unsigned int probe_rsa_count;
-#endif /* CONFIG_SERIAL_8250_RSA  */
-
 struct uart_8250_port {
 	struct uart_port	port;
 	struct timer_list	timer;		/* "no irq" timer */
@@ -181,196 +170,45 @@
 		.fifo_size	= 1,
 		.tx_loadsz	= 1,
 	},
-	[PORT_16450] = {
-		.name		= "16450",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16550] = {
-		.name		= "16550",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16550A] = {
-		.name		= "16550A",
-		.fifo_size	= 16,
-		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO,
-	},
-	[PORT_CIRRUS] = {
-		.name		= "Cirrus",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16650] = {
-		.name		= "ST16650",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_16650V2] = {
-		.name		= "ST16650V2",
-		.fifo_size	= 32,
-		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |
-				  UART_FCR_T_TRIG_00,
-		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_16750] = {
-		.name		= "TI16750",
-		.fifo_size	= 64,
-		.tx_loadsz	= 64,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10 |
-				  UART_FCR7_64BYTE,
-		.flags		= UART_CAP_FIFO | UART_CAP_SLEEP | UART_CAP_AFE,
-	},
-	[PORT_STARTECH] = {
-		.name		= "Startech",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16C950] = {
-		.name		= "16C950/954",
-		.fifo_size	= 128,
-		.tx_loadsz	= 128,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO,
-	},
+#ifdef CONFIG_SERIAL_SC16IS7X0
 	[PORT_16654] = {
 		.name		= "ST16654",
+#if 0
 		.fifo_size	= 64,
 		.tx_loadsz	= 32,
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |
 				  UART_FCR_T_TRIG_10,
 		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_16850] = {
-		.name		= "XR16850",
-		.fifo_size	= 128,
-		.tx_loadsz	= 128,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_RSA] = {
-		.name		= "RSA",
-		.fifo_size	= 2048,
-		.tx_loadsz	= 2048,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_11,
-		.flags		= UART_CAP_FIFO,
-	},
-	[PORT_NS16550A] = {
-		.name		= "NS16550A",
+#else
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO | UART_NATSEMI,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
+		.flags		= UART_CAP_FIFO,
+#endif
 	},
-	[PORT_XSCALE] = {
-		.name		= "XScale",
-		.fifo_size	= 32,
-		.tx_loadsz	= 32,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO | UART_CAP_UUE,
+#endif
+	[PORT_16550] = {
+		.name		= "16550",
+		.fifo_size	= 1,
+		.tx_loadsz	= 1,
 	},
-	[PORT_RM9000] = {
-		.name		= "RM9000",
+	[PORT_16550A] = {
+		.name		= "16550A",
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO,
-	},
-	[PORT_OCTEON] = {
-		.name		= "OCTEON",
-		.fifo_size	= 64,
-		.tx_loadsz	= 64,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
+#ifdef CONFIG_SERIAL_RTL8198_UART1
+		.flags		= UART_CAP_FIFO | UART_CAP_AFE,
+#else
 		.flags		= UART_CAP_FIFO,
+#endif
 	},
 };
 
-#if defined (CONFIG_SERIAL_8250_AU1X00)
-
-/* Au1x00 UART hardware has a weird register layout */
-static const u8 au_io_in_map[] = {
-	[UART_RX]  = 0,
-	[UART_IER] = 2,
-	[UART_IIR] = 3,
-	[UART_LCR] = 5,
-	[UART_MCR] = 6,
-	[UART_LSR] = 7,
-	[UART_MSR] = 8,
-};
-
-static const u8 au_io_out_map[] = {
-	[UART_TX]  = 1,
-	[UART_IER] = 2,
-	[UART_FCR] = 4,
-	[UART_LCR] = 5,
-	[UART_MCR] = 6,
-};
-
-/* sane hardware needs no mapping */
-static inline int map_8250_in_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_AU)
-		return offset;
-	return au_io_in_map[offset];
-}
-
-static inline int map_8250_out_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_AU)
-		return offset;
-	return au_io_out_map[offset];
-}
-
-#elif defined(CONFIG_SERIAL_8250_RM9K)
-
-static const u8
-	regmap_in[8] = {
-		[UART_RX]	= 0x00,
-		[UART_IER]	= 0x0c,
-		[UART_IIR]	= 0x14,
-		[UART_LCR]	= 0x1c,
-		[UART_MCR]	= 0x20,
-		[UART_LSR]	= 0x24,
-		[UART_MSR]	= 0x28,
-		[UART_SCR]	= 0x2c
-	},
-	regmap_out[8] = {
-		[UART_TX] 	= 0x04,
-		[UART_IER]	= 0x0c,
-		[UART_FCR]	= 0x18,
-		[UART_LCR]	= 0x1c,
-		[UART_MCR]	= 0x20,
-		[UART_LSR]	= 0x24,
-		[UART_MSR]	= 0x28,
-		[UART_SCR]	= 0x2c
-	};
-
-static inline int map_8250_in_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_RM9000)
-		return offset;
-	return regmap_in[offset];
-}
-
-static inline int map_8250_out_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_RM9000)
-		return offset;
-	return regmap_out[offset];
-}
-
-#else
-
 /* sane hardware needs no mapping */
 #define map_8250_in_reg(up, offset) (offset)
 #define map_8250_out_reg(up, offset) (offset)
 
-#endif
-
 static unsigned int hub6_serial_in(struct uart_port *p, int offset)
 {
 	offset = map_8250_in_reg(p, offset) << p->regshift;
@@ -409,38 +247,6 @@
 	return readl(p->membase + offset);
 }
 
-#ifdef CONFIG_SERIAL_8250_AU1X00
-static unsigned int au_serial_in(struct uart_port *p, int offset)
-{
-	offset = map_8250_in_reg(p, offset) << p->regshift;
-	return __raw_readl(p->membase + offset);
-}
-
-static void au_serial_out(struct uart_port *p, int offset, int value)
-{
-	offset = map_8250_out_reg(p, offset) << p->regshift;
-	__raw_writel(value, p->membase + offset);
-}
-#endif
-
-static unsigned int tsi_serial_in(struct uart_port *p, int offset)
-{
-	unsigned int tmp;
-	offset = map_8250_in_reg(p, offset) << p->regshift;
-	if (offset == UART_IIR) {
-		tmp = readl(p->membase + (UART_IIR & ~3));
-		return (tmp >> 16) & 0xff; /* UART_IIR % 4 == 2 */
-	} else
-		return readb(p->membase + offset);
-}
-
-static void tsi_serial_out(struct uart_port *p, int offset, int value)
-{
-	offset = map_8250_out_reg(p, offset) << p->regshift;
-	if (!((offset == UART_IER) && (value & UART_IER_UUE)))
-		writeb(value, p->membase + offset);
-}
-
 static void dwapb_serial_out(struct uart_port *p, int offset, int value)
 {
 	int save_offset = offset;
@@ -451,7 +257,7 @@
 		struct uart_8250_port *up = (struct uart_8250_port *)p;
 		up->lcr = value;
 	}
-	writeb(value, p->membase + offset);
+	writel(value, p->membase + offset);
 	/* Read the IER to ensure any interrupt is cleared before
 	 * returning from ISR. */
 	if (save_offset == UART_TX || save_offset == UART_IER)
@@ -470,13 +276,25 @@
 	outb(value, p->iobase + offset);
 }
 
+#ifdef CONFIG_SERIAL_SC16IS7X0
+static unsigned int i2c_serial_in(struct uart_port *p, int offset)
+{
+	extern unsigned int serial_in_i2c(unsigned int i2c_addr, int offset);
+	return serial_in_i2c( p ->iobase, offset );
+}
+static void i2c_serial_out(struct uart_port *p, int offset, int value)
+{
+	extern unsigned int serial_out_i2c(unsigned int i2c_addr, int offset, int value);
+	serial_out_i2c( p ->iobase, offset, value );
+}
+#endif
 static void set_io_from_upio(struct uart_port *p)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)p;
 	switch (p->iotype) {
-	case UPIO_HUB6:
-		p->serial_in = hub6_serial_in;
-		p->serial_out = hub6_serial_out;
+	case UPIO_DWAPB:
+		p->serial_in = mem32_serial_in;
+		p->serial_out = dwapb_serial_out;
 		break;
 
 	case UPIO_MEM:
@@ -484,27 +302,21 @@
 		p->serial_out = mem_serial_out;
 		break;
 
-	case UPIO_RM9000:
 	case UPIO_MEM32:
 		p->serial_in = mem32_serial_in;
 		p->serial_out = mem32_serial_out;
 		break;
 
-#ifdef CONFIG_SERIAL_8250_AU1X00
-	case UPIO_AU:
-		p->serial_in = au_serial_in;
-		p->serial_out = au_serial_out;
-		break;
-#endif
-	case UPIO_TSI:
-		p->serial_in = tsi_serial_in;
-		p->serial_out = tsi_serial_out;
+	case UPIO_HUB6:
+		p->serial_in = hub6_serial_in;
+		p->serial_out = hub6_serial_out;
 		break;
-
-	case UPIO_DWAPB:
-		p->serial_in = mem_serial_in;
-		p->serial_out = dwapb_serial_out;
+#ifdef CONFIG_SERIAL_SC16IS7X0
+	case UPIO_I2C:
+		p->serial_in = i2c_serial_in;
+		p->serial_out = i2c_serial_out;
 		break;
+#endif
 
 	default:
 		p->serial_in = io_serial_in;
@@ -520,12 +332,9 @@
 {
 	struct uart_port *p = &up->port;
 	switch (p->iotype) {
+	case UPIO_DWAPB:
 	case UPIO_MEM:
 	case UPIO_MEM32:
-#ifdef CONFIG_SERIAL_8250_AU1X00
-	case UPIO_AU:
-#endif
-	case UPIO_DWAPB:
 		p->serial_out(p, offset, value);
 		p->serial_in(p, UART_LCR);	/* safe, no side-effects */
 		break;
@@ -538,88 +347,22 @@
 	(up->port.serial_in(&(up)->port, (offset)))
 #define serial_out(up, offset, value)	\
 	(up->port.serial_out(&(up)->port, (offset), (value)))
-/*
- * We used to support using pause I/O for certain machines.  We
- * haven't supported this for a while, but just in case it's badly
- * needed for certain old 386 machines, I've left these #define's
- * in....
- */
-#define serial_inp(up, offset)		serial_in(up, offset)
-#define serial_outp(up, offset, value)	serial_out(up, offset, value)
 
 /* Uart divisor latch read */
 static inline int _serial_dl_read(struct uart_8250_port *up)
 {
-	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
+	return serial_in(up, UART_DLL) | serial_in(up, UART_DLM) << 8;
 }
 
 /* Uart divisor latch write */
 static inline void _serial_dl_write(struct uart_8250_port *up, int value)
 {
-	serial_outp(up, UART_DLL, value & 0xff);
-	serial_outp(up, UART_DLM, value >> 8 & 0xff);
-}
-
-#if defined(CONFIG_SERIAL_8250_AU1X00)
-/* Au1x00 haven't got a standard divisor latch */
-static int serial_dl_read(struct uart_8250_port *up)
-{
-	if (up->port.iotype == UPIO_AU)
-		return __raw_readl(up->port.membase + 0x28);
-	else
-		return _serial_dl_read(up);
-}
-
-static void serial_dl_write(struct uart_8250_port *up, int value)
-{
-	if (up->port.iotype == UPIO_AU)
-		__raw_writel(value, up->port.membase + 0x28);
-	else
-		_serial_dl_write(up, value);
-}
-#elif defined(CONFIG_SERIAL_8250_RM9K)
-static int serial_dl_read(struct uart_8250_port *up)
-{
-	return	(up->port.iotype == UPIO_RM9000) ?
-		(((__raw_readl(up->port.membase + 0x10) << 8) |
-		(__raw_readl(up->port.membase + 0x08) & 0xff)) & 0xffff) :
-		_serial_dl_read(up);
+	serial_out(up, UART_DLL, value & 0xff);
+	serial_out(up, UART_DLM, value >> 8 & 0xff);
 }
 
-static void serial_dl_write(struct uart_8250_port *up, int value)
-{
-	if (up->port.iotype == UPIO_RM9000) {
-		__raw_writel(value, up->port.membase + 0x08);
-		__raw_writel(value >> 8, up->port.membase + 0x10);
-	} else {
-		_serial_dl_write(up, value);
-	}
-}
-#else
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
-#endif
-
-/*
- * For the 16C950
- */
-static void serial_icr_write(struct uart_8250_port *up, int offset, int value)
-{
-	serial_out(up, UART_SCR, offset);
-	serial_out(up, UART_ICR, value);
-}
-
-static unsigned int serial_icr_read(struct uart_8250_port *up, int offset)
-{
-	unsigned int value;
-
-	serial_icr_write(up, UART_ACR, up->acr | UART_ACR_ICRRD);
-	serial_out(up, UART_SCR, offset);
-	value = serial_in(up, UART_ICR);
-	serial_icr_write(up, UART_ACR, up->acr);
-
-	return value;
-}
 
 /*
  * FIFO support.
@@ -627,10 +370,10 @@
 static void serial8250_clear_fifos(struct uart_8250_port *p)
 {
 	if (p->capabilities & UART_CAP_FIFO) {
-		serial_outp(p, UART_FCR, UART_FCR_ENABLE_FIFO);
-		serial_outp(p, UART_FCR, UART_FCR_ENABLE_FIFO |
+		serial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO);
+		serial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO |
 			       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-		serial_outp(p, UART_FCR, 0);
+		serial_out(p, UART_FCR, 0);
 	}
 }
 
@@ -643,657 +386,17 @@
 {
 	if (p->capabilities & UART_CAP_SLEEP) {
 		if (p->capabilities & UART_CAP_EFR) {
-			serial_outp(p, UART_LCR, 0xBF);
-			serial_outp(p, UART_EFR, UART_EFR_ECB);
-			serial_outp(p, UART_LCR, 0);
+			serial_out(p, UART_LCR, 0xBF);
+			serial_out(p, UART_EFR, UART_EFR_ECB);
+			serial_out(p, UART_LCR, 0);
 		}
-		serial_outp(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
+		serial_out(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
 		if (p->capabilities & UART_CAP_EFR) {
-			serial_outp(p, UART_LCR, 0xBF);
-			serial_outp(p, UART_EFR, 0);
-			serial_outp(p, UART_LCR, 0);
-		}
-	}
-}
-
-#ifdef CONFIG_SERIAL_8250_RSA
-/*
- * Attempts to turn on the RSA FIFO.  Returns zero on failure.
- * We set the port uart clock rate if we succeed.
- */
-static int __enable_rsa(struct uart_8250_port *up)
-{
-	unsigned char mode;
-	int result;
-
-	mode = serial_inp(up, UART_RSA_MSR);
-	result = mode & UART_RSA_MSR_FIFO;
-
-	if (!result) {
-		serial_outp(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);
-		mode = serial_inp(up, UART_RSA_MSR);
-		result = mode & UART_RSA_MSR_FIFO;
-	}
-
-	if (result)
-		up->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;
-
-	return result;
-}
-
-static void enable_rsa(struct uart_8250_port *up)
-{
-	if (up->port.type == PORT_RSA) {
-		if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {
-			spin_lock_irq(&up->port.lock);
-			__enable_rsa(up);
-			spin_unlock_irq(&up->port.lock);
-		}
-		if (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)
-			serial_outp(up, UART_RSA_FRR, 0);
-	}
-}
-
-/*
- * Attempts to turn off the RSA FIFO.  Returns zero on failure.
- * It is unknown why interrupts were disabled in here.  However,
- * the caller is expected to preserve this behaviour by grabbing
- * the spinlock before calling this function.
- */
-static void disable_rsa(struct uart_8250_port *up)
-{
-	unsigned char mode;
-	int result;
-
-	if (up->port.type == PORT_RSA &&
-	    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {
-		spin_lock_irq(&up->port.lock);
-
-		mode = serial_inp(up, UART_RSA_MSR);
-		result = !(mode & UART_RSA_MSR_FIFO);
-
-		if (!result) {
-			serial_outp(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);
-			mode = serial_inp(up, UART_RSA_MSR);
-			result = !(mode & UART_RSA_MSR_FIFO);
-		}
-
-		if (result)
-			up->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
-		spin_unlock_irq(&up->port.lock);
-	}
-}
-#endif /* CONFIG_SERIAL_8250_RSA */
-
-/*
- * This is a quickie test to see how big the FIFO is.
- * It doesn't work at all the time, more's the pity.
- */
-static int size_fifo(struct uart_8250_port *up)
-{
-	unsigned char old_fcr, old_mcr, old_lcr;
-	unsigned short old_dl;
-	int count;
-
-	old_lcr = serial_inp(up, UART_LCR);
-	serial_outp(up, UART_LCR, 0);
-	old_fcr = serial_inp(up, UART_FCR);
-	old_mcr = serial_inp(up, UART_MCR);
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |
-		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-	serial_outp(up, UART_MCR, UART_MCR_LOOP);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	old_dl = serial_dl_read(up);
-	serial_dl_write(up, 0x0001);
-	serial_outp(up, UART_LCR, 0x03);
-	for (count = 0; count < 256; count++)
-		serial_outp(up, UART_TX, count);
-	mdelay(20);/* FIXME - schedule_timeout */
-	for (count = 0; (serial_inp(up, UART_LSR) & UART_LSR_DR) &&
-	     (count < 256); count++)
-		serial_inp(up, UART_RX);
-	serial_outp(up, UART_FCR, old_fcr);
-	serial_outp(up, UART_MCR, old_mcr);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	serial_dl_write(up, old_dl);
-	serial_outp(up, UART_LCR, old_lcr);
-
-	return count;
-}
-
-/*
- * Read UART ID using the divisor method - set DLL and DLM to zero
- * and the revision will be in DLL and device type in DLM.  We
- * preserve the device state across this.
- */
-static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
-{
-	unsigned char old_dll, old_dlm, old_lcr;
-	unsigned int id;
-
-	old_lcr = serial_inp(p, UART_LCR);
-	serial_outp(p, UART_LCR, UART_LCR_DLAB);
-
-	old_dll = serial_inp(p, UART_DLL);
-	old_dlm = serial_inp(p, UART_DLM);
-
-	serial_outp(p, UART_DLL, 0);
-	serial_outp(p, UART_DLM, 0);
-
-	id = serial_inp(p, UART_DLL) | serial_inp(p, UART_DLM) << 8;
-
-	serial_outp(p, UART_DLL, old_dll);
-	serial_outp(p, UART_DLM, old_dlm);
-	serial_outp(p, UART_LCR, old_lcr);
-
-	return id;
-}
-
-/*
- * This is a helper routine to autodetect StarTech/Exar/Oxsemi UART's.
- * When this function is called we know it is at least a StarTech
- * 16650 V2, but it might be one of several StarTech UARTs, or one of
- * its clones.  (We treat the broken original StarTech 16650 V1 as a
- * 16550, and why not?  Startech doesn't seem to even acknowledge its
- * existence.)
- *
- * What evil have men's minds wrought...
- */
-static void autoconfig_has_efr(struct uart_8250_port *up)
-{
-	unsigned int id1, id2, id3, rev;
-
-	/*
-	 * Everything with an EFR has SLEEP
-	 */
-	up->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;
-
-	/*
-	 * First we check to see if it's an Oxford Semiconductor UART.
-	 *
-	 * If we have to do this here because some non-National
-	 * Semiconductor clone chips lock up if you try writing to the
-	 * LSR register (which serial_icr_read does)
-	 */
-
-	/*
-	 * Check for Oxford Semiconductor 16C950.
-	 *
-	 * EFR [4] must be set else this test fails.
-	 *
-	 * This shouldn't be necessary, but Mike Hudson (Exoray@isys.ca)
-	 * claims that it's needed for 952 dual UART's (which are not
-	 * recommended for new designs).
-	 */
-	up->acr = 0;
-	serial_out(up, UART_LCR, 0xBF);
-	serial_out(up, UART_EFR, UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0x00);
-	id1 = serial_icr_read(up, UART_ID1);
-	id2 = serial_icr_read(up, UART_ID2);
-	id3 = serial_icr_read(up, UART_ID3);
-	rev = serial_icr_read(up, UART_REV);
-
-	DEBUG_AUTOCONF("950id=%02x:%02x:%02x:%02x ", id1, id2, id3, rev);
-
-	if (id1 == 0x16 && id2 == 0xC9 &&
-	    (id3 == 0x50 || id3 == 0x52 || id3 == 0x54)) {
-		up->port.type = PORT_16C950;
-
-		/*
-		 * Enable work around for the Oxford Semiconductor 952 rev B
-		 * chip which causes it to seriously miscalculate baud rates
-		 * when DLL is 0.
-		 */
-		if (id3 == 0x52 && rev == 0x01)
-			up->bugs |= UART_BUG_QUOT;
-		return;
-	}
-
-	/*
-	 * We check for a XR16C850 by setting DLL and DLM to 0, and then
-	 * reading back DLL and DLM.  The chip type depends on the DLM
-	 * value read back:
-	 *  0x10 - XR16C850 and the DLL contains the chip revision.
-	 *  0x12 - XR16C2850.
-	 *  0x14 - XR16C854.
-	 */
-	id1 = autoconfig_read_divisor_id(up);
-	DEBUG_AUTOCONF("850id=%04x ", id1);
-
-	id2 = id1 >> 8;
-	if (id2 == 0x10 || id2 == 0x12 || id2 == 0x14) {
-		up->port.type = PORT_16850;
-		return;
-	}
-
-	/*
-	 * It wasn't an XR16C850.
-	 *
-	 * We distinguish between the '654 and the '650 by counting
-	 * how many bytes are in the FIFO.  I'm using this for now,
-	 * since that's the technique that was sent to me in the
-	 * serial driver update, but I'm not convinced this works.
-	 * I've had problems doing this in the past.  -TYT
-	 */
-	if (size_fifo(up) == 64)
-		up->port.type = PORT_16654;
-	else
-		up->port.type = PORT_16650V2;
-}
-
-/*
- * We detected a chip without a FIFO.  Only two fall into
- * this category - the original 8250 and the 16450.  The
- * 16450 has a scratch register (accessible with LCR=0)
- */
-static void autoconfig_8250(struct uart_8250_port *up)
-{
-	unsigned char scratch, status1, status2;
-
-	up->port.type = PORT_8250;
-
-	scratch = serial_in(up, UART_SCR);
-	serial_outp(up, UART_SCR, 0xa5);
-	status1 = serial_in(up, UART_SCR);
-	serial_outp(up, UART_SCR, 0x5a);
-	status2 = serial_in(up, UART_SCR);
-	serial_outp(up, UART_SCR, scratch);
-
-	if (status1 == 0xa5 && status2 == 0x5a)
-		up->port.type = PORT_16450;
-}
-
-static int broken_efr(struct uart_8250_port *up)
-{
-	/*
-	 * Exar ST16C2550 "A2" devices incorrectly detect as
-	 * having an EFR, and report an ID of 0x0201.  See
-	 * http://www.exar.com/info.php?pdf=dan180_oct2004.pdf
-	 */
-	if (autoconfig_read_divisor_id(up) == 0x0201 && size_fifo(up) == 16)
-		return 1;
-
-	return 0;
-}
-
-/*
- * We know that the chip has FIFOs.  Does it have an EFR?  The
- * EFR is located in the same register position as the IIR and
- * we know the top two bits of the IIR are currently set.  The
- * EFR should contain zero.  Try to read the EFR.
- */
-static void autoconfig_16550a(struct uart_8250_port *up)
-{
-	unsigned char status1, status2;
-	unsigned int iersave;
-
-	up->port.type = PORT_16550A;
-	up->capabilities |= UART_CAP_FIFO;
-
-	/*
-	 * Check for presence of the EFR when DLAB is set.
-	 * Only ST16C650V1 UARTs pass this test.
-	 */
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	if (serial_in(up, UART_EFR) == 0) {
-		serial_outp(up, UART_EFR, 0xA8);
-		if (serial_in(up, UART_EFR) != 0) {
-			DEBUG_AUTOCONF("EFRv1 ");
-			up->port.type = PORT_16650;
-			up->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;
-		} else {
-			DEBUG_AUTOCONF("Motorola 8xxx DUART ");
-		}
-		serial_outp(up, UART_EFR, 0);
-		return;
-	}
-
-	/*
-	 * Maybe it requires 0xbf to be written to the LCR.
-	 * (other ST16C650V2 UARTs, TI16C752A, etc)
-	 */
-	serial_outp(up, UART_LCR, 0xBF);
-	if (serial_in(up, UART_EFR) == 0 && !broken_efr(up)) {
-		DEBUG_AUTOCONF("EFRv2 ");
-		autoconfig_has_efr(up);
-		return;
-	}
-
-	/*
-	 * Check for a National Semiconductor SuperIO chip.
-	 * Attempt to switch to bank 2, read the value of the LOOP bit
-	 * from EXCR1. Switch back to bank 0, change it in MCR. Then
-	 * switch back to bank 2, read it from EXCR1 again and check
-	 * it's changed. If so, set baud_base in EXCR2 to 921600. -- dwmw2
-	 */
-	serial_outp(up, UART_LCR, 0);
-	status1 = serial_in(up, UART_MCR);
-	serial_outp(up, UART_LCR, 0xE0);
-	status2 = serial_in(up, 0x02); /* EXCR1 */
-
-	if (!((status2 ^ status1) & UART_MCR_LOOP)) {
-		serial_outp(up, UART_LCR, 0);
-		serial_outp(up, UART_MCR, status1 ^ UART_MCR_LOOP);
-		serial_outp(up, UART_LCR, 0xE0);
-		status2 = serial_in(up, 0x02); /* EXCR1 */
-		serial_outp(up, UART_LCR, 0);
-		serial_outp(up, UART_MCR, status1);
-
-		if ((status2 ^ status1) & UART_MCR_LOOP) {
-			unsigned short quot;
-
-			serial_outp(up, UART_LCR, 0xE0);
-
-			quot = serial_dl_read(up);
-			quot <<= 3;
-
-			status1 = serial_in(up, 0x04); /* EXCR2 */
-			status1 &= ~0xB0; /* Disable LOCK, mask out PRESL[01] */
-			status1 |= 0x10;  /* 1.625 divisor for baud_base --> 921600 */
-			serial_outp(up, 0x04, status1);
-
-			serial_dl_write(up, quot);
-
-			serial_outp(up, UART_LCR, 0);
-
-			up->port.uartclk = 921600*16;
-			up->port.type = PORT_NS16550A;
-			up->capabilities |= UART_NATSEMI;
-			return;
-		}
-	}
-
-	/*
-	 * No EFR.  Try to detect a TI16750, which only sets bit 5 of
-	 * the IIR when 64 byte FIFO mode is enabled when DLAB is set.
-	 * Try setting it with and without DLAB set.  Cheap clones
-	 * set bit 5 without DLAB set.
-	 */
-	serial_outp(up, UART_LCR, 0);
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
-	status1 = serial_in(up, UART_IIR) >> 5;
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
-	status2 = serial_in(up, UART_IIR) >> 5;
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	serial_outp(up, UART_LCR, 0);
-
-	DEBUG_AUTOCONF("iir1=%d iir2=%d ", status1, status2);
-
-	if (status1 == 6 && status2 == 7) {
-		up->port.type = PORT_16750;
-		up->capabilities |= UART_CAP_AFE | UART_CAP_SLEEP;
-		return;
-	}
-
-	/*
-	 * Try writing and reading the UART_IER_UUE bit (b6).
-	 * If it works, this is probably one of the Xscale platform's
-	 * internal UARTs.
-	 * We're going to explicitly set the UUE bit to 0 before
-	 * trying to write and read a 1 just to make sure it's not
-	 * already a 1 and maybe locked there before we even start start.
-	 */
-	iersave = serial_in(up, UART_IER);
-	serial_outp(up, UART_IER, iersave & ~UART_IER_UUE);
-	if (!(serial_in(up, UART_IER) & UART_IER_UUE)) {
-		/*
-		 * OK it's in a known zero state, try writing and reading
-		 * without disturbing the current state of the other bits.
-		 */
-		serial_outp(up, UART_IER, iersave | UART_IER_UUE);
-		if (serial_in(up, UART_IER) & UART_IER_UUE) {
-			/*
-			 * It's an Xscale.
-			 * We'll leave the UART_IER_UUE bit set to 1 (enabled).
-			 */
-			DEBUG_AUTOCONF("Xscale ");
-			up->port.type = PORT_XSCALE;
-			up->capabilities |= UART_CAP_UUE;
-			return;
-		}
-	} else {
-		/*
-		 * If we got here we couldn't force the IER_UUE bit to 0.
-		 * Log it and continue.
-		 */
-		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
-	}
-	serial_outp(up, UART_IER, iersave);
-}
-
-/*
- * This routine is called by rs_init() to initialize a specific serial
- * port.  It determines what type of UART chip this serial port is
- * using: 8250, 16450, 16550, 16550A.  The important question is
- * whether or not this UART is a 16550A or not, since this will
- * determine whether or not we can use its FIFO features or not.
- */
-static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
-{
-	unsigned char status1, scratch, scratch2, scratch3;
-	unsigned char save_lcr, save_mcr;
-	unsigned long flags;
-
-	if (!up->port.iobase && !up->port.mapbase && !up->port.membase)
-		return;
-
-	DEBUG_AUTOCONF("ttyS%d: autoconf (0x%04x, 0x%p): ",
-		       serial_index(&up->port), up->port.iobase, up->port.membase);
-
-	/*
-	 * We really do need global IRQs disabled here - we're going to
-	 * be frobbing the chips IRQ enable register to see if it exists.
-	 */
-	spin_lock_irqsave(&up->port.lock, flags);
-
-	up->capabilities = 0;
-	up->bugs = 0;
-
-	if (!(up->port.flags & UPF_BUGGY_UART)) {
-		/*
-		 * Do a simple existence test first; if we fail this,
-		 * there's no point trying anything else.
-		 *
-		 * 0x80 is used as a nonsense port to prevent against
-		 * false positives due to ISA bus float.  The
-		 * assumption is that 0x80 is a non-existent port;
-		 * which should be safe since include/asm/io.h also
-		 * makes this assumption.
-		 *
-		 * Note: this is safe as long as MCR bit 4 is clear
-		 * and the device is in "PC" mode.
-		 */
-		scratch = serial_inp(up, UART_IER);
-		serial_outp(up, UART_IER, 0);
-#ifdef __i386__
-		outb(0xff, 0x080);
-#endif
-		/*
-		 * Mask out IER[7:4] bits for test as some UARTs (e.g. TL
-		 * 16C754B) allow only to modify them if an EFR bit is set.
-		 */
-		scratch2 = serial_inp(up, UART_IER) & 0x0f;
-		serial_outp(up, UART_IER, 0x0F);
-#ifdef __i386__
-		outb(0, 0x080);
-#endif
-		scratch3 = serial_inp(up, UART_IER) & 0x0f;
-		serial_outp(up, UART_IER, scratch);
-		if (scratch2 != 0 || scratch3 != 0x0F) {
-			/*
-			 * We failed; there's nothing here
-			 */
-			DEBUG_AUTOCONF("IER test failed (%02x, %02x) ",
-				       scratch2, scratch3);
-			goto out;
-		}
-	}
-
-	save_mcr = serial_in(up, UART_MCR);
-	save_lcr = serial_in(up, UART_LCR);
-
-	/*
-	 * Check to see if a UART is really there.  Certain broken
-	 * internal modems based on the Rockwell chipset fail this
-	 * test, because they apparently don't implement the loopback
-	 * test mode.  So this test is skipped on the COM 1 through
-	 * COM 4 ports.  This *should* be safe, since no board
-	 * manufacturer would be stupid enough to design a board
-	 * that conflicts with COM 1-4 --- we hope!
-	 */
-	if (!(up->port.flags & UPF_SKIP_TEST)) {
-		serial_outp(up, UART_MCR, UART_MCR_LOOP | 0x0A);
-		status1 = serial_inp(up, UART_MSR) & 0xF0;
-		serial_outp(up, UART_MCR, save_mcr);
-		if (status1 != 0x90) {
-			DEBUG_AUTOCONF("LOOP test failed (%02x) ",
-				       status1);
-			goto out;
-		}
-	}
-
-	/*
-	 * We're pretty sure there's a port here.  Lets find out what
-	 * type of port it is.  The IIR top two bits allows us to find
-	 * out if it's 8250 or 16450, 16550, 16550A or later.  This
-	 * determines what we test for next.
-	 *
-	 * We also initialise the EFR (if any) to zero for later.  The
-	 * EFR occupies the same register location as the FCR and IIR.
-	 */
-	serial_outp(up, UART_LCR, 0xBF);
-	serial_outp(up, UART_EFR, 0);
-	serial_outp(up, UART_LCR, 0);
-
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	scratch = serial_in(up, UART_IIR) >> 6;
-
-	DEBUG_AUTOCONF("iir=%d ", scratch);
-
-	switch (scratch) {
-	case 0:
-		autoconfig_8250(up);
-		break;
-	case 1:
-		up->port.type = PORT_UNKNOWN;
-		break;
-	case 2:
-		up->port.type = PORT_16550;
-		break;
-	case 3:
-		autoconfig_16550a(up);
-		break;
-	}
-
-#ifdef CONFIG_SERIAL_8250_RSA
-	/*
-	 * Only probe for RSA ports if we got the region.
-	 */
-	if (up->port.type == PORT_16550A && probeflags & PROBE_RSA) {
-		int i;
-
-		for (i = 0 ; i < probe_rsa_count; ++i) {
-			if (probe_rsa[i] == up->port.iobase &&
-			    __enable_rsa(up)) {
-				up->port.type = PORT_RSA;
-				break;
-			}
-		}
-	}
-#endif
-
-#ifdef CONFIG_SERIAL_8250_AU1X00
-	/* if access method is AU, it is a 16550 with a quirk */
-	if (up->port.type == PORT_16550A && up->port.iotype == UPIO_AU)
-		up->bugs |= UART_BUG_NOMSR;
-#endif
-
-	serial_outp(up, UART_LCR, save_lcr);
-
-	if (up->capabilities != uart_config[up->port.type].flags) {
-		printk(KERN_WARNING
-		       "ttyS%d: detected caps %08x should be %08x\n",
-		       serial_index(&up->port), up->capabilities,
-		       uart_config[up->port.type].flags);
-	}
-
-	up->port.fifosize = uart_config[up->port.type].fifo_size;
-	up->capabilities = uart_config[up->port.type].flags;
-	up->tx_loadsz = uart_config[up->port.type].tx_loadsz;
-
-	if (up->port.type == PORT_UNKNOWN)
-		goto out;
-
-	/*
-	 * Reset the UART.
-	 */
-#ifdef CONFIG_SERIAL_8250_RSA
-	if (up->port.type == PORT_RSA)
-		serial_outp(up, UART_RSA_FRR, 0);
-#endif
-	serial_outp(up, UART_MCR, save_mcr);
-	serial8250_clear_fifos(up);
-	serial_in(up, UART_RX);
-	if (up->capabilities & UART_CAP_UUE)
-		serial_outp(up, UART_IER, UART_IER_UUE);
-	else
-		serial_outp(up, UART_IER, 0);
-
- out:
-	spin_unlock_irqrestore(&up->port.lock, flags);
-	DEBUG_AUTOCONF("type=%s\n", uart_config[up->port.type].name);
+			serial_out(p, UART_LCR, 0xBF);
+			serial_out(p, UART_EFR, 0);
+			serial_out(p, UART_LCR, 0);
 }
-
-static void autoconfig_irq(struct uart_8250_port *up)
-{
-	unsigned char save_mcr, save_ier;
-	unsigned char save_ICP = 0;
-	unsigned int ICP = 0;
-	unsigned long irqs;
-	int irq;
-
-	if (up->port.flags & UPF_FOURPORT) {
-		ICP = (up->port.iobase & 0xfe0) | 0x1f;
-		save_ICP = inb_p(ICP);
-		outb_p(0x80, ICP);
-		(void) inb_p(ICP);
-	}
-
-	/* forget possible initially masked and pending IRQ */
-	probe_irq_off(probe_irq_on());
-	save_mcr = serial_inp(up, UART_MCR);
-	save_ier = serial_inp(up, UART_IER);
-	serial_outp(up, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);
-
-	irqs = probe_irq_on();
-	serial_outp(up, UART_MCR, 0);
-	udelay(10);
-	if (up->port.flags & UPF_FOURPORT) {
-		serial_outp(up, UART_MCR,
-			    UART_MCR_DTR | UART_MCR_RTS);
-	} else {
-		serial_outp(up, UART_MCR,
-			    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
 	}
-	serial_outp(up, UART_IER, 0x0f);	/* enable all intrs */
-	(void)serial_inp(up, UART_LSR);
-	(void)serial_inp(up, UART_RX);
-	(void)serial_inp(up, UART_IIR);
-	(void)serial_inp(up, UART_MSR);
-	serial_outp(up, UART_TX, 0xFF);
-	udelay(20);
-	irq = probe_irq_off(irqs);
-
-	serial_outp(up, UART_MCR, save_mcr);
-	serial_outp(up, UART_IER, save_ier);
-
-	if (up->port.flags & UPF_FOURPORT)
-		outb_p(save_ICP, ICP);
-
-	up->port.irq = (irq > 0) ? irq : 0;
 }
 
 static inline void __stop_tx(struct uart_8250_port *p)
@@ -1309,14 +412,6 @@
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
 	__stop_tx(up);
-
-	/*
-	 * We really want to stop the transmitter from sending.
-	 */
-	if (up->port.type == PORT_16C950) {
-		up->acr |= UART_ACR_TXDIS;
-		serial_icr_write(up, UART_ACR, up->acr);
-	}
 }
 
 static void transmit_chars(struct uart_8250_port *up);
@@ -1341,14 +436,6 @@
 				transmit_chars(up);
 		}
 	}
-
-	/*
-	 * Re-enable the transmitter if we disabled it.
-	 */
-	if (up->port.type == PORT_16C950 && up->acr & UART_ACR_TXDIS) {
-		up->acr &= ~UART_ACR_TXDIS;
-		serial_icr_write(up, UART_ACR, up->acr);
-	}
 }
 
 static void serial8250_stop_rx(struct uart_port *port)
@@ -1382,7 +469,7 @@
 
 	do {
 		if (likely(lsr & UART_LSR_DR))
-			ch = serial_inp(up, UART_RX);
+			ch = serial_in(up, UART_RX);
 		else
 			/*
 			 * Intel 82571 has a Serial Over Lan device that will
@@ -1440,7 +527,7 @@
 		uart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);
 
 ignore_char:
-		lsr = serial_inp(up, UART_LSR);
+		lsr = serial_in(up, UART_LSR);
 	} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));
 	spin_unlock(&up->port.lock);
 	tty_flip_buffer_push(tty);
@@ -1454,7 +541,7 @@
 	int count;
 
 	if (up->port.x_char) {
-		serial_outp(up, UART_TX, up->port.x_char);
+		serial_out(up, UART_TX, up->port.x_char);
 		up->port.icount.tx++;
 		up->port.x_char = 0;
 		return;
@@ -1519,7 +606,7 @@
 
 	spin_lock_irqsave(&up->port.lock, flags);
 
-	status = serial_inp(up, UART_LSR);
+	status = serial_in(up, UART_LSR);
 
 	DEBUG_INTR("status = %x...", status);
 
@@ -1552,6 +639,11 @@
 	struct list_head *l, *end = NULL;
 	int pass_counter = 0, handled = 0;
 
+#ifdef CONFIG_SERIAL_SC16IS7X0
+	extern int sc16is7x0_clean_interrupt( int irq );
+	if( sc16is7x0_clean_interrupt( irq ) < 0 )
+		return IRQ_RETVAL(handled);
+#endif
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
 	spin_lock(&i->lock);
@@ -1635,7 +727,8 @@
 	struct hlist_head *h;
 	struct hlist_node *n;
 	struct irq_info *i;
-	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+//	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : IRQF_DISABLED;
 
 	mutex_lock(&hash_mutex);
 
@@ -1682,7 +775,7 @@
 
 static void serial_unlink_irq_chain(struct uart_8250_port *up)
 {
-	struct irq_info *i;
+	struct irq_info *i=NULL;
 	struct hlist_node *n;
 	struct hlist_head *h;
 
@@ -1886,12 +979,12 @@
 static int serial8250_get_poll_char(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	unsigned char lsr = serial_inp(up, UART_LSR);
+	unsigned char lsr = serial_in(up, UART_LSR);
 
 	while (!(lsr & UART_LSR_DR))
-		lsr = serial_inp(up, UART_LSR);
+		lsr = serial_in(up, UART_LSR);
 
-	return serial_inp(up, UART_RX);
+	return serial_in(up, UART_RX);
 }
 
 
@@ -1944,27 +1037,6 @@
 	if (up->port.iotype != up->cur_iotype)
 		set_io_from_upio(port);
 
-	if (up->port.type == PORT_16C950) {
-		/* Wake up and initialize UART */
-		up->acr = 0;
-		serial_outp(up, UART_LCR, 0xBF);
-		serial_outp(up, UART_EFR, UART_EFR_ECB);
-		serial_outp(up, UART_IER, 0);
-		serial_outp(up, UART_LCR, 0);
-		serial_icr_write(up, UART_CSR, 0); /* Reset the UART */
-		serial_outp(up, UART_LCR, 0xBF);
-		serial_outp(up, UART_EFR, UART_EFR_ECB);
-		serial_outp(up, UART_LCR, 0);
-	}
-
-#ifdef CONFIG_SERIAL_8250_RSA
-	/*
-	 * If this is an RSA port, see if we can kick it up to the
-	 * higher speed clock.
-	 */
-	enable_rsa(up);
-#endif
-
 	/*
 	 * Clear the FIFO buffers and disable them.
 	 * (they will be reenabled in set_termios())
@@ -1974,10 +1046,10 @@
 	/*
 	 * Clear the interrupt registers.
 	 */
-	(void) serial_inp(up, UART_LSR);
-	(void) serial_inp(up, UART_RX);
-	(void) serial_inp(up, UART_IIR);
-	(void) serial_inp(up, UART_MSR);
+	(void) serial_in(up, UART_LSR);
+	(void) serial_in(up, UART_RX);
+	(void) serial_in(up, UART_IIR);
+	(void) serial_in(up, UART_MSR);
 
 	/*
 	 * At this point, there's no way the LSR could still be 0xff;
@@ -1985,29 +1057,12 @@
 	 * here.
 	 */
 	if (!(up->port.flags & UPF_BUGGY_UART) &&
-	    (serial_inp(up, UART_LSR) == 0xff)) {
+	    (serial_in(up, UART_LSR) == 0xff)) {
 		printk(KERN_INFO "ttyS%d: LSR safety check engaged!\n",
 		       serial_index(&up->port));
 		return -ENODEV;
 	}
 
-	/*
-	 * For a XR16C850, we need to set the trigger levels
-	 */
-	if (up->port.type == PORT_16850) {
-		unsigned char fctr;
-
-		serial_outp(up, UART_LCR, 0xbf);
-
-		fctr = serial_inp(up, UART_FCTR) & ~(UART_FCTR_RX|UART_FCTR_TX);
-		serial_outp(up, UART_FCTR, fctr | UART_FCTR_TRGD | UART_FCTR_RX);
-		serial_outp(up, UART_TRG, UART_TRG_96);
-		serial_outp(up, UART_FCTR, fctr | UART_FCTR_TRGD | UART_FCTR_TX);
-		serial_outp(up, UART_TRG, UART_TRG_96);
-
-		serial_outp(up, UART_LCR, 0);
-	}
-
 	if (is_real_interrupt(up->port.irq)) {
 		unsigned char iir1;
 		/*
@@ -2075,13 +1130,9 @@
 	/*
 	 * Now, initialize the UART
 	 */
-	serial_outp(up, UART_LCR, UART_LCR_WLEN8);
+	serial_out(up, UART_LCR, UART_LCR_WLEN8);
 
 	spin_lock_irqsave(&up->port.lock, flags);
-	if (up->port.flags & UPF_FOURPORT) {
-		if (!is_real_interrupt(up->port.irq))
-			up->port.mctrl |= TIOCM_OUT1;
-	} else
 		/*
 		 * Most PC uarts need OUT2 raised to enable interrupts.
 		 */
@@ -2108,10 +1159,10 @@
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
 	 */
-	serial_outp(up, UART_IER, UART_IER_THRI);
+	serial_out(up, UART_IER, UART_IER_THRI);
 	lsr = serial_in(up, UART_LSR);
 	iir = serial_in(up, UART_IIR);
-	serial_outp(up, UART_IER, 0);
+	serial_out(up, UART_IER, 0);
 
 	if (lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT) {
 		if (!(up->bugs & UART_BUG_TXEN)) {
@@ -2131,10 +1182,10 @@
 	 * saved flags to avoid getting false values from polling
 	 * routines or the previous session.
 	 */
-	serial_inp(up, UART_LSR);
-	serial_inp(up, UART_RX);
-	serial_inp(up, UART_IIR);
-	serial_inp(up, UART_MSR);
+	serial_in(up, UART_LSR);
+	serial_in(up, UART_RX);
+	serial_in(up, UART_IIR);
+	serial_in(up, UART_MSR);
 	up->lsr_saved_flags = 0;
 	up->msr_saved_flags = 0;
 
@@ -2144,17 +1195,7 @@
 	 * anyway, so we don't enable them here.
 	 */
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
-	serial_outp(up, UART_IER, up->ier);
-
-	if (up->port.flags & UPF_FOURPORT) {
-		unsigned int icp;
-		/*
-		 * Enable interrupts on the AST Fourport board
-		 */
-		icp = (up->port.iobase & 0xfe0) | 0x01f;
-		outb_p(0x80, icp);
-		(void) inb_p(icp);
-	}
+	serial_out(up, UART_IER, up->ier);
 
 	return 0;
 }
@@ -2168,14 +1209,9 @@
 	 * Disable interrupts from this port
 	 */
 	up->ier = 0;
-	serial_outp(up, UART_IER, 0);
+	serial_out(up, UART_IER, 0);
 
 	spin_lock_irqsave(&up->port.lock, flags);
-	if (up->port.flags & UPF_FOURPORT) {
-		/* reset interrupts on the AST Fourport board */
-		inb((up->port.iobase & 0xfe0) | 0x1f);
-		up->port.mctrl |= TIOCM_OUT1;
-	} else
 		up->port.mctrl &= ~TIOCM_OUT2;
 
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
@@ -2184,16 +1220,9 @@
 	/*
 	 * Disable break condition and FIFOs
 	 */
-	serial_out(up, UART_LCR, serial_inp(up, UART_LCR) & ~UART_LCR_SBC);
+	serial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);
 	serial8250_clear_fifos(up);
 
-#ifdef CONFIG_SERIAL_8250_RSA
-	/*
-	 * Reset the RSA board back to 115kbps compat mode.
-	 */
-	disable_rsa(up);
-#endif
-
 	/*
 	 * Read data port to reset things, and then unlink from
 	 * the IRQ chain.
@@ -2289,7 +1318,11 @@
 	 * have sufficient FIFO entries for the latency of the remote
 	 * UART to respond.  IOW, at least 32 bytes of FIFO.
 	 */
+#ifdef CONFIG_SERIAL_RTL8198_UART1
+	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 16) {
+#else
 	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 32) {
+#endif
 		up->mcr &= ~UART_MCR_AFE;
 		if (termios->c_cflag & CRTSCTS)
 			up->mcr |= UART_MCR_AFE;
@@ -2356,46 +1389,21 @@
 		if (termios->c_cflag & CRTSCTS)
 			efr |= UART_EFR_CTS;
 
-		serial_outp(up, UART_LCR, 0xBF);
-		serial_outp(up, UART_EFR, efr);
-	}
-
-#ifdef CONFIG_ARCH_OMAP
-	/* Workaround to enable 115200 baud on OMAP1510 internal ports */
-	if (cpu_is_omap1510() && is_omap_port(up)) {
-		if (baud == 115200) {
-			quot = 1;
-			serial_out(up, UART_OMAP_OSC_12M_SEL, 1);
-		} else
-			serial_out(up, UART_OMAP_OSC_12M_SEL, 0);
-	}
-#endif
-
-	if (up->capabilities & UART_NATSEMI) {
-		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
-		serial_outp(up, UART_LCR, 0xe0);
-	} else {
-		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+		serial_out(up, UART_LCR, 0xBF);
+		serial_out(up, UART_EFR, efr);
 	}
 
+    serial_out(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	serial_dl_write(up, quot);
 
-	/*
-	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
-	 * is written without DLAB set, this mode will be disabled.
-	 */
-	if (up->port.type == PORT_16750)
-		serial_outp(up, UART_FCR, fcr);
-
-	serial_outp(up, UART_LCR, cval);		/* reset DLAB */
+	serial_out(up, UART_LCR, cval);		/* reset DLAB */
 	up->lcr = cval;					/* Save LCR */
-	if (up->port.type != PORT_16750) {
 		if (fcr & UART_FCR_ENABLE_FIFO) {
 			/* emulated UARTs (Lucent Venus 167x) need two steps */
-			serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-		}
-		serial_outp(up, UART_FCR, fcr);		/* set fcr */
+      serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);
 	}
+    serial_out(up, UART_FCR, fcr);		/* set fcr */
+
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
 	spin_unlock_irqrestore(&up->port.lock, flags);
 	/* Don't rewrite B0 */
@@ -2417,12 +1425,6 @@
 
 static unsigned int serial8250_port_size(struct uart_8250_port *pt)
 {
-	if (pt->port.iotype == UPIO_AU)
-		return 0x100000;
-#ifdef CONFIG_ARCH_OMAP
-	if (is_omap_port(pt))
-		return 0x16 << pt->port.regshift;
-#endif
 	return 8 << pt->port.regshift;
 }
 
@@ -2435,8 +1437,6 @@
 	int ret = 0;
 
 	switch (up->port.iotype) {
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_MEM32:
 	case UPIO_MEM:
 	case UPIO_DWAPB:
@@ -2463,6 +1463,8 @@
 		if (!request_region(up->port.iobase, size, "serial"))
 			ret = -EBUSY;
 		break;
+	case UPIO_I2C:
+		break;
 	}
 	return ret;
 }
@@ -2472,8 +1474,6 @@
 	unsigned int size = serial8250_port_size(up);
 
 	switch (up->port.iotype) {
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_MEM32:
 	case UPIO_MEM:
 	case UPIO_DWAPB:
@@ -2492,38 +1492,7 @@
 	case UPIO_PORT:
 		release_region(up->port.iobase, size);
 		break;
-	}
-}
-
-static int serial8250_request_rsa_resource(struct uart_8250_port *up)
-{
-	unsigned long start = UART_RSA_BASE << up->port.regshift;
-	unsigned int size = 8 << up->port.regshift;
-	int ret = -EINVAL;
-
-	switch (up->port.iotype) {
-	case UPIO_HUB6:
-	case UPIO_PORT:
-		start += up->port.iobase;
-		if (request_region(start, size, "serial-rsa"))
-			ret = 0;
-		else
-			ret = -EBUSY;
-		break;
-	}
-
-	return ret;
-}
-
-static void serial8250_release_rsa_resource(struct uart_8250_port *up)
-{
-	unsigned long offset = UART_RSA_BASE << up->port.regshift;
-	unsigned int size = 8 << up->port.regshift;
-
-	switch (up->port.iotype) {
-	case UPIO_HUB6:
-	case UPIO_PORT:
-		release_region(up->port.iobase + offset, size);
+	case UPIO_I2C:
 		break;
 	}
 }
@@ -2533,29 +1502,18 @@
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
 	serial8250_release_std_resource(up);
-	if (up->port.type == PORT_RSA)
-		serial8250_release_rsa_resource(up);
 }
 
 static int serial8250_request_port(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	int ret = 0;
 
-	ret = serial8250_request_std_resource(up);
-	if (ret == 0 && up->port.type == PORT_RSA) {
-		ret = serial8250_request_rsa_resource(up);
-		if (ret < 0)
-			serial8250_release_std_resource(up);
-	}
-
-	return ret;
+	return serial8250_request_std_resource(up);
 }
 
 static void serial8250_config_port(struct uart_port *port, int flags)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	int probeflags = PROBE_ANY;
 	int ret;
 
 	/*
@@ -2566,20 +1524,9 @@
 	if (ret < 0)
 		return;
 
-	ret = serial8250_request_rsa_resource(up);
-	if (ret < 0)
-		probeflags &= ~PROBE_RSA;
-
 	if (up->port.iotype != up->cur_iotype)
 		set_io_from_upio(port);
 
-	if (flags & UART_CONFIG_TYPE)
-		autoconfig(up, probeflags);
-	if (up->port.type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)
-		autoconfig_irq(up);
-
-	if (up->port.type != PORT_RSA && probeflags & PROBE_RSA)
-		serial8250_release_rsa_resource(up);
 	if (up->port.type == PORT_UNKNOWN)
 		serial8250_release_std_resource(up);
 }
@@ -2773,6 +1720,14 @@
 	int parity = 'n';
 	int flow = 'n';
 
+#ifdef CONFIG_SERIAL_SC16IS7X0
+	extern int __init early_sc16is7x0_init_i2c_and_check( void );
+	if( serial8250_ports[co->index].port.iotype == UPIO_I2C &&
+		early_sc16is7x0_init_i2c_and_check() != 0 )
+	{
+		return -ENODEV;
+	}
+#endif
 	/*
 	 * Check whether an invalid uart number has been specified, and
 	 * if so, search for the first available port that does have
@@ -2902,19 +1857,6 @@
 {
 	struct uart_8250_port *up = &serial8250_ports[line];
 
-	if (up->capabilities & UART_NATSEMI) {
-		unsigned char tmp;
-
-		/* Ensure it's still in high speed mode */
-		serial_outp(up, UART_LCR, 0xE0);
-
-		tmp = serial_in(up, 0x04); /* EXCR2 */
-		tmp &= ~0xB0; /* Disable LOCK, mask out PRESL[01] */
-		tmp |= 0x10;  /* 1.625 divisor for baud_base --> 921600 */
-		serial_outp(up, 0x04, tmp);
-
-		serial_outp(up, UART_LCR, 0);
-	}
 	uart_resume_port(&serial8250_reg, &up->port);
 }
 
@@ -3159,12 +2101,8 @@
 		"%d ports, IRQ sharing %sabled\n", nr_uarts,
 		share_irqs ? "en" : "dis");
 
-#ifdef CONFIG_SPARC
-	ret = sunserial_register_minors(&serial8250_reg, UART_NR);
-#else
 	serial8250_reg.nr = UART_NR;
 	ret = uart_register_driver(&serial8250_reg);
-#endif
 	if (ret)
 		goto out;
 
@@ -3189,11 +2127,7 @@
 put_dev:
 	platform_device_put(serial8250_isa_devs);
 unreg_uart_drv:
-#ifdef CONFIG_SPARC
-	sunserial_unregister_minors(&serial8250_reg, UART_NR);
-#else
 	uart_unregister_driver(&serial8250_reg);
-#endif
 out:
 	return ret;
 }
@@ -3212,11 +2146,7 @@
 	platform_driver_unregister(&serial8250_isa_driver);
 	platform_device_unregister(isa_dev);
 
-#ifdef CONFIG_SPARC
-	sunserial_unregister_minors(&serial8250_reg, UART_NR);
-#else
 	uart_unregister_driver(&serial8250_reg);
-#endif
 }
 
 module_init(serial8250_init);
@@ -3235,8 +2165,4 @@
 module_param(nr_uarts, uint, 0644);
 MODULE_PARM_DESC(nr_uarts, "Maximum number of UARTs supported. (1-" __MODULE_STRING(CONFIG_SERIAL_8250_NR_UARTS) ")");
 
-#ifdef CONFIG_SERIAL_8250_RSA
-module_param_array(probe_rsa, ulong, &probe_rsa_count, 0444);
-MODULE_PARM_DESC(probe_rsa, "Probe I/O ports for RSA");
-#endif
 MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/serial/8250.h linux-2.6.30.9-rsdk/drivers/serial/8250.h
--- linux-2.6.30.9/drivers/serial/8250.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/serial/8250.h	2011-12-05 15:50:14.000000000 +0000
@@ -60,20 +60,4 @@
 #define SERIAL8250_SHARE_IRQS 0
 #endif
 
-#if defined(__alpha__) && !defined(CONFIG_PCI)
-/*
- * Digital did something really horribly wrong with the OUT1 and OUT2
- * lines on at least some ALPHA's.  The failure mode is that if either
- * is cleared, the machine locks up with endless interrupts.
- */
-#define ALPHA_KLUDGE_MCR  (UART_MCR_OUT2 | UART_MCR_OUT1)
-#elif defined(CONFIG_SBC8560)
-/*
- * WindRiver did something similarly broken on their SBC8560 board. The
- * UART tristates its IRQ output while OUT2 is clear, but they pulled
- * the interrupt line _up_ instead of down, so if we register the IRQ
- * while the UART is in that state, we die in an IRQ storm. */
-#define ALPHA_KLUDGE_MCR (UART_MCR_OUT2)
-#else
 #define ALPHA_KLUDGE_MCR 0
-#endif
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/serial/Kconfig linux-2.6.30.9-rsdk/drivers/serial/Kconfig
--- linux-2.6.30.9/drivers/serial/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/serial/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -1,9 +1,10 @@
 #
 # Serial device configuration
 #
+# $Id: Kconfig,v 1.11 2004/03/11 18:08:04 lethal Exp $
+#
 
 menu "Serial drivers"
-	depends on HAS_IOMEM
 
 #
 # The new 8250/16550 serial drivers
@@ -59,61 +60,6 @@
 	  kernel will automatically use the first serial line, /dev/ttyS0, as
 	  system console.
 
-	  You can set that using a kernel command line option such as
-	  "console=uart8250,io,0x3f8,9600n8"
-	  "console=uart8250,mmio,0xff5e0000,115200n8".
-	  and it will switch to normal serial console when the corresponding 
-	  port is ready.
-	  "earlycon=uart8250,io,0x3f8,9600n8"
-	  "earlycon=uart8250,mmio,0xff5e0000,115200n8".
-	  it will not only setup early console.
-
-	  If unsure, say N.
-
-config FIX_EARLYCON_MEM
-	bool
-	depends on X86
-	default y
-
-config SERIAL_8250_GSC
-	tristate
-	depends on SERIAL_8250 && GSC
-	default SERIAL_8250
-
-config SERIAL_8250_PCI
-	tristate "8250/16550 PCI device support" if EMBEDDED
-	depends on SERIAL_8250 && PCI
-	default SERIAL_8250
-	help
-	  This builds standard PCI serial support. You may be able to
-	  disable this feature if you only need legacy serial support.
-	  Saves about 9K.
-
-config SERIAL_8250_PNP
-	tristate "8250/16550 PNP device support" if EMBEDDED
-	depends on SERIAL_8250 && PNP
-	default SERIAL_8250
-	help
-	  This builds standard PNP serial support. You may be able to
-	  disable this feature if you only need legacy serial support.
-
-config SERIAL_8250_HP300
-	tristate
-	depends on SERIAL_8250 && HP300
-	default SERIAL_8250
-
-config SERIAL_8250_CS
-	tristate "8250/16550 PCMCIA device support"
-	depends on PCMCIA && SERIAL_8250
-	---help---
-	  Say Y here to enable support for 16-bit PCMCIA serial devices,
-	  including serial port cards, modems, and the modem functions of
-	  multi-function Ethernet/modem cards. (PCMCIA- or PC-cards are
-	  credit-card size devices often used with laptops.)
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called serial_cs.
-
 	  If unsure, say N.
 
 config SERIAL_8250_NR_UARTS
@@ -163,58 +109,6 @@
 	  say N here to save some memory. You can also say Y if you have an
 	  "intelligent" multiport card such as Cyclades, Digiboards, etc.
 
-#
-# Multi-port serial cards
-#
-
-config SERIAL_8250_FOURPORT
-	tristate "Support Fourport cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have an AST FourPort serial board.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_fourport.
-
-config SERIAL_8250_ACCENT
-	tristate "Support Accent cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have an Accent Async serial board.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_accent.
-
-config SERIAL_8250_BOCA
-	tristate "Support Boca cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have a Boca serial board.  Please read the Boca
-	  mini-HOWTO, available from <http://www.tldp.org/docs.html#howto>
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_boca.
-
-config SERIAL_8250_EXAR_ST16C554
-	tristate "Support Exar ST16C554/554D Quad UART"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  The Uplogix Envoy TU301 uses this Exar Quad UART.  If you are
-	  tinkering with your Envoy TU301, or have a machine with this UART,
-	  say Y here.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_exar_st16c554.
-
-config SERIAL_8250_HUB6
-	tristate "Support Hub6 cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have a HUB6 serial board.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_hub6.
-
 config SERIAL_8250_SHARE_IRQ
 	bool "Support for sharing serial interrupts"
 	depends on SERIAL_8250_EXTENDED
@@ -223,1214 +117,48 @@
 	  serial ports on the same board to share a single IRQ. To enable
 	  support for this in the serial driver, say Y here.
 
-config SERIAL_8250_DETECT_IRQ
-	bool "Autodetect IRQ on standard ports (unsafe)"
-	depends on SERIAL_8250_EXTENDED
-	help
-	  Say Y here if you want the kernel to try to guess which IRQ
-	  to use for your serial port.
-
-	  This is considered unsafe; it is far better to configure the IRQ in
-	  a boot script using the setserial command.
-
-	  If unsure, say N.
-
-config SERIAL_8250_RSA
-	bool "Support RSA serial ports"
-	depends on SERIAL_8250_EXTENDED
-	help
-	  ::: To be written :::
-
-config SERIAL_8250_MCA
-	tristate "Support 8250-type ports on MCA buses"
-	depends on SERIAL_8250 != n && MCA
-	help
-	  Say Y here if you have a MCA serial ports.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_mca.
-
-config SERIAL_8250_ACORN
-	tristate "Acorn expansion card serial port support"
-	depends on ARCH_ACORN && SERIAL_8250
-	help
-	  If you have an Atomwide Serial card or Serial Port card for an Acorn
-	  system, say Y to this option.  The driver can handle 1, 2, or 3 port
-	  cards.  If unsure, say N.
-
-config SERIAL_8250_AU1X00
-	bool "Au1x00 serial port support"
-	depends on SERIAL_8250 != n && SOC_AU1X00
-	help
-	  If you have an Au1x00 SOC based board and want to use the serial port,
-	  say Y to this option. The driver can handle up to 4 serial ports,
-	  depending on the SOC. If unsure, say N.
-
-config SERIAL_8250_RM9K
-	bool "Support for MIPS RM9xxx integrated serial port"
-	depends on SERIAL_8250 != n && SERIAL_RM9000
-	select SERIAL_8250_SHARE_IRQ
-	help
-	  Selecting this option will add support for the integrated serial
-	  port hardware found on MIPS RM9122 and similar processors.
-	  If unsure, say N.
-
-comment "Non-8250 serial port support"
-
-config SERIAL_AMBA_PL010
-	tristate "ARM AMBA PL010 serial port support"
-	depends on ARM_AMBA && (BROKEN || !ARCH_VERSATILE)
-	select SERIAL_CORE
-	help
-	  This selects the ARM(R) AMBA(R) PrimeCell PL010 UART.  If you have
-	  an Integrator/AP or Integrator/PP2 platform, or if you have a
-	  Cirrus Logic EP93xx CPU, say Y or M here.
-
-	  If unsure, say N.
-
-config SERIAL_AMBA_PL010_CONSOLE
-	bool "Support for console on AMBA serial port"
-	depends on SERIAL_AMBA_PL010=y
-	select SERIAL_CORE_CONSOLE
-	---help---
-	  Say Y here if you wish to use an AMBA PrimeCell UART as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyAM0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_AMBA_PL011
-	tristate "ARM AMBA PL011 serial port support"
-	depends on ARM_AMBA
-	select SERIAL_CORE
-	help
-	  This selects the ARM(R) AMBA(R) PrimeCell PL011 UART.  If you have
-	  an Integrator/PP2, Integrator/CP or Versatile platform, say Y or M
-	  here.
-
-	  If unsure, say N.
-
-config SERIAL_AMBA_PL011_CONSOLE
-	bool "Support for console on AMBA serial port"
-	depends on SERIAL_AMBA_PL011=y
-	select SERIAL_CORE_CONSOLE
-	---help---
-	  Say Y here if you wish to use an AMBA PrimeCell UART as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyAMA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SB1250_DUART
-	tristate "BCM1xxx on-chip DUART serial support"
-	depends on SIBYTE_SB1xxx_SOC=y
-	select SERIAL_CORE
-	default y
-	---help---
-	  Support for the asynchronous serial interface (DUART) included in
-	  the BCM1250 and derived System-On-a-Chip (SOC) devices.  Note that
-	  the letter D in DUART stands for "dual", which is how the device
-	  is implemented.  Depending on the SOC configuration there may be
-	  one or more DUARTs available of which all are handled.
-
-	  If unsure, say Y.  To compile this driver as a module, choose M here:
-	  the module will be called sb1250-duart.
-
-config SERIAL_SB1250_DUART_CONSOLE
-	bool "Support for console on a BCM1xxx DUART serial port"
-	depends on SERIAL_SB1250_DUART=y
-	select SERIAL_CORE_CONSOLE
-	default y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode).
-
-	  If unsure, say Y.
-
-config SERIAL_ATMEL
-	bool "AT91 / AT32 on-chip serial port support"
-	depends on (ARM && ARCH_AT91) || AVR32
-	select SERIAL_CORE
-	help
-	  This enables the driver for the on-chip UARTs of the Atmel
-	  AT91 and AT32 processors.
-
-config SERIAL_ATMEL_CONSOLE
-	bool "Support for console on AT91 / AT32 serial port"
-	depends on SERIAL_ATMEL=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use an on-chip UART on a Atmel
-	  AT91 or AT32 processor as the system console (the system
-	  console is the device which receives all kernel messages and
-	  warnings and which allows logins in single user mode).
-
-config SERIAL_ATMEL_PDC
-	bool "Support DMA transfers on AT91 / AT32 serial port"
-	depends on SERIAL_ATMEL
-	default y
-	help
-	  Say Y here if you wish to use the PDC to do DMA transfers to
-	  and from the Atmel AT91 / AT32 serial port. In order to
-	  actually use DMA transfers, make sure that the use_dma_tx
-	  and use_dma_rx members in the atmel_uart_data struct is set
-	  appropriately for each port.
-
-	  Note that break and error handling currently doesn't work
-	  properly when DMA is enabled. Make sure that ports where
-	  this matters don't use DMA.
-
-config SERIAL_ATMEL_TTYAT
-	bool "Install as device ttyATn instead of ttySn"
-	depends on SERIAL_ATMEL=y
-	help
-	  Say Y here if you wish to have the internal AT91 / AT32 UARTs
-	  appear as /dev/ttyATn (major 204, minor starting at 154)
-	  instead of the normal /dev/ttySn (major 4, minor starting at
-	  64). This is necessary if you also want other UARTs, such as
-	  external 8250/16C550 compatible UARTs.
-	  The ttySn nodes are legally reserved for the 8250 serial driver
-	  but are often misused by other serial drivers.
-
-	  To use this, you should create suitable ttyATn device nodes in
-	  /dev/, and pass "console=ttyATn" to the kernel.
-
-	  Say Y if you have an external 8250/16C550 UART.  If unsure, say N.
-
-config SERIAL_KS8695
-	bool "Micrel KS8695 (Centaur) serial port support"
-	depends on ARCH_KS8695
-	select SERIAL_CORE
-	help
-	  This selects the Micrel Centaur KS8695 UART.  Say Y here.
-
-config SERIAL_KS8695_CONSOLE
-	bool "Support for console on KS8695 (Centaur) serial port"
-	depends on SERIAL_KS8695=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use a KS8695 (Centaur) UART as the
-	  system console (the system console is the device which
-	  receives all kernel messages and warnings and which allows
-	  logins in single user mode).
-
-config SERIAL_CLPS711X
-	tristate "CLPS711X serial port support"
-	depends on ARM && ARCH_CLPS711X
-	select SERIAL_CORE
-	help
-	  ::: To be written :::
-
-config SERIAL_CLPS711X_CONSOLE
-	bool "Support for console on CLPS711X serial port"
-	depends on SERIAL_CLPS711X=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyCL1". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SAMSUNG
-	tristate "Samsung SoC serial support"
-	depends on ARM && PLAT_S3C
-	select SERIAL_CORE
-	help
-	  Support for the on-chip UARTs on the Samsung S3C24XX series CPUs,
-	  providing /dev/ttySAC0, 1 and 2 (note, some machines may not
-	  provide all of these ports, depending on how the serial port
-	  pins are configured.
-
-config SERIAL_SAMSUNG_UARTS
-	int
-	depends on ARM && PLAT_S3C
-	default 2 if ARCH_S3C2400
-	default 4 if ARCH_S3C64XX || CPU_S3C2443
-	default 3
-	help
-	  Select the number of available UART ports for the Samsung S3C
-	  serial driver
-	
-config SERIAL_SAMSUNG_DEBUG
-	bool "Samsung SoC serial debug"
-	depends on SERIAL_SAMSUNG && DEBUG_LL
-	help
-	  Add support for debugging the serial driver. Since this is
-	  generally being used as a console, we use our own output
-	  routines that go via the low-level debug printascii()
-	  function.
-
-config SERIAL_SAMSUNG_CONSOLE
-	bool "Support for console on Samsung SoC serial port"
-	depends on SERIAL_SAMSUNG=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Allow selection of the S3C24XX on-board serial ports for use as
-	  an virtual console.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySACx". (Try "man bootparam" or see the documentation of
-	  your boot loader about how to pass options to the kernel at
-	  boot time.)
-
-config SERIAL_S3C2400
-	tristate "Samsung S3C2410 Serial port support"
-	depends on ARM && SERIAL_SAMSUNG && CPU_S3C2400
-	default y if CPU_S3C2400
-	help
-	  Serial port support for the Samsung S3C2400 SoC
-
-config SERIAL_S3C2410
-	tristate "Samsung S3C2410 Serial port support"
-	depends on SERIAL_SAMSUNG && CPU_S3C2410
-	default y if CPU_S3C2410
-	help
-	  Serial port support for the Samsung S3C2410 SoC
-
-config SERIAL_S3C2412
-	tristate "Samsung S3C2412/S3C2413 Serial port support"
-	depends on SERIAL_SAMSUNG && CPU_S3C2412
-	default y if CPU_S3C2412
-	help
-	  Serial port support for the Samsung S3C2412 and S3C2413 SoC
-
-config SERIAL_S3C2440
-	tristate "Samsung S3C2440/S3C2442 Serial port support"
-	depends on SERIAL_SAMSUNG && (CPU_S3C2440 || CPU_S3C2442)
-	default y if CPU_S3C2440
-	default y if CPU_S3C2442
-	help
-	  Serial port support for the Samsung S3C2440 and S3C2442 SoC
-
-config SERIAL_S3C24A0
-	tristate "Samsung S3C24A0 Serial port support"
-	depends on SERIAL_SAMSUNG && CPU_S3C24A0
-	default y if CPU_S3C24A0
-	help
-	  Serial port support for the Samsung S3C24A0 SoC
-
-config SERIAL_S3C6400
-	tristate "Samsung S3C6400/S3C6410 Serial port support"
-	depends on SERIAL_SAMSUNG && (CPU_S3C600 || CPU_S3C6410)
-	default y
-	help
-	  Serial port support for the Samsung S3C6400 and S3C6410
-	  SoCs
-
-config SERIAL_MAX3100
-	tristate "MAX3100 support"
-	depends on SPI
-	select SERIAL_CORE
-	help
-	  MAX3100 chip support
-
-config SERIAL_DZ
-	bool "DECstation DZ serial driver"
-	depends on MACH_DECSTATION && 32BIT
-	select SERIAL_CORE
-	default y
-	---help---
-	  DZ11-family serial controllers for DECstations and VAXstations,
-	  including the DC7085, M7814, and M7819.
-
-config SERIAL_DZ_CONSOLE
-	bool "Support console on DECstation DZ serial driver"
-	depends on SERIAL_DZ=y
-	select SERIAL_CORE_CONSOLE
-	default y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode).
-
-	  Note that the firmware uses ttyS3 as the serial console on
-	  DECstations that use this driver.
-
-	  If unsure, say Y.
-
-config SERIAL_ZS
-	tristate "DECstation Z85C30 serial support"
-	depends on MACH_DECSTATION
-	select SERIAL_CORE
-	default y
-	---help---
-	  Support for the Zilog 85C350 serial communications controller used
-	  for serial ports in newer DECstation systems.  These include the
-	  DECsystem 5900 and all models of the DECstation and DECsystem 5000
-	  systems except from model 200.
-
-	  If unsure, say Y.  To compile this driver as a module, choose M here:
-	  the module will be called zs.
-
-config SERIAL_ZS_CONSOLE
-	bool "Support for console on a DECstation Z85C30 serial port"
-	depends on SERIAL_ZS=y
-	select SERIAL_CORE_CONSOLE
-	default y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode).
-
-	  Note that the firmware uses ttyS1 as the serial console on the
-	  Maxine and ttyS3 on the others using this driver.
-
-	  If unsure, say Y.
-
-config SERIAL_21285
-	tristate "DC21285 serial port support"
-	depends on ARM && FOOTBRIDGE
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a 21285 (Footbridge) StrongARM(R)/
-	  PCI bridge you can enable its onboard serial port by enabling this
-	  option.
-
-config SERIAL_21285_CONSOLE
-	bool "Console on DC21285 serial port"
-	depends on SERIAL_21285=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the 21285 footbridge you can
-	  make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyFB". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_MPSC
-	bool "Marvell MPSC serial port support"
-	depends on PPC32 && MV64X60
-	select SERIAL_CORE
-	help
-	  Say Y here if you want to use the Marvell MPSC serial controller.
-
-config SERIAL_MPSC_CONSOLE
-	bool "Support for console on Marvell MPSC serial port"
-	depends on SERIAL_MPSC
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you want to support a serial console on a Marvell MPSC.
-
-config SERIAL_PXA
-	bool "PXA serial port support"
-	depends on ARCH_PXA || ARCH_MMP
-	select SERIAL_CORE
-	help
-	  If you have a machine based on an Intel XScale PXA2xx CPU you
-	  can enable its onboard serial ports by enabling this option.
-
-config SERIAL_PXA_CONSOLE
-	bool "Console on PXA serial port"
-	depends on SERIAL_PXA
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the Intel XScale PXA
-	  CPU you can make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SA1100
-	bool "SA1100 serial port support"
-	depends on ARM && ARCH_SA1100
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a SA1100/SA1110 StrongARM(R) CPU you
-	  can enable its onboard serial port by enabling this option.
-	  Please read <file:Documentation/arm/SA1100/serial_UART> for further
-	  info.
-
-config SERIAL_SA1100_CONSOLE
-	bool "Console on SA1100 serial port"
-	depends on SERIAL_SA1100
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the SA1100/SA1110 StrongARM
-	  CPU you can make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_BFIN
-	tristate "Blackfin serial port support"
-	depends on BLACKFIN
-	select SERIAL_CORE
-	select SERIAL_BFIN_UART0 if (BF531 || BF532 || BF533 || BF561)
-	help
-	  Add support for the built-in UARTs on the Blackfin.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bfin_5xx.
-
-config SERIAL_BFIN_CONSOLE
-	bool "Console on Blackfin serial port"
-	depends on SERIAL_BFIN=y
-	select SERIAL_CORE_CONSOLE
-
-choice
-	prompt "UART Mode"
-	depends on SERIAL_BFIN
-	default SERIAL_BFIN_DMA
-	help
-	  This driver supports the built-in serial ports of the Blackfin family
-	  of CPUs
-
-config SERIAL_BFIN_DMA
-	bool "DMA mode"
-	depends on !DMA_UNCACHED_NONE && KGDB_SERIAL_CONSOLE=n
-	help
-	  This driver works under DMA mode. If this option is selected, the
-	  blackfin simple dma driver is also enabled.
-
-config SERIAL_BFIN_PIO
-	bool "PIO mode"
-	help
-	  This driver works under PIO mode.
-
-endchoice
-
-config SERIAL_BFIN_UART0
-	bool "Enable UART0"
-	depends on SERIAL_BFIN
-	help
-	  Enable UART0
-
-config BFIN_UART0_CTSRTS
-	bool "Enable UART0 hardware flow control"
-	depends on SERIAL_BFIN_UART0
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART0_CTS_PIN
-	int "UART0 CTS pin"
-	depends on BFIN_UART0_CTSRTS && !BF548
-	default 23
-	help
-	  The default pin is GPIO_GP7.
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART0_RTS_PIN
-	int "UART0 RTS pin"
-	depends on BFIN_UART0_CTSRTS && !BF548
-	default 22
-	help
-	  The default pin is GPIO_GP6.
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_BFIN_UART1
-	bool "Enable UART1"
-	depends on SERIAL_BFIN && (!BF531 && !BF532 && !BF533 && !BF561)
-	help
-	  Enable UART1
-
-config BFIN_UART1_CTSRTS
-	bool "Enable UART1 hardware flow control"
-	depends on SERIAL_BFIN_UART1
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART1_CTS_PIN
-	int "UART1 CTS pin"
-	depends on BFIN_UART1_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART1_RTS_PIN
-	int "UART1 RTS pin"
-	depends on BFIN_UART1_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_BFIN_UART2
-	bool "Enable UART2"
-	depends on SERIAL_BFIN && (BF54x || BF538 || BF539)
-	help
-	  Enable UART2
-
-config BFIN_UART2_CTSRTS
-	bool "Enable UART2 hardware flow control"
-	depends on SERIAL_BFIN_UART2
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART2_CTS_PIN
-	int "UART2 CTS pin"
-	depends on BFIN_UART2_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART2_RTS_PIN
-	int "UART2 RTS pin"
-	depends on BFIN_UART2_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_BFIN_UART3
-	bool "Enable UART3"
-	depends on SERIAL_BFIN && (BF54x)
-	help
-	  Enable UART3
-
-config BFIN_UART3_CTSRTS
-	bool "Enable UART3 hardware flow control"
-	depends on SERIAL_BFIN_UART3
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART3_CTS_PIN
-	int "UART3 CTS pin"
-	depends on BFIN_UART3_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART3_RTS_PIN
-	int "UART3 RTS pin"
-	depends on BFIN_UART3_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_IMX
-	bool "IMX serial port support"
-	depends on ARM && (ARCH_IMX || ARCH_MXC)
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a Motorola IMX CPU you
-	  can enable its onboard serial port by enabling this option.
-
-config SERIAL_IMX_CONSOLE
-	bool "Console on IMX serial port"
-	depends on SERIAL_IMX
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the Motorola IMX
-	  CPU you can make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_UARTLITE
-	tristate "Xilinx uartlite serial port support"
-	depends on PPC32 || MICROBLAZE
-	select SERIAL_CORE
-	help
-	  Say Y here if you want to use the Xilinx uartlite serial controller.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called uartlite.ko.
-
-config SERIAL_UARTLITE_CONSOLE
-	bool "Support for console on Xilinx uartlite serial port"
-	depends on SERIAL_UARTLITE=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use a Xilinx uartlite as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-config SERIAL_SUNCORE
-	bool
-	depends on SPARC
-	select SERIAL_CORE
-	select SERIAL_CORE_CONSOLE
-	default y
-
-config SERIAL_SUNZILOG
-	tristate "Sun Zilog8530 serial support"
-	depends on SPARC
-	help
-	  This driver supports the Zilog8530 serial ports found on many Sparc
-	  systems.  Say Y or M if you want to be able to these serial ports.
-
-config SERIAL_SUNZILOG_CONSOLE
-	bool "Console on Sun Zilog8530 serial port"
-	depends on SERIAL_SUNZILOG=y
-	help
-	  If you would like to be able to use the Zilog8530 serial port
-	  on your Sparc system as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_SUNSU
-	tristate "Sun SU serial support"
-	depends on SPARC && PCI
-	help
-	  This driver supports the 8250 serial ports that run the keyboard and
-	  mouse on (PCI) UltraSPARC systems.  Say Y or M if you want to be able
-	  to these serial ports.
-
-config SERIAL_SUNSU_CONSOLE
-	bool "Console on Sun SU serial port"
-	depends on SERIAL_SUNSU=y
-	help
-	  If you would like to be able to use the SU serial port
-	  on your Sparc system as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_MUX
-	tristate "Serial MUX support"
-	depends on GSC
-	select SERIAL_CORE
-	default y
-	---help---
-	  Saying Y here will enable the hardware MUX serial driver for
-	  the Nova, K class systems and D class with a 'remote control card'.
-	  The hardware MUX is not 8250/16550 compatible therefore the
-	  /dev/ttyB0 device is shared between the Serial MUX and the PDC
-	  software console. The following steps need to be completed to use
-	  the Serial MUX:
-
-	    1. create the device entry (mknod /dev/ttyB0 c 11 0)
-	    2. Edit the /etc/inittab to start a getty listening on /dev/ttyB0
-	    3. Add device ttyB0 to /etc/securetty (if you want to log on as
-		 root on this console.)
-	    4. Change the kernel command console parameter to: console=ttyB0
-
-config SERIAL_MUX_CONSOLE
-	bool "Support for console on serial MUX"
-	depends on SERIAL_MUX=y
-	select SERIAL_CORE_CONSOLE
-	default y
-
-config PDC_CONSOLE
-	bool "PDC software console support"
-	depends on PARISC && !SERIAL_MUX && VT
-	default n
-	help
-	  Saying Y here will enable the software based PDC console to be 
-	  used as the system console.  This is useful for machines in 
-	  which the hardware based console has not been written yet.  The
-	  following steps must be competed to use the PDC console:
-
-	    1. create the device entry (mknod /dev/ttyB0 c 11 0)
-	    2. Edit the /etc/inittab to start a getty listening on /dev/ttyB0
-	    3. Add device ttyB0 to /etc/securetty (if you want to log on as
-		 root on this console.)
-	    4. Change the kernel command console parameter to: console=ttyB0
-
-config SERIAL_SUNSAB
-	tristate "Sun Siemens SAB82532 serial support"
-	depends on SPARC && PCI
-	help
-	  This driver supports the Siemens SAB82532 DUSCC serial ports on newer
-	  (PCI) UltraSPARC systems.  Say Y or M if you want to be able to these
-	  serial ports.
-
-config SERIAL_SUNSAB_CONSOLE
-	bool "Console on Sun Siemens SAB82532 serial port"
-	depends on SERIAL_SUNSAB=y
-	help
-	  If you would like to be able to use the SAB82532 serial port
-	  on your Sparc system as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_SUNHV
-	bool "Sun4v Hypervisor Console support"
-	depends on SPARC64
-	help
-	  This driver supports the console device found on SUN4V Sparc
-	  systems.  Say Y if you want to be able to use this device.
-
-config SERIAL_IP22_ZILOG
-	tristate "SGI Zilog8530 serial support"
-	depends on SGI_HAS_ZILOG
-	select SERIAL_CORE
-	help
-	  This driver supports the Zilog8530 serial ports found on SGI
-	  systems.  Say Y or M if you want to be able to these serial ports.
-
-config SERIAL_IP22_ZILOG_CONSOLE
-	bool "Console on SGI Zilog8530 serial port"
-	depends on SERIAL_IP22_ZILOG=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_SH_SCI
-	tristate "SuperH SCI(F) serial port support"
-	depends on SUPERH || H8300
-	select SERIAL_CORE
-
-config SERIAL_SH_SCI_NR_UARTS
-	int "Maximum number of SCI(F) serial ports"
-	depends on SERIAL_SH_SCI
-	default "2"
-
-config SERIAL_SH_SCI_CONSOLE
-	bool "Support for console on SuperH SCI(F)"
-	depends on SERIAL_SH_SCI=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_PNX8XXX
-	bool "Enable PNX8XXX SoCs' UART Support"
-	depends on MIPS && (SOC_PNX8550 || SOC_PNX833X)
-	select SERIAL_CORE
-	help
-	  If you have a MIPS-based Philips SoC such as PNX8550 or PNX8330
-	  and you want to use serial ports, say Y.  Otherwise, say N.
-
-config SERIAL_PNX8XXX_CONSOLE
-	bool "Enable PNX8XX0 serial console"
-	depends on SERIAL_PNX8XXX
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have a MIPS-based Philips SoC such as PNX8550 or PNX8330
-	  and you want to use serial console, say Y. Otherwise, say N.
-
 config SERIAL_CORE
 	tristate
 
 config SERIAL_CORE_CONSOLE
 	bool
 
-config CONSOLE_POLL
-	bool
-
-config SERIAL_68328
-	bool "68328 serial support"
-	depends on M68328 || M68EZ328 || M68VZ328
-	help
-	  This driver supports the built-in serial port of the Motorola 68328
-	  (standard, EZ and VZ varieties).
-
-config SERIAL_68328_RTS_CTS
-	bool "Support RTS/CTS on 68328 serial port"
-	depends on SERIAL_68328
-
-config SERIAL_MCF
-	bool "Coldfire serial support"
-	depends on COLDFIRE
-	select SERIAL_CORE
-	help
-	  This serial driver supports the Freescale Coldfire serial ports.
-
-config SERIAL_MCF_BAUDRATE
-	int "Default baudrate for Coldfire serial ports"
-	depends on SERIAL_MCF
-	default 19200
-	help
-	  This setting lets you define what the default baudrate is for the
-	  ColdFire serial ports. The usual default varies from board to board,
-	  and this setting is a way of catering for that.
-
-config SERIAL_MCF_CONSOLE
-	bool "Coldfire serial console support"
-	depends on SERIAL_MCF
-	select SERIAL_CORE_CONSOLE
-	help
-	  Enable a ColdFire internal serial port to be the system console.
-
-config SERIAL_68360_SMC
-	bool "68360 SMC uart support"
-	depends on M68360
-	help
-	  This driver supports the SMC serial ports of the Motorola 68360 CPU.
-
-config SERIAL_68360_SCC
-	bool "68360 SCC uart support"
-	depends on M68360
-	help
-	  This driver supports the SCC serial ports of the Motorola 68360 CPU.
-
-config SERIAL_68360
-	bool
-	depends on SERIAL_68360_SMC || SERIAL_68360_SCC
-	default y
-
-config SERIAL_PMACZILOG
-	tristate "PowerMac z85c30 ESCC support"
-	depends on PPC_OF && PPC_PMAC
-	select SERIAL_CORE
-	help
-	  This driver supports the Zilog z85C30 serial ports found on
-	  PowerMac machines.
-	  Say Y or M if you want to be able to these serial ports.
-
-config SERIAL_PMACZILOG_TTYS
-	bool "Use ttySn device nodes for Zilog z85c30"
-	depends on SERIAL_PMACZILOG
-	help
-	  The pmac_zilog driver for the z85C30 chip on many powermacs
-	  historically used the device numbers for /dev/ttySn.  The
-	  8250 serial port driver also uses these numbers, which means
-	  the two drivers being unable to coexist; you could not use
-	  both z85C30 and 8250 type ports at the same time.
-
-	  If this option is not selected, the pmac_zilog driver will
-	  use the device numbers allocated for /dev/ttyPZn.  This allows
-	  the pmac_zilog and 8250 drivers to co-exist, but may cause
-	  existing userspace setups to break.  Programs that need to
-	  access the built-in serial ports on powermacs will need to
-	  be reconfigured to use /dev/ttyPZn instead of /dev/ttySn.
-
-	  If you enable this option, any z85c30 ports in the system will
-	  be registered as ttyS0 onwards as in the past, and you will be
-	  unable to use the 8250 module for PCMCIA or other 16C550-style
-	  UARTs.
-
-	  Say N unless you need the z85c30 ports on your powermac
-	  to appear as /dev/ttySn.
-
-config SERIAL_PMACZILOG_CONSOLE
-	bool "Console on PowerMac z85c30 serial port"
-	depends on SERIAL_PMACZILOG=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you would like to be able to use the z85c30 serial port
-	  on your PowerMac as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_LH7A40X
-	tristate "Sharp LH7A40X embedded UART support"
-	depends on ARM && ARCH_LH7A40X
-	select SERIAL_CORE
-	help
-	  This enables support for the three on-board UARTs of the
-	  Sharp LH7A40X series CPUs.  Choose Y or M.
-
-config SERIAL_LH7A40X_CONSOLE
-	bool "Support for console on Sharp LH7A40X serial port"
-	depends on SERIAL_LH7A40X=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use one of the serial ports as the
-	  system console--the system console is the device which
-	  receives all kernel messages and warnings and which allows
-	  logins in single user mode.
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the default system console, but
-	  you can alter that using a kernel command line, for example
-	  "console=ttyAM1".
-
-config SERIAL_CPM
-	tristate "CPM SCC/SMC serial port support"
-	depends on CPM2 || 8xx
-	select SERIAL_CORE
-	help
-	  This driver supports the SCC and SMC serial ports on Motorola 
-	  embedded PowerPC that contain a CPM1 (8xx) or CPM2 (8xxx)
-
-config SERIAL_CPM_CONSOLE
-	bool "Support for console on CPM SCC/SMC serial port"
-	depends on SERIAL_CPM=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use a SCC or SMC CPM UART as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyCPM0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SGI_L1_CONSOLE
-	bool "SGI Altix L1 serial console support"
-	depends on IA64_GENERIC || IA64_SGI_SN2
-	select SERIAL_CORE
-	select SERIAL_CORE_CONSOLE
-	help
-		If you have an SGI Altix and you would like to use the system
-		controller serial port as your console (you want this!),
-		say Y.  Otherwise, say N.
-
-config SERIAL_MPC52xx
-	tristate "Freescale MPC52xx/MPC512x family PSC serial support"
-	depends on PPC_MPC52xx || PPC_MPC512x
-	select SERIAL_CORE
-	help
-	  This driver supports MPC52xx and MPC512x PSC serial ports. If you would
-	  like to use them, you must answer Y or M to this option. Note that
-	  for use as console, it must be included in kernel and not as a
-	  module.
-
-config SERIAL_MPC52xx_CONSOLE
-	bool "Console on a Freescale MPC52xx/MPC512x family PSC serial port"
-	depends on SERIAL_MPC52xx=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Select this options if you'd like to use one of the PSC serial port
-	  of the Freescale MPC52xx family as a console.
-
-config SERIAL_MPC52xx_CONSOLE_BAUD
-	int "Freescale MPC52xx/MPC512x family PSC serial port baud"
-	depends on SERIAL_MPC52xx_CONSOLE=y
-	default "9600"
-	help
-	  Select the MPC52xx console baud rate.
-	  This value is only used if the bootloader doesn't pass in the
-	  console baudrate
-
-config SERIAL_ICOM
-	tristate "IBM Multiport Serial Adapter"
-	depends on PCI && (PPC_ISERIES || PPC_PSERIES)
-	select SERIAL_CORE
-	select FW_LOADER
-	help
-	  This driver is for a family of multiport serial adapters
-	  including 2 port RVX, 2 port internal modem, 4 port internal
-	  modem and a split 1 port RVX and 1 port internal modem.
-
-	  This driver can also be built as a module.  If so, the module
-	  will be called icom.
-
-config SERIAL_M32R_SIO
-	bool "M32R SIO I/F"
-	depends on M32R
-	default y
-	select SERIAL_CORE
-	help
-	  Say Y here if you want to use the M32R serial controller.
-
-config SERIAL_M32R_SIO_CONSOLE
-	bool "use SIO console"
-	depends on SERIAL_M32R_SIO=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you want to support a serial console.
-
-	  If you use an M3T-M32700UT or an OPSPUT platform,
-	  please say also y for SERIAL_M32R_PLDSIO.
-
-config SERIAL_M32R_PLDSIO
-	bool "M32R SIO I/F on a PLD"
-	depends on SERIAL_M32R_SIO=y && (PLAT_OPSPUT || PLAT_USRV || PLAT_M32700UT)
-	default n
-	help
-	  Say Y here if you want to use the M32R serial controller
-	  on a PLD (Programmable Logic Device).
-
-	  If you use an M3T-M32700UT or an OPSPUT platform,
-	  please say Y.
-
-config SERIAL_TXX9
-	bool "TMPTX39XX/49XX SIO support"
-	depends on HAS_TXX9_SERIAL
-	select SERIAL_CORE
-	default y
-
-config HAS_TXX9_SERIAL
-	bool
-
-config SERIAL_TXX9_NR_UARTS
-	int "Maximum number of TMPTX39XX/49XX SIO ports"
-	depends on SERIAL_TXX9
-	default "6"
-
-config SERIAL_TXX9_CONSOLE
-	bool "TMPTX39XX/49XX SIO Console support"
-	depends on SERIAL_TXX9=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_TXX9_STDSERIAL
-	bool "TX39XX/49XX SIO act as standard serial"
-	depends on !SERIAL_8250 && SERIAL_TXX9
-
-config SERIAL_VR41XX
-	tristate "NEC VR4100 series Serial Interface Unit support"
-	depends on CPU_VR41XX
-	select SERIAL_CORE
-	help
-	  If you have a NEC VR4100 series processor and you want to use
-	  Serial Interface Unit(SIU) or Debug Serial Interface Unit(DSIU)
-	  (not include VR4111/VR4121 DSIU), say Y.  Otherwise, say N.
-
-config SERIAL_VR41XX_CONSOLE
-	bool "Enable NEC VR4100 series Serial Interface Unit console"
-	depends on SERIAL_VR41XX=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have a NEC VR4100 series processor and you want to use
-	  a console on a serial port, say Y.  Otherwise, say N.
-
-config SERIAL_JSM
-	tristate "Digi International NEO PCI Support"
-	depends on PCI
-	select SERIAL_CORE
-	help
-	  This is a driver for Digi International's Neo series
-	  of cards which provide multiple serial ports. You would need
-	  something like this to connect more than two modems to your Linux
-	  box, for instance in order to become a dial-in server. This driver
-	  supports PCI boards only.
-
-	  If you have a card like this, say Y here, otherwise say N.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called jsm.
-
-config SERIAL_SGI_IOC4
-	tristate "SGI IOC4 controller serial support"
-	depends on (IA64_GENERIC || IA64_SGI_SN2) && SGI_IOC4
-	select SERIAL_CORE
-	help
-		If you have an SGI Altix with an IOC4 based Base IO card
-		and wish to use the serial ports on this card, say Y.
-		Otherwise, say N.
-
-config SERIAL_SGI_IOC3
-	tristate "SGI Altix IOC3 serial support"
-	depends on (IA64_GENERIC || IA64_SGI_SN2) && SGI_IOC3
-	select SERIAL_CORE
-	help
-	  If you have an SGI Altix with an IOC3 serial card,
-	  say Y or M.  Otherwise, say N.
-
-config SERIAL_NETX
-	tristate "NetX serial port support"
-	depends on ARM && ARCH_NETX
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a Hilscher NetX SoC you
-	  can enable its onboard serial port by enabling this option.
-
-          To compile this driver as a module, choose M here: the
-          module will be called netx-serial.
-
-config SERIAL_NETX_CONSOLE
-	bool "Console on NetX serial port"
-	depends on SERIAL_NETX=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the Hilscher NetX SoC
-	  you can make it the console by answering Y to this option.
-
-config SERIAL_OF_PLATFORM
-	tristate "Serial port on Open Firmware platform bus"
-	depends on PPC_OF || MICROBLAZE
-	depends on SERIAL_8250 || SERIAL_OF_PLATFORM_NWPSERIAL
-	help
-	  If you have a PowerPC based system that has serial ports
-	  on a platform specific bus, you should enable this option.
-	  Currently, only 8250 compatible ports are supported, but
-	  others can easily be added.
-
-config SERIAL_OF_PLATFORM_NWPSERIAL
-	tristate "NWP serial port driver"
-	depends on PPC_OF && PPC_DCR
-	select SERIAL_OF_PLATFORM
-	select SERIAL_CORE_CONSOLE
-	select SERIAL_CORE
-	help
-	  This driver supports the cell network processor nwp serial
-	  device.
-
-config SERIAL_OF_PLATFORM_NWPSERIAL_CONSOLE
-	bool "Console on NWP serial port"
-	depends on SERIAL_OF_PLATFORM_NWPSERIAL=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Support for Console on the NWP serial ports.
-
-config SERIAL_QE
-	tristate "Freescale QUICC Engine serial port support"
-	depends on QUICC_ENGINE
-	select SERIAL_CORE
-	select FW_LOADER
-	default n
-	help
-	  This driver supports the QE serial ports on Freescale embedded
-	  PowerPC that contain a QUICC Engine.
-
-config SERIAL_SC26XX
-	tristate "SC2681/SC2692 serial port support"
-	depends on SNI_RM
-	select SERIAL_CORE
-	help
-	  This is a driver for the onboard serial ports of
-	  older RM400 machines.
-
-config SERIAL_SC26XX_CONSOLE
-	bool "Console on SC2681/SC2692 serial port"
-	depends on SERIAL_SC26XX
-	select SERIAL_CORE_CONSOLE
-	help
-	  Support for Console on SC2681/SC2692 serial ports.
-
-config SERIAL_BFIN_SPORT
-	tristate "Blackfin SPORT emulate UART (EXPERIMENTAL)"
-	depends on BLACKFIN && EXPERIMENTAL
-	select SERIAL_CORE
+comment "8250 compatible port support"
+config SERIAL_RTL8198_UART1
+	bool "8198 UART1 support"
+	depends on SERIAL_8250 && SERIAL_8250_NR_UARTS >= 2 && SERIAL_8250_RUNTIME_UARTS >= 2
+	help
+		Enable 8198 UART1 support, and this MAY add an uart device to ttyS1. 
+		NOTE: We don't provide option for this port to be console. 
+
+config SERIAL_SC16IS7X0
+	bool "SC16IS7x0 series (I2C bus) support"
+	depends on SERIAL_8250 && SERIAL_8250_NR_UARTS >= 2 && SERIAL_8250_RUNTIME_UARTS >= 2
 	help
-	  Enable SPORT emulate UART on Blackfin series.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bfin_sport_uart.
-
+		Enable sc16is7x0 definition is to add an UART device to ttyS1. 
+		This is based on standard 8250, and doesn't affect original setting. 
 choice
-	prompt "Baud rate for Blackfin SPORT UART"
-	depends on SERIAL_BFIN_SPORT
-	default SERIAL_SPORT_BAUD_RATE_57600
+	prompt "Crystal for SC16IS7x0 XTAL1"
+	depends on SERIAL_SC16IS7X0
 	help
-	  Choose a baud rate for the SPORT UART, other uart settings are
-	  8 bit, 1 stop bit, no parity, no flow control.
-
-config SERIAL_SPORT_BAUD_RATE_115200
-	bool "115200"
-
-config SERIAL_SPORT_BAUD_RATE_57600
-	bool "57600"
-
-config SERIAL_SPORT_BAUD_RATE_38400
-	bool "38400"
-
-config SERIAL_SPORT_BAUD_RATE_19200
-	bool "19200"
-
-config SERIAL_SPORT_BAUD_RATE_9600
-	bool "9600"
+		Crystal for SC16IS7x0 XTAL1. 
+		This is factor of baudrate, so bad parameter will cause UART to be 
+		abnormal.
+	config SERIAL_SC16IS7X0_XTAL1_CLK_1843200
+		bool "1.8432 MHZ"
+	config SERIAL_SC16IS7X0_XTAL1_CLK_14746500
+		bool "14.7465 MHZ (NXP demoboard)"
 endchoice
-
-config SPORT_BAUD_RATE
-	int
-	depends on SERIAL_BFIN_SPORT
-	default 115200 if (SERIAL_SPORT_BAUD_RATE_115200)
-	default 57600 if (SERIAL_SPORT_BAUD_RATE_57600)
-	default 38400 if (SERIAL_SPORT_BAUD_RATE_38400)
-	default 19200 if (SERIAL_SPORT_BAUD_RATE_19200)
-	default 9600 if (SERIAL_SPORT_BAUD_RATE_9600)
-
+config SERIAL_SC16IS7X0_CONSOLE
+	bool "Console on SC16IS7x0 port (ttyS1)"
+	depends on SERIAL_SC16IS7X0 && SERIAL_8250_CONSOLE
+	help
+		If you don't check this option, we will use standard 8250 as console.
+		Here, 8250 and sc16is7x0 occups ttyS0 and ttyS1 respectively.
+		Notice 1:
+			You need add "console=ttyS1" to CONFIG_CMDLINE, or console output will be incorrect.  
+		Notice 2: 
+			If you want to make user space's stdout to this port, 
+			device (major,minor) of /dev/console has to be ttyS1 (4,65) 
+			instead of ttyS0 (4,64). 
 endmenu
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/serial/Makefile linux-2.6.30.9-rsdk/drivers/serial/Makefile
--- linux-2.6.30.9/drivers/serial/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/serial/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -1,79 +1,26 @@
 #
 # Makefile for the kernel serial device drivers.
 #
+ifeq ($(CONFIG_SERIAL_SC16IS7X0),y)
+	EXTRA_CFLAGS += -DCONFIG_RTK_VOIP_DRIVERS_PCM8972B_FAMILY
+endif
 
 obj-$(CONFIG_SERIAL_CORE) += serial_core.o
-obj-$(CONFIG_SERIAL_21285) += 21285.o
 
 # These Sparc drivers have to appear before others such as 8250
 # which share ttySx minor node space.  Otherwise console device
 # names change and other unplesantries.
-obj-$(CONFIG_SERIAL_SUNCORE) += suncore.o
-obj-$(CONFIG_SERIAL_SUNHV) += sunhv.o
-obj-$(CONFIG_SERIAL_SUNZILOG) += sunzilog.o
-obj-$(CONFIG_SERIAL_SUNSU) += sunsu.o
-obj-$(CONFIG_SERIAL_SUNSAB) += sunsab.o
 
 obj-$(CONFIG_SERIAL_8250) += 8250.o
 obj-$(CONFIG_SERIAL_8250_PNP) += 8250_pnp.o
 obj-$(CONFIG_SERIAL_8250_GSC) += 8250_gsc.o
 obj-$(CONFIG_SERIAL_8250_PCI) += 8250_pci.o
-obj-$(CONFIG_SERIAL_8250_HP300) += 8250_hp300.o
-obj-$(CONFIG_SERIAL_8250_CS) += serial_cs.o
-obj-$(CONFIG_SERIAL_8250_ACORN) += 8250_acorn.o
 obj-$(CONFIG_SERIAL_8250_CONSOLE) += 8250_early.o
-obj-$(CONFIG_SERIAL_8250_FOURPORT) += 8250_fourport.o
-obj-$(CONFIG_SERIAL_8250_ACCENT) += 8250_accent.o
-obj-$(CONFIG_SERIAL_8250_BOCA) += 8250_boca.o
-obj-$(CONFIG_SERIAL_8250_EXAR_ST16C554) += 8250_exar_st16c554.o
-obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
-obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
-obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
-obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
-obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
-obj-$(CONFIG_SERIAL_PXA) += pxa.o
-obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
-obj-$(CONFIG_SERIAL_SA1100) += sa1100.o
-obj-$(CONFIG_SERIAL_BFIN) += bfin_5xx.o
-obj-$(CONFIG_SERIAL_BFIN_SPORT) += bfin_sport_uart.o
-obj-$(CONFIG_SERIAL_SAMSUNG) += samsung.o
-obj-$(CONFIG_SERIAL_S3C2400) += s3c2400.o
-obj-$(CONFIG_SERIAL_S3C2410) += s3c2410.o
-obj-$(CONFIG_SERIAL_S3C2412) += s3c2412.o
-obj-$(CONFIG_SERIAL_S3C2440) += s3c2440.o
-obj-$(CONFIG_SERIAL_S3C24A0) += s3c24a0.o
-obj-$(CONFIG_SERIAL_S3C6400) += s3c6400.o
-obj-$(CONFIG_SERIAL_MAX3100) += max3100.o
-obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
-obj-$(CONFIG_SERIAL_MUX) += mux.o
-obj-$(CONFIG_SERIAL_68328) += 68328serial.o
-obj-$(CONFIG_SERIAL_68360) += 68360serial.o
-obj-$(CONFIG_SERIAL_MCF) += mcf.o
-obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
-obj-$(CONFIG_SERIAL_LH7A40X) += serial_lh7a40x.o
-obj-$(CONFIG_SERIAL_DZ) += dz.o
-obj-$(CONFIG_SERIAL_ZS) += zs.o
-obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
-obj-$(CONFIG_SERIAL_SGI_L1_CONSOLE) += sn_console.o
-obj-$(CONFIG_SERIAL_CPM) += cpm_uart/
-obj-$(CONFIG_SERIAL_IMX) += imx.o
-obj-$(CONFIG_SERIAL_MPC52xx) += mpc52xx_uart.o
-obj-$(CONFIG_SERIAL_ICOM) += icom.o
-obj-$(CONFIG_SERIAL_M32R_SIO) += m32r_sio.o
-obj-$(CONFIG_SERIAL_MPSC) += mpsc.o
-obj-$(CONFIG_SERIAL_SB1250_DUART) += sb1250-duart.o
-obj-$(CONFIG_ETRAX_SERIAL) += crisv10.o
-obj-$(CONFIG_SERIAL_SC26XX) += sc26xx.o
-obj-$(CONFIG_SERIAL_JSM) += jsm/
-obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
-obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
-obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
-obj-$(CONFIG_SERIAL_SGI_IOC3) += ioc3_serial.o
-obj-$(CONFIG_SERIAL_ATMEL) += atmel_serial.o
-obj-$(CONFIG_SERIAL_UARTLITE) += uartlite.o
-obj-$(CONFIG_SERIAL_NETX) += netx-serial.o
 obj-$(CONFIG_SERIAL_OF_PLATFORM) += of_serial.o
 obj-$(CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL) += nwpserial.o
-obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
-obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
+obj-$(CONFIG_SERIAL_SC16IS7X0) += 8250_sc16is7x0.o
+obj-$(CONFIG_SERIAL_SC16IS7X0) += i2c.o
+obj-$(CONFIG_SERIAL_SC16IS7X0) += gpio_8972b.o
+
+EXTRA_CFLAGS += -Iinclude/asm-mips/rtl865x/
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/serial/serial_core.c linux-2.6.30.9-rsdk/drivers/serial/serial_core.c
--- linux-2.6.30.9/drivers/serial/serial_core.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/serial/serial_core.c	2011-12-05 15:50:14.000000000 +0000
@@ -417,7 +417,7 @@
 	 * Old custom speed handling.
 	 */
 	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)
-		quot = port->custom_divisor;
+		quot = 3; //port->custom_divisor;
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
 
@@ -2140,12 +2140,14 @@
 		break;
 	case UPIO_MEM:
 	case UPIO_MEM32:
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_DWAPB:
 		snprintf(address, sizeof(address),
 			 "MMIO 0x%llx", (unsigned long long)port->mapbase);
 		break;
+	case UPIO_I2C:
+		snprintf(address, sizeof(address),
+			 "I2C 0x%lx", port->iobase);
+		break;		
 	default:
 		strlcpy(address, "*unknown*", sizeof(address));
 		break;
@@ -2349,8 +2351,13 @@
 	normal->type		= TTY_DRIVER_TYPE_SERIAL;
 	normal->subtype		= SERIAL_TYPE_NORMAL;
 	normal->init_termios	= tty_std_termios;
+#if defined(CONFIG_SERIAL_SC16IS7X0) || defined(CONFIG_SERIAL_RTL8198_UART1)
+	normal->init_termios.c_cflag = B38400 | CS8 | CREAD | HUPCL | CLOCAL;
+	normal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 38400;
+#else
 	normal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	normal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 9600;
+#endif
 	normal->flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	normal->driver_state    = drv;
 	tty_set_operations(normal, &uart_ops);
@@ -2554,10 +2561,10 @@
 		       (port1->hub6   == port2->hub6);
 	case UPIO_MEM:
 	case UPIO_MEM32:
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_DWAPB:
 		return (port1->mapbase == port2->mapbase);
+	case UPIO_I2C:
+		return (port1->iobase == port2->iobase);		
 	}
 	return 0;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/staging/Kconfig linux-2.6.30.9-rsdk/drivers/staging/Kconfig
--- linux-2.6.30.9/drivers/staging/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/staging/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -85,6 +85,8 @@
 
 source "drivers/staging/rtl8187se/Kconfig"
 
+source "drivers/staging/rtl8192su/Kconfig"
+
 source "drivers/staging/rspiusb/Kconfig"
 
 source "drivers/staging/mimio/Kconfig"
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/staging/Makefile linux-2.6.30.9-rsdk/drivers/staging/Makefile
--- linux-2.6.30.9/drivers/staging/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/staging/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -25,6 +25,7 @@
 obj-$(CONFIG_PANEL)		+= panel/
 obj-$(CONFIG_ALTERA_PCIE_CHDMA)	+= altpciechdma/
 obj-$(CONFIG_RTL8187SE)		+= rtl8187se/
+obj-$(CONFIG_RTL8192SU)		+= rtl8192su/
 obj-$(CONFIG_USB_RSPI)		+= rspiusb/
 obj-$(CONFIG_INPUT_MIMIO)	+= mimio/
 obj-$(CONFIG_TRANZPORT)		+= frontier/
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/core/hcd.c linux-2.6.30.9-rsdk/drivers/usb/core/hcd.c
--- linux-2.6.30.9/drivers/usb/core/hcd.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/core/hcd.c	2011-12-05 15:50:14.000000000 +0000
@@ -82,7 +82,7 @@
 /*-------------------------------------------------------------------------*/
 
 /* Keep track of which host controller drivers are loaded */
-unsigned long usb_hcds_loaded;
+unsigned long usb_hcds_loaded=0;
 EXPORT_SYMBOL_GPL(usb_hcds_loaded);
 
 /* host controllers we manage */
@@ -878,7 +878,7 @@
  * to register the usb device.  It also assigns the root hub's USB address
  * (always 1).
  */
-static int register_root_hub(struct usb_hcd *hcd)
+int register_root_hub(struct usb_hcd *hcd)
 {
 	struct device *parent_dev = hcd->self.controller;
 	struct usb_device *usb_dev = hcd->self.root_hub;
@@ -923,6 +923,8 @@
 	return retval;
 }
 
+EXPORT_SYMBOL(register_root_hub);
+
 
 /*-------------------------------------------------------------------------*/
 
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/core/hub.c linux-2.6.30.9-rsdk/drivers/usb/core/hub.c
--- linux-2.6.30.9/drivers/usb/core/hub.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/core/hub.c	2011-12-05 15:50:14.000000000 +0000
@@ -30,6 +30,13 @@
 #include "hcd.h"
 #include "hub.h"
 
+//#include "rtl865xc_asicregs.h"
+
+#define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
+#define PABCD_DIR  0xb8003508
+#define PABCD_DAT 0xb800350C
+#define USB_LED_OFFSET 19
+
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
 #ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES
@@ -1432,8 +1439,12 @@
 	 * this quiesces everyting except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+	//RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) | (1 << EN_USB_LED)));
+	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<USB_LED_OFFSET);
+	REG32(PABCD_DAT) = REG32(PABCD_DAT) | (0x1<<USB_LED_OFFSET);
 	dev_info (&udev->dev, "USB disconnect, address %d\n", udev->devnum);
 
+	
 	usb_lock_device(udev);
 
 	/* Free up all the children before we remove this device */
@@ -1776,17 +1787,16 @@
 }
 
 
-#define PORT_RESET_TRIES	5
+#define PORT_RESET_TRIES	20
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
 #define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))
 #define USE_NEW_SCHEME(i)	((i) / 2 == old_scheme_first)
 
-#define HUB_ROOT_RESET_TIME	50	/* times are in msec */
+#define HUB_ROOT_RESET_TIME	500	/* times are in msec */
 #define HUB_SHORT_RESET_TIME	10
-#define HUB_LONG_RESET_TIME	200
-#define HUB_RESET_TIMEOUT	500
-
+#define HUB_LONG_RESET_TIME	2000
+#define HUB_RESET_TIMEOUT	10000
 static int hub_port_wait_reset(struct usb_hub *hub, int port1,
 				struct usb_device *udev, unsigned int delay)
 {
@@ -1842,8 +1852,13 @@
 static int hub_port_reset(struct usb_hub *hub, int port1,
 				struct usb_device *udev, unsigned int delay)
 {
+#ifdef CONFIG_RTL_OTGCTRL	 
+	//slove the usb phy debonce. close the auto-det interrupt
+	extern unsigned int TurnOn_OTGCtrl_Interrupt(unsigned int);  //wei add
+	int old=TurnOn_OTGCtrl_Interrupt(0);  //wei add
+#endif	
 	int i, status;
-
+	unsigned char retry=3;  //realtek patch, if failed, retry 3 times
 	/* Block EHCI CF initialization during the port reset.
 	 * Some companion controllers don't like it when they mix.
 	 */
@@ -1868,12 +1883,19 @@
 		/* return on disconnect or reset */
 		switch (status) {
 		case 0:
+			retry = 0; //realtek patch
 			/* TRSTRCY = 10 ms; plus some extra */
 			msleep(10 + 40);
 			update_address(udev, 0);
 			/* FALL THROUGH */
 		case -ENOTCONN:
 		case -ENODEV:
+//realtek patch
+			if(retry){
+				retry--;
+				continue;
+			}
+////
 			clear_port_feature(hub->hdev,
 				port1, USB_PORT_FEAT_C_RESET);
 			/* FIXME need disconnect() for NOTATTACHED device */
@@ -1895,6 +1917,10 @@
 
  done:
 	up_read(&ehci_cf_port_reset_rwsem);
+	
+#ifdef CONFIG_RTL_OTGCTRL	 
+	TurnOn_OTGCtrl_Interrupt(old);  //wei add
+#endif
 	return status;
 }
 
@@ -2451,6 +2477,13 @@
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
 	 */
+
+	//RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & 0xffffbfff));
+
+	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<USB_LED_OFFSET);
+	REG32(PABCD_DAT) = REG32(PABCD_DAT) &(~ (0x1<<USB_LED_OFFSET));
+
+
 	if (!hdev->parent) {
 		delay = HUB_ROOT_RESET_TIME;
 		if (port1 == hdev->bus->otg_port)
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/core/urb.c linux-2.6.30.9-rsdk/drivers/usb/core/urb.c
--- linux-2.6.30.9/drivers/usb/core/urb.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/core/urb.c	2011-12-05 15:50:14.000000000 +0000
@@ -8,6 +8,12 @@
 #include <linux/wait.h>
 #include "hcd.h"
 
+#include "bspchip.h"
+
+#ifndef __IRAM_USB
+#define __IRAM_USB 
+#endif
+
 #define to_urb(d) container_of(d, struct urb, kref)
 
 
@@ -87,6 +93,7 @@
  * Note: The transfer buffer associated with the urb is not freed unless the
  * URB_FREE_BUFFER transfer flag is set.
  */
+__IRAM_USB 
 void usb_free_urb(struct urb *urb)
 {
 	if (urb)
@@ -104,6 +111,7 @@
  *
  * A pointer to the urb with the incremented reference counter is returned.
  */
+__IRAM_USB
 struct urb *usb_get_urb(struct urb *urb)
 {
 	if (urb)
@@ -285,6 +293,7 @@
  *      GFP_NOIO, unless b) or c) apply
  *
  */
+__IRAM_USB
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
 	int				xfertype, max;
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/core/usb.c linux-2.6.30.9-rsdk/drivers/usb/core/usb.c
--- linux-2.6.30.9/drivers/usb/core/usb.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/core/usb.c	2011-12-05 15:50:14.000000000 +0000
@@ -43,6 +43,10 @@
 #include "hcd.h"
 #include "usb.h"
 
+#define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
+#define PIN_MUX_SEL_2 0xb8000044
+#define PABCD_DIR  0xb8003508
+#define PABCD_DAT 0xb800350C
 
 const char *usbcore_name = "usbcore";
 
@@ -1001,6 +1005,16 @@
 	.notifier_call = usb_bus_notify,
 };
 
+
+static void usb_led_init(void)
+{
+	REG32(PIN_MUX_SEL_2) = REG32(PIN_MUX_SEL_2) |(0x7<<21);
+	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<19);
+	REG32(PABCD_DAT) = REG32(PABCD_DAT) |(0x1<<19);
+}
+
+
+
 /*
  * Init
  */
@@ -1011,7 +1025,7 @@
 		pr_info("%s: USB support disabled\n", usbcore_name);
 		return 0;
 	}
-
+	usb_led_init();
 	retval = ksuspend_usb_init();
 	if (retval)
 		goto out;
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ehci.h linux-2.6.30.9-rsdk/drivers/usb/host/ehci.h
--- linux-2.6.30.9/drivers/usb/host/ehci.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci.h	2011-12-05 15:50:14.000000000 +0000
@@ -36,6 +36,11 @@
 #define __hc32	__le32
 #define __hc16	__le16
 #endif
+#include "bspchip.h"
+
+#ifndef __IRAM_USB
+#define __IRAM_USB 
+#endif
 
 /* statistics can be kept for for tuning/monitoring */
 struct ehci_stats {
@@ -602,6 +607,9 @@
 static inline unsigned int ehci_readl(const struct ehci_hcd *ehci,
 		__u32 __iomem * regs)
 {
+#if defined(CONFIG_RTL_819X)
+        return (le32_to_cpu((*(volatile unsigned long *)(regs))));
+#else
 #ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
 	return ehci_big_endian_mmio(ehci) ?
 		readl_be(regs) :
@@ -609,11 +617,15 @@
 #else
 	return readl(regs);
 #endif
+#endif
 }
 
 static inline void ehci_writel(const struct ehci_hcd *ehci,
 		const unsigned int val, __u32 __iomem *regs)
 {
+#if defined(CONFIG_RTL_819X)
+        ((*(volatile unsigned long *)(regs))=cpu_to_le32(val));
+#else
 #ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
 	ehci_big_endian_mmio(ehci) ?
 		writel_be(val, regs) :
@@ -621,6 +633,7 @@
 #else
 	writel(val, regs);
 #endif
+#endif
 }
 
 /*
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ehci-hcd.c linux-2.6.30.9-rsdk/drivers/usb/host/ehci-hcd.c
--- linux-2.6.30.9/drivers/usb/host/ehci-hcd.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-hcd.c	2011-12-05 15:50:14.000000000 +0000
@@ -169,10 +169,10 @@
 	u32	result;
 
 	do {
-		result = ehci_readl(ehci, ptr);
+		result = (ehci_readl(ehci, ptr))&0xffff;
 		if (result == ~(u32)0)		/* card removed */
 			return -ENODEV;
-		result &= mask;
+		result &= (mask)&0xffff;
 		if (result == done)
 			return 0;
 		udelay (1);
@@ -429,6 +429,7 @@
  * ehci_work is called from some interrupts, timers, and so on.
  * it calls driver completion functions, after dropping ehci->lock.
  */
+__IRAM_USB
 static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
@@ -677,7 +678,7 @@
 }
 
 /*-------------------------------------------------------------------------*/
-
+__IRAM_USB
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
@@ -786,7 +787,19 @@
 	}
 
 	if (bh)
+	{
+		#if 1
+		 __asm__ __volatile__(  \
+                ".set   push\n\t"       \
+                ".set   noreorder\n\t"  \
+                "nop\n\t"               \
+		"nop\n\t"               \
+		"nop\n\t"               \
+		".set   pop\n\t");
+		#endif
+
 		ehci_work (ehci);
+	}
 	spin_unlock (&ehci->lock);
 	if (pcd_status)
 		usb_hcd_poll_rh_status(hcd);
@@ -807,6 +820,7 @@
  * NOTE:  control, bulk, and interrupt share the same code to append TDs
  * to a (possibly active) QH, and the same QH scanning code.
  */
+__IRAM_USB
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
 	struct urb	*urb,
@@ -1040,48 +1054,31 @@
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_VIA_PCI
 #include "ehci-pci.c"
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_FSL
-#include "ehci-fsl.c"
-#define	PLATFORM_DRIVER		ehci_fsl_driver
-#endif
-
-#ifdef CONFIG_SOC_AU1200
-#include "ehci-au1xxx.c"
-#define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
-#endif
-
-#ifdef CONFIG_PPC_PS3
-#include "ehci-ps3.c"
-#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
-#endif
-
-#ifdef CONFIG_USB_EHCI_HCD_PPC_OF
-#include "ehci-ppc-of.c"
-#define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
-#endif
-
-#ifdef CONFIG_PLAT_ORION
-#include "ehci-orion.c"
-#define	PLATFORM_DRIVER		ehci_orion_driver
+#if defined(CONFIG_RTL_819X)
+#include "ehci-rtl8652.c"
+#define PLATFORM_DRIVER		ehci_rtl8652_driver
 #endif
 
-#ifdef CONFIG_ARCH_IXP4XX
-#include "ehci-ixp4xx.c"
-#define	PLATFORM_DRIVER		ixp4xx_ehci_driver
+#ifdef CONFIG_USB_EHCI_DWC 
+#include "ehci-dwc.c"
+#define	PLATFORM_DRIVER  ehci_dwc_driver
 #endif
 
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
+#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
 static int __init ehci_hcd_init(void)
 {
+	if (test_bit(USB_EHCI_LOADED, &usb_hcds_loaded))
+	{	printk("EHCI-HCD: already init \n");
+		return -1;
+	}
 	int retval = 0;
 
 	if (usb_disabled())
@@ -1099,6 +1096,13 @@
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
+#if defined(CONFIG_RTL_819X)
+	if(ehci_rtl8652_init() !=0)
+	{ retval = -1;   //wei add
+	   goto err_out;   //wei add
+	}
+#endif
+
 #ifdef DEBUG
 	ehci_debug_root = debugfs_create_dir("ehci", NULL);
 	if (!ehci_debug_root) {
@@ -1119,27 +1123,8 @@
 		goto clean1;
 #endif
 
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0)
-		goto clean2;
-#endif
-
-#ifdef OF_PLATFORM_DRIVER
-	retval = of_register_platform_driver(&OF_PLATFORM_DRIVER);
-	if (retval < 0)
-		goto clean3;
-#endif
 	return retval;
 
-#ifdef OF_PLATFORM_DRIVER
-	/* of_unregister_platform_driver(&OF_PLATFORM_DRIVER); */
-clean3:
-#endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
-clean2:
-#endif
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 clean1:
@@ -1153,28 +1138,39 @@
 	ehci_debug_root = NULL;
 err_debug:
 #endif
+err_out:
+
+#if defined(CONFIG_RTL_819X)  
+	ehci_rtl8652_cleanup();   //wei add
+#endif
+
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ehci_hcd_init);
-
+//-----------------------------------------------------------
 static void __exit ehci_hcd_cleanup(void)
 {
-#ifdef OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
-#endif
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
-#endif
+	if (!test_bit(USB_EHCI_LOADED, &usb_hcds_loaded))
+	{	printk("EHCI-HCD: not init, cannot cleanup \n");
+		return;
+	}
+
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+
+#ifdef PLATFORM_DRIVER
+	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
+
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 #endif
+
+#if defined(CONFIG_RTL_819X)  
+	ehci_rtl8652_cleanup();   //wei add
+#endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ehci-hub.c linux-2.6.30.9-rsdk/drivers/usb/host/ehci-hub.c
--- linux-2.6.30.9/drivers/usb/host/ehci-hub.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-hub.c	2011-12-05 15:50:14.000000000 +0000
@@ -412,6 +412,12 @@
 	u32 __iomem	*status_reg,
 	int		port_status
 ) {
+//realtek patch
+#if 1 /* patch for synopsis USB 2.0 */
+	int i;
+	static unsigned char retry=3; //if failed, retry 3 times
+#endif
+////
 	if (!(port_status & PORT_CONNECT))
 		return port_status;
 
@@ -425,7 +431,12 @@
 				index+1);
 			return port_status;
 		}
-
+		//realtek patch
+		if(--retry) {
+			return port_status;
+		}
+		retry = 3;	
+		/////	
 		ehci_dbg (ehci, "port %d full speed --> companion\n",
 			index + 1);
 
@@ -438,6 +449,9 @@
 		if (ehci->has_amcc_usb23)
 			set_ohci_hcfs(ehci, 1);
 	} else {
+            //realtek patch
+		retry = 3;  //realtek patch
+            ////
 		ehci_dbg (ehci, "port %d high speed\n", index + 1);
 		/* ensure 440EPx ohci controller state is suspended */
 		if (ehci->has_amcc_usb23)
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ehci-q.c linux-2.6.30.9-rsdk/drivers/usb/host/ehci-q.c
--- linux-2.6.30.9/drivers/usb/host/ehci-q.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-q.c	2011-12-05 15:50:14.000000000 +0000
@@ -41,7 +41,7 @@
 /*-------------------------------------------------------------------------*/
 
 /* fill a qtd, returning how much of the buffer we were able to queue up */
-
+__IRAM_USB
 static int
 qtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,
 		  size_t len, int token, int maxpacket)
@@ -83,7 +83,7 @@
 }
 
 /*-------------------------------------------------------------------------*/
-
+__IRAM_USB
 static inline void
 qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 {
@@ -118,6 +118,7 @@
  * overlay, so qh->hw_token wrongly becomes inactive/halted), only fault
  * recovery (including urb dequeue) would need software changes to a QH...
  */
+__IRAM_USB
 static void
 qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
@@ -138,7 +139,7 @@
 }
 
 /*-------------------------------------------------------------------------*/
-
+__IRAM_USB
 static void qh_link_async(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 static void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,
@@ -187,7 +188,7 @@
 		}
 	}
 }
-
+__IRAM_USB
 static int qtd_copy_status (
 	struct ehci_hcd *ehci,
 	struct urb *urb,
@@ -248,7 +249,7 @@
 
 	return status;
 }
-
+__IRAM_USB
 static void
 ehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)
 __releases(ehci->lock)
@@ -570,6 +571,7 @@
 /*
  * create a list of filled qtds for this URB; won't link into qh.
  */
+__IRAM_USB
 static struct list_head *
 qh_urb_transaction (
 	struct ehci_hcd		*ehci,
@@ -952,6 +954,7 @@
  * Returns null if it can't allocate a QH it needs to.
  * If the QH has TDs (urbs) already, that's great.
  */
+__IRAM_USB
 static struct ehci_qh *qh_append_tds (
 	struct ehci_hcd		*ehci,
 	struct urb		*urb,
@@ -1033,6 +1036,7 @@
 
 /*-------------------------------------------------------------------------*/
 
+__IRAM_USB
 static int
 submit_async (
 	struct ehci_hcd		*ehci,
@@ -1091,6 +1095,7 @@
 
 /* the async qh for the qtds being reclaimed are now unlinked from the HC */
 
+__IRAM_USB
 static void end_unlink_async (struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh = ehci->reclaim;
@@ -1132,6 +1137,7 @@
 /* makes sure the async qh will become idle */
 /* caller must own ehci->lock */
 
+__IRAM_USB
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	int		cmd = ehci_readl(ehci, &ehci->regs->command);
@@ -1189,6 +1195,7 @@
 
 /*-------------------------------------------------------------------------*/
 
+__IRAM_USB
 static void scan_async (struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh;
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ehci-sched.c linux-2.6.30.9-rsdk/drivers/usb/host/ehci-sched.c
--- linux-2.6.30.9/drivers/usb/host/ehci-sched.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-sched.c	2011-12-05 15:50:14.000000000 +0000
@@ -608,7 +608,8 @@
 					& qh->hw_info2) != 0)
 		wait = 2;
 	else
-		wait = 55;	/* worst case: 3 * 1024 */
+		//wait = 55;	/* worst case: 3 * 1024 */
+		wait = 3 * 1024;
 
 	udelay (wait);
 	qh->qh_state = QH_STATE_IDLE;
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/Kconfig linux-2.6.30.9-rsdk/drivers/usb/host/Kconfig
--- linux-2.6.30.9/drivers/usb/host/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -78,6 +78,12 @@
 	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX)
 	default y
 
+#config USB_EHCI_DWC
+#	bool "Support for Synopsys DWC EHCI USB controller"
+#	depends on USB_EHCI_HCD
+#	select USB_EHCI_ROOT_HUB_TT
+#    default y
+
 config USB_EHCI_FSL
 	bool "Support for Freescale on-chip EHCI USB controller"
 	depends on USB_EHCI_HCD && FSL_SOC
@@ -88,7 +94,6 @@
 config USB_EHCI_HCD_PPC_OF
 	bool "EHCI support for PPC USB controller on OF platform bus"
 	depends on USB_EHCI_HCD && PPC_OF
-	default y
 	---help---
 	  Enables support for the USB controller present on the PowerPC
 	  OpenFirmware platform bus.
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ohci.h linux-2.6.30.9-rsdk/drivers/usb/host/ohci.h
--- linux-2.6.30.9/drivers/usb/host/ohci.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ohci.h	2011-12-05 15:50:14.000000000 +0000
@@ -544,6 +544,9 @@
 static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 					__hc32 __iomem * regs)
 {
+#if defined(CONFIG_RTL_819X)
+        return (le32_to_cpu((*(volatile unsigned long *)(regs))));
+#else
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	return big_endian_mmio(ohci) ?
 		readl_be (regs) :
@@ -551,11 +554,15 @@
 #else
 	return readl (regs);
 #endif
+#endif
 }
 
 static inline void _ohci_writel (const struct ohci_hcd *ohci,
 				 const unsigned int val, __hc32 __iomem *regs)
 {
+#if defined(CONFIG_RTL_819X)
+        ((*(volatile unsigned long *)(regs))=cpu_to_le32(val));
+#else
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	big_endian_mmio(ohci) ?
 		writel_be (val, regs) :
@@ -563,6 +570,7 @@
 #else
 		writel (val, regs);
 #endif
+#endif
 }
 
 #ifdef CONFIG_ARCH_LH7A404
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/host/ohci-hcd.c linux-2.6.30.9-rsdk/drivers/usb/host/ohci-hcd.c
--- linux-2.6.30.9/drivers/usb/host/ohci-hcd.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ohci-hcd.c	2011-12-05 15:50:14.000000000 +0000
@@ -1047,6 +1047,11 @@
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#if defined(CONFIG_RTL_819X)
+#include "ohci-rtl8652.c"
+#define PLATFORM_DRIVER		ohci_hcd_rtl8652_driver
+#endif
+
 #if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
     defined(CONFIG_CPU_SUBTYPE_SH7721) || \
     defined(CONFIG_CPU_SUBTYPE_SH7763) || \
@@ -1094,6 +1099,11 @@
 
 static int __init ohci_hcd_mod_init(void)
 {
+	if ( test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+	{	printk("OHCI-HCD: already init \n");
+		return -1;
+	}
+	
 	int retval = 0;
 
 	if (usb_disabled())
@@ -1104,6 +1114,13 @@
 		sizeof (struct ed), sizeof (struct td));
 	set_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 
+#if defined(CONFIG_RTL_819X)
+	if(ohci_rtl8652_init() !=0)
+	{ retval = -1;   //wei add
+	   goto err_out;   //wei add
+	}
+#endif
+
 #ifdef DEBUG
 	ohci_debug_root = debugfs_create_dir("ohci", NULL);
 	if (!ohci_debug_root) {
@@ -1200,14 +1217,22 @@
 	ohci_debug_root = NULL;
  error_debug:
 #endif
-
+err_out:
+#if defined(CONFIG_RTL_819X)  
+	ohci_rtl8652_cleanup();   //wei add
+#endif
 	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ohci_hcd_mod_init);
-
+//-----------------------------------------------------------
 static void __exit ohci_hcd_mod_exit(void)
 {
+	if (!test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+	{	printk("OHCI-HCD: not init, cannot cleanup \n");
+		return;
+	}
+
 #ifdef TMIO_OHCI_DRIVER
 	platform_driver_unregister(&TMIO_OHCI_DRIVER);
 #endif
@@ -1235,6 +1260,10 @@
 #ifdef DEBUG
 	debugfs_remove(ohci_debug_root);
 #endif
+
+#if defined(CONFIG_RTL_819X)  //wei add
+        ohci_rtl8652_cleanup();
+#endif
 	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ohci_hcd_mod_exit);
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/Kconfig linux-2.6.30.9-rsdk/drivers/usb/Kconfig
--- linux-2.6.30.9/drivers/usb/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -19,45 +19,18 @@
 	boolean
 	default y if USB_ARCH_HAS_OHCI
 	default y if USB_ARCH_HAS_EHCI
-	default y if PCMCIA && !M32R			# sl811_cs
-	default y if ARM				# SL-811
-	default y if SUPERH				# r8a66597-hcd
-	default PCI
+	default y if RTL_819X
+	default y if SOC_HAS_USB
 
 # many non-PCI SOC chips embed OHCI
 config USB_ARCH_HAS_OHCI
 	boolean
-	# ARM:
-	default y if SA1111
-	default y if ARCH_OMAP
-	default y if ARCH_LH7A404
-	default y if ARCH_S3C2410
-	default y if PXA27x
-	default y if PXA3xx
-	default y if ARCH_EP93XX
-	default y if ARCH_AT91
-	default y if ARCH_PNX4008 && I2C
-	default y if MFD_TC6393XB
-	# PPC:
-	default y if STB03xxx
-	default y if PPC_MPC52xx
-	# MIPS:
-	default y if SOC_AU1X00
-	# SH:
-	default y if CPU_SUBTYPE_SH7720
-	default y if CPU_SUBTYPE_SH7721
-	default y if CPU_SUBTYPE_SH7763
-	default y if CPU_SUBTYPE_SH7786
-	# more:
-	default PCI
+	default y if RTL_819X
 
 # some non-PCI hcds implement EHCI
 config USB_ARCH_HAS_EHCI
 	boolean
-	default y if PPC_83xx
-	default y if SOC_AU1200
-	default y if ARCH_IXP4XX
-	default PCI
+	default y if RTL_819X
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
 config USB
@@ -153,4 +126,6 @@
 
 source "drivers/usb/otg/Kconfig"
 
+source "drivers/usb/dwc_otg/Kconfig"
+
 endif # USB_SUPPORT
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/Makefile linux-2.6.30.9-rsdk/drivers/usb/Makefile
--- linux-2.6.30.9/drivers/usb/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -22,6 +22,7 @@
 
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
+obj-$(CONFIG_DWC_OTG)       += dwc_otg/
 obj-$(CONFIG_USB_WUSB)		+= wusbcore/
 
 obj-$(CONFIG_USB_ACM)		+= class/
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/serial/option.c linux-2.6.30.9-rsdk/drivers/usb/serial/option.c
--- linux-2.6.30.9/drivers/usb/serial/option.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/serial/option.c	2011-12-05 15:50:14.000000000 +0000
@@ -297,6 +297,8 @@
 #define ZTE_PRODUCT_MF628			0x0015
 #define ZTE_PRODUCT_MF626			0x0031
 #define ZTE_PRODUCT_CDMA_TECH			0xfffe
+#define ZTE_PRODUCT_AC8710			0xfff1
+#define ZTE_PRODUCT_AC2726			0xfff5
 
 #define BENQ_VENDOR_ID				0x04a5
 #define BENQ_PRODUCT_H10			0x4068
@@ -304,6 +306,16 @@
 #define DLINK_VENDOR_ID				0x1186
 #define DLINK_PRODUCT_DWM_652			0x3e04
 
+#define QISDA_VENDOR_ID             0x1da5
+#define QISDA_PRODUCT_H21_4512          0x4512
+#define QISDA_PRODUCT_H21_4523          0x4523
+#define QISDA_PRODUCT_H20_4515          0x4515
+#define QISDA_PRODUCT_H20_4519          0x4519
+
+/* SMPS PRODUCTS */
+#define SMPS_VENDOR_ID              0xfeed
+#define SMPS_PRODUCT_TITAN20            0x1234
+
 
 static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
@@ -522,7 +534,19 @@
 	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH) },
 	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_H10) },
 	{ USB_DEVICE(DLINK_VENDOR_ID, DLINK_PRODUCT_DWM_652) },
-	{ USB_DEVICE(0x1da5, 0x4515) }, /* BenQ H20 */
+
+    /* bruce: for qisda */
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H21_4512) },
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H21_4523) },
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H20_4515) },
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H20_4519) },
+
+	/* bruce: for ZTE */
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710, 0xff, 0xff, 0xff) },
+
+    /* mobilepeak */
+    { USB_DEVICE_AND_INTERFACE_INFO(SMPS_VENDOR_ID, SMPS_PRODUCT_TITAN20, 0xff, 0xff, 0xff) },
+
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
@@ -833,8 +857,9 @@
 			dbg("%s: type %x req %x", __func__,
 				req_pkt->bRequestType, req_pkt->bRequest);
 		}
-	} else
+	} else {/////TODO
 		err("%s: error %d", __func__, status);
+    }
 
 	/* Resubmit urb so we continue receiving IRQ data */
 	if (status != -ESHUTDOWN && status != -ENOENT) {
diff -uNr --ignore-all-space linux-2.6.30.9/drivers/usb/serial/usb-serial.c linux-2.6.30.9-rsdk/drivers/usb/serial/usb-serial.c
--- linux-2.6.30.9/drivers/usb/serial/usb-serial.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/drivers/usb/serial/usb-serial.c	2011-12-05 15:50:14.000000000 +0000
@@ -35,6 +35,10 @@
 #include <linux/usb/serial.h>
 #include "pl2303.h"
 
+#if CONFIG_USB_SERIAL_OPTION
+#include <linux/smp_lock.h> /* brucehou, 2010/05/21, for lock_kernel & unlock_kernel */
+#endif
+
 /*
  * Version Information
  */
diff -uNr --ignore-all-space linux-2.6.30.9/fs/cifs/connect.c linux-2.6.30.9-rsdk/fs/cifs/connect.c
--- linux-2.6.30.9/fs/cifs/connect.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/cifs/connect.c	2011-12-05 15:50:14.000000000 +0000
@@ -2563,7 +2563,6 @@
 
 			if (mount_data != mount_data_global)
 				kfree(mount_data);
-
 			mount_data = cifs_compose_mount_options(
 					cifs_sb->mountdata, full_path + 1,
 					referrals, &fake_devname);
diff -uNr --ignore-all-space linux-2.6.30.9/fs/dcache.c linux-2.6.30.9-rsdk/fs/dcache.c
--- linux-2.6.30.9/fs/dcache.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/dcache.c	2011-12-05 15:50:14.000000000 +0000
@@ -1865,6 +1865,7 @@
 shouldnt_be_hashed:
 	spin_unlock(&dcache_lock);
 	BUG();
+	return 0;
 }
 
 static int prepend(char **buffer, int *buflen, const char *str, int namelen)
@@ -2256,7 +2257,7 @@
 					HASH_EARLY,
 					&d_hash_shift,
 					&d_hash_mask,
-					0);
+					256*1024);
 
 	for (loop = 0; loop < (1 << d_hash_shift); loop++)
 		INIT_HLIST_HEAD(&dentry_hashtable[loop]);
@@ -2288,7 +2289,7 @@
 					0,
 					&d_hash_shift,
 					&d_hash_mask,
-					0);
+					256*1024);
 
 	for (loop = 0; loop < (1 << d_hash_shift); loop++)
 		INIT_HLIST_HEAD(&dentry_hashtable[loop]);
diff -uNr --ignore-all-space linux-2.6.30.9/fs/hostfs/Makefile linux-2.6.30.9-rsdk/fs/hostfs/Makefile
--- linux-2.6.30.9/fs/hostfs/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/hostfs/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -8,4 +8,4 @@
 obj-y :=
 obj-$(CONFIG_HOSTFS) += hostfs.o
 
-include arch/um/scripts/Makefile.rules
+#include arch/um/scripts/Makefile.rules
diff -uNr --ignore-all-space linux-2.6.30.9/fs/inode.c linux-2.6.30.9-rsdk/fs/inode.c
--- linux-2.6.30.9/fs/inode.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/inode.c	2011-12-05 15:50:14.000000000 +0000
@@ -123,6 +123,7 @@
 	static const struct address_space_operations empty_aops;
 	static struct inode_operations empty_iops;
 	static const struct file_operations empty_fops;
+
 	struct address_space *const mapping = &inode->i_data;
 
 	inode->i_sb = sb;
@@ -1520,7 +1521,7 @@
 					HASH_EARLY,
 					&i_hash_shift,
 					&i_hash_mask,
-					0);
+					256*1024);
 
 	for (loop = 0; loop < (1 << i_hash_shift); loop++)
 		INIT_HLIST_HEAD(&inode_hashtable[loop]);
@@ -1551,7 +1552,7 @@
 					0,
 					&i_hash_shift,
 					&i_hash_mask,
-					0);
+					256*1024);
 
 	for (loop = 0; loop < (1 << i_hash_shift); loop++)
 		INIT_HLIST_HEAD(&inode_hashtable[loop]);
diff -uNr --ignore-all-space linux-2.6.30.9/fs/jffs2/super.c linux-2.6.30.9-rsdk/fs/jffs2/super.c
--- linux-2.6.30.9/fs/jffs2/super.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/jffs2/super.c	2011-12-05 15:50:14.000000000 +0000
@@ -209,6 +209,7 @@
 	.name =		"jffs2",
 	.get_sb =	jffs2_get_sb,
 	.kill_sb =	jffs2_kill_sb,
+	.fs_flags	= FS_REQUIRES_DEV,	// pkshih: add to make mount_block_root() try this fs 
 };
 
 static int __init init_jffs2_fs(void)
diff -uNr --ignore-all-space linux-2.6.30.9/fs/ocfs2/super.c linux-2.6.30.9-rsdk/fs/ocfs2/super.c
--- linux-2.6.30.9/fs/ocfs2/super.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/ocfs2/super.c	2011-12-05 15:50:14.000000000 +0000
@@ -305,6 +305,7 @@
 
 	out += snprintf(buf + out, len - out, "%10s => %3s  %10s\n",
 			"Slots", "Num", "RecoGen");
+
 	for (i = 0; i < osb->max_slots; ++i) {
 		out += snprintf(buf + out, len - out,
 				"%10s  %c %3d  %10d\n",
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/block.c linux-2.6.30.9-rsdk/fs/squashfs/block.c
--- linux-2.6.30.9/fs/squashfs/block.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/block.c	2011-12-05 15:50:14.000000000 +0000
@@ -29,16 +29,14 @@
 #include <linux/fs.h>
 #include <linux/vfs.h>
 #include <linux/slab.h>
-#include <linux/mutex.h>
 #include <linux/string.h>
 #include <linux/buffer_head.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
 #include "squashfs_fs_i.h"
 #include "squashfs.h"
-
+#include "decompressor.h"
 /*
  * Read the metadata block length, this is stored in the first two
  * bytes of the metadata block.
@@ -153,72 +151,10 @@
 	}
 
 	if (compressed) {
-		int zlib_err = 0, zlib_init = 0;
-
-		/*
-		 * Uncompress block.
-		 */
-
-		mutex_lock(&msblk->read_data_mutex);
-
-		msblk->stream.avail_out = 0;
-		msblk->stream.avail_in = 0;
-
-		bytes = length;
-		do {
-			if (msblk->stream.avail_in == 0 && k < b) {
-				avail = min(bytes, msblk->devblksize - offset);
-				bytes -= avail;
-				wait_on_buffer(bh[k]);
-				if (!buffer_uptodate(bh[k]))
-					goto release_mutex;
-
-				if (avail == 0) {
-					offset = 0;
-					put_bh(bh[k++]);
-					continue;
-				}
-
-				msblk->stream.next_in = bh[k]->b_data + offset;
-				msblk->stream.avail_in = avail;
-				offset = 0;
-			}
-
-			if (msblk->stream.avail_out == 0 && page < pages) {
-				msblk->stream.next_out = buffer[page++];
-				msblk->stream.avail_out = PAGE_CACHE_SIZE;
-			}
-
-			if (!zlib_init) {
-				zlib_err = zlib_inflateInit(&msblk->stream);
-				if (zlib_err != Z_OK) {
-					ERROR("zlib_inflateInit returned"
-						" unexpected result 0x%x,"
-						" srclength %d\n", zlib_err,
-						srclength);
-					goto release_mutex;
-				}
-				zlib_init = 1;
-			}
-
-			zlib_err = zlib_inflate(&msblk->stream, Z_SYNC_FLUSH);
-
-			if (msblk->stream.avail_in == 0 && k < b)
-				put_bh(bh[k++]);
-		} while (zlib_err == Z_OK);
-
-		if (zlib_err != Z_STREAM_END) {
-			ERROR("zlib_inflate error, data probably corrupt\n");
-			goto release_mutex;
-		}
-
-		zlib_err = zlib_inflateEnd(&msblk->stream);
-		if (zlib_err != Z_OK) {
-			ERROR("zlib_inflate error, data probably corrupt\n");
-			goto release_mutex;
-		}
-		length = msblk->stream.total_out;
-		mutex_unlock(&msblk->read_data_mutex);
+		length = squashfs_decompress(msblk, buffer, bh, b, offset,
+			length, srclength, pages);
+		if (length < 0)
+			goto read_failure;
 	} else {
 		/*
 		 * Block is uncompressed.
@@ -255,9 +191,6 @@
 	kfree(bh);
 	return length;
 
-release_mutex:
-	mutex_unlock(&msblk->read_data_mutex);
-
 block_release:
 	for (; k < b; k++)
 		put_bh(bh[k]);
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/cache.c linux-2.6.30.9-rsdk/fs/squashfs/cache.c
--- linux-2.6.30.9/fs/squashfs/cache.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/cache.c	2011-12-05 15:50:14.000000000 +0000
@@ -51,7 +51,6 @@
 #include <linux/sched.h>
 #include <linux/spinlock.h>
 #include <linux/wait.h>
-#include <linux/zlib.h>
 #include <linux/pagemap.h>
 
 #include "squashfs_fs.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/dir.c linux-2.6.30.9-rsdk/fs/squashfs/dir.c
--- linux-2.6.30.9/fs/squashfs/dir.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/dir.c	2011-12-05 15:50:14.000000000 +0000
@@ -30,7 +30,6 @@
 #include <linux/fs.h>
 #include <linux/vfs.h>
 #include <linux/slab.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/export.c linux-2.6.30.9-rsdk/fs/squashfs/export.c
--- linux-2.6.30.9/fs/squashfs/export.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/export.c	2011-12-05 15:50:14.000000000 +0000
@@ -39,7 +39,6 @@
 #include <linux/vfs.h>
 #include <linux/dcache.h>
 #include <linux/exportfs.h>
-#include <linux/zlib.h>
 #include <linux/slab.h>
 
 #include "squashfs_fs.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/file.c linux-2.6.30.9-rsdk/fs/squashfs/file.c
--- linux-2.6.30.9/fs/squashfs/file.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/file.c	2011-12-05 15:50:14.000000000 +0000
@@ -47,7 +47,6 @@
 #include <linux/string.h>
 #include <linux/pagemap.h>
 #include <linux/mutex.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/fragment.c linux-2.6.30.9-rsdk/fs/squashfs/fragment.c
--- linux-2.6.30.9/fs/squashfs/fragment.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/fragment.c	2011-12-05 15:50:14.000000000 +0000
@@ -36,7 +36,6 @@
 #include <linux/fs.h>
 #include <linux/vfs.h>
 #include <linux/slab.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/id.c linux-2.6.30.9-rsdk/fs/squashfs/id.c
--- linux-2.6.30.9/fs/squashfs/id.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/id.c	2011-12-05 15:50:14.000000000 +0000
@@ -34,7 +34,6 @@
 #include <linux/fs.h>
 #include <linux/vfs.h>
 #include <linux/slab.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/inode.c linux-2.6.30.9-rsdk/fs/squashfs/inode.c
--- linux-2.6.30.9/fs/squashfs/inode.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/inode.c	2011-12-05 15:50:14.000000000 +0000
@@ -40,7 +40,6 @@
 
 #include <linux/fs.h>
 #include <linux/vfs.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/Kconfig linux-2.6.30.9-rsdk/fs/squashfs/Kconfig
--- linux-2.6.30.9/fs/squashfs/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -26,6 +26,12 @@
 
 	  If unsure, say N.
 
+config SQUASHFS_LZMA
+	bool "Include support for LZMA compressed file systems"
+	depends on SQUASHFS
+	select DECOMPRESS_LZMA
+	select DECOMPRESS_LZMA_NEEDED
+
 config SQUASHFS_EMBEDDED
 
 	bool "Additional option for memory-constrained systems" 
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/Makefile linux-2.6.30.9-rsdk/fs/squashfs/Makefile
--- linux-2.6.30.9/fs/squashfs/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -4,4 +4,5 @@
 
 obj-$(CONFIG_SQUASHFS) += squashfs.o
 squashfs-y += block.o cache.o dir.o export.o file.o fragment.o id.o inode.o
-squashfs-y += namei.o super.o symlink.o
+squashfs-y += namei.o super.o symlink.o zlib_wrapper.o decompressor.o
+squashfs-$(CONFIG_SQUASHFS_LZMA) += lzma_wrapper.o
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/namei.c linux-2.6.30.9-rsdk/fs/squashfs/namei.c
--- linux-2.6.30.9/fs/squashfs/namei.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/namei.c	2011-12-05 15:50:14.000000000 +0000
@@ -57,7 +57,6 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/dcache.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/squashfs_fs.h linux-2.6.30.9-rsdk/fs/squashfs/squashfs_fs.h
--- linux-2.6.30.9/fs/squashfs/squashfs_fs.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/squashfs_fs.h	2011-12-05 15:50:14.000000000 +0000
@@ -212,6 +212,8 @@
  * definitions for structures on disk
  */
 #define ZLIB_COMPRESSION	 1
+#define LZMA_COMPRESSION	2
+#define LZO_COMPRESSION		3
 
 struct squashfs_super_block {
 	__le32			s_magic;
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/squashfs_fs_sb.h linux-2.6.30.9-rsdk/fs/squashfs/squashfs_fs_sb.h
--- linux-2.6.30.9/fs/squashfs/squashfs_fs_sb.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/squashfs_fs_sb.h	2011-12-05 15:50:14.000000000 +0000
@@ -52,6 +52,7 @@
 };
 
 struct squashfs_sb_info {
+	const struct squashfs_decompressor	*decompressor;
 	int			devblksize;
 	int			devblksize_log2;
 	struct squashfs_cache	*block_cache;
@@ -64,7 +65,7 @@
 	struct mutex		read_data_mutex;
 	struct mutex		meta_index_mutex;
 	struct meta_index	*meta_index;
-	z_stream		stream;
+	void					*stream;
 	__le64			*inode_lookup_table;
 	u64			inode_table;
 	u64			directory_table;
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/squashfs.h linux-2.6.30.9-rsdk/fs/squashfs/squashfs.h
--- linux-2.6.30.9/fs/squashfs/squashfs.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/squashfs.h	2011-12-05 15:50:14.000000000 +0000
@@ -51,6 +51,9 @@
 				u64, int);
 extern int squashfs_read_table(struct super_block *, void *, u64, int);
 
+/* decompressor.c */
+extern const struct squashfs_decompressor *squashfs_lookup_decompressor(int);
+
 /* export.c */
 extern __le64 *squashfs_read_inode_lookup_table(struct super_block *, u64,
 				unsigned int);
@@ -71,7 +74,7 @@
 extern int squashfs_read_inode(struct inode *, long long);
 
 /*
- * Inodes and files operations
+ * Inodes, files and decompressor operations
  */
 
 /* dir.c */
@@ -88,3 +91,9 @@
 
 /* symlink.c */
 extern const struct address_space_operations squashfs_symlink_aops;
+
+/* zlib_wrapper.c */
+extern const struct squashfs_decompressor squashfs_zlib_comp_ops;
+
+/* lzma wrapper.c */
+extern const struct squashfs_decompressor squashfs_lzma_comp_ops;
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/super.c linux-2.6.30.9-rsdk/fs/squashfs/super.c
--- linux-2.6.30.9/fs/squashfs/super.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/super.c	2011-12-05 15:50:14.000000000 +0000
@@ -30,38 +30,46 @@
 #include <linux/fs.h>
 #include <linux/vfs.h>
 #include <linux/slab.h>
+#include <linux/smp_lock.h>
 #include <linux/mutex.h>
 #include <linux/pagemap.h>
 #include <linux/init.h>
 #include <linux/module.h>
-#include <linux/zlib.h>
 #include <linux/magic.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
 #include "squashfs_fs_i.h"
 #include "squashfs.h"
+#include "decompressor.h"
 
 static struct file_system_type squashfs_fs_type;
-static struct super_operations squashfs_super_ops;
+static const struct super_operations squashfs_super_ops;
 
-static int supported_squashfs_filesystem(short major, short minor, short comp)
+static const struct squashfs_decompressor *supported_squashfs_filesystem(short
+	major, short minor, short id)
 {
+	const struct squashfs_decompressor *decompressor;
+
 	if (major < SQUASHFS_MAJOR) {
 		ERROR("Major/Minor mismatch, older Squashfs %d.%d "
 			"filesystems are unsupported\n", major, minor);
-		return -EINVAL;
+		return NULL;
 	} else if (major > SQUASHFS_MAJOR || minor > SQUASHFS_MINOR) {
 		ERROR("Major/Minor mismatch, trying to mount newer "
 			"%d.%d filesystem\n", major, minor);
 		ERROR("Please update your kernel\n");
-		return -EINVAL;
+		return NULL;
 	}
 
-	if (comp != ZLIB_COMPRESSION)
-		return -EINVAL;
+	decompressor = squashfs_lookup_decompressor(id);
+	if (!decompressor->supported) {
+		ERROR("Filesystem uses \"%s\" compression. This is not "
+			"supported\n", decompressor->name);
+		return NULL;
+	}
 
-	return 0;
+	return decompressor;
 }
 
 
@@ -86,13 +94,6 @@
 	}
 	msblk = sb->s_fs_info;
 
-	msblk->stream.workspace = kmalloc(zlib_inflate_workspacesize(),
-		GFP_KERNEL);
-	if (msblk->stream.workspace == NULL) {
-		ERROR("Failed to allocate zlib workspace\n");
-		goto failure;
-	}
-
 	sblk = kzalloc(sizeof(*sblk), GFP_KERNEL);
 	if (sblk == NULL) {
 		ERROR("Failed to allocate squashfs_super_block\n");
@@ -119,25 +120,25 @@
 		goto failed_mount;
 	}
 
+	err = -EINVAL;
+
 	/* Check it is a SQUASHFS superblock */
 	sb->s_magic = le32_to_cpu(sblk->s_magic);
 	if (sb->s_magic != SQUASHFS_MAGIC) {
 		if (!silent)
 			ERROR("Can't find a SQUASHFS superblock on %s\n",
 						bdevname(sb->s_bdev, b));
-		err = -EINVAL;
 		goto failed_mount;
 	}
 
-	/* Check the MAJOR & MINOR versions and compression type */
-	err = supported_squashfs_filesystem(le16_to_cpu(sblk->s_major),
+	/* Check the MAJOR & MINOR versions and lookup compression type */
+	msblk->decompressor = supported_squashfs_filesystem(
+			le16_to_cpu(sblk->s_major),
 			le16_to_cpu(sblk->s_minor),
 			le16_to_cpu(sblk->compression));
-	if (err < 0)
+	if (msblk->decompressor == NULL)
 		goto failed_mount;
 
-	err = -EINVAL;
-
 	/*
 	 * Check if there's xattrs in the filesystem.  These are not
 	 * supported in this version, so warn that they will be ignored.
@@ -204,6 +205,10 @@
 
 	err = -ENOMEM;
 
+	msblk->stream = squashfs_decompressor_init(msblk);
+	if (msblk->stream == NULL)
+		goto failed_mount;
+
 	msblk->block_cache = squashfs_cache_init("metadata",
 			SQUASHFS_CACHED_BLKS, SQUASHFS_METADATA_SIZE);
 	if (msblk->block_cache == NULL)
@@ -291,17 +296,16 @@
 	squashfs_cache_delete(msblk->block_cache);
 	squashfs_cache_delete(msblk->fragment_cache);
 	squashfs_cache_delete(msblk->read_page);
+	squashfs_decompressor_free(msblk, msblk->stream);
 	kfree(msblk->inode_lookup_table);
 	kfree(msblk->fragment_index);
 	kfree(msblk->id_table);
-	kfree(msblk->stream.workspace);
 	kfree(sb->s_fs_info);
 	sb->s_fs_info = NULL;
 	kfree(sblk);
 	return err;
 
 failure:
-	kfree(msblk->stream.workspace);
 	kfree(sb->s_fs_info);
 	sb->s_fs_info = NULL;
 	return -ENOMEM;
@@ -338,18 +342,22 @@
 
 static void squashfs_put_super(struct super_block *sb)
 {
+	lock_kernel();
+
 	if (sb->s_fs_info) {
 		struct squashfs_sb_info *sbi = sb->s_fs_info;
 		squashfs_cache_delete(sbi->block_cache);
 		squashfs_cache_delete(sbi->fragment_cache);
 		squashfs_cache_delete(sbi->read_page);
+		squashfs_decompressor_free(sbi, sbi->stream);
 		kfree(sbi->id_table);
 		kfree(sbi->fragment_index);
 		kfree(sbi->meta_index);
-		kfree(sbi->stream.workspace);
 		kfree(sb->s_fs_info);
 		sb->s_fs_info = NULL;
 	}
+
+	unlock_kernel();
 }
 
 
@@ -439,7 +447,7 @@
 	.fs_flags = FS_REQUIRES_DEV
 };
 
-static struct super_operations squashfs_super_ops = {
+static const struct super_operations squashfs_super_ops = {
 	.alloc_inode = squashfs_alloc_inode,
 	.destroy_inode = squashfs_destroy_inode,
 	.statfs = squashfs_statfs,
diff -uNr --ignore-all-space linux-2.6.30.9/fs/squashfs/symlink.c linux-2.6.30.9-rsdk/fs/squashfs/symlink.c
--- linux-2.6.30.9/fs/squashfs/symlink.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/fs/squashfs/symlink.c	2011-12-05 15:50:14.000000000 +0000
@@ -36,7 +36,6 @@
 #include <linux/slab.h>
 #include <linux/string.h>
 #include <linux/pagemap.h>
-#include <linux/zlib.h>
 
 #include "squashfs_fs.h"
 #include "squashfs_fs_sb.h"
diff -uNr --ignore-all-space linux-2.6.30.9/include/asm-generic/bitops/sched.h linux-2.6.30.9-rsdk/include/asm-generic/bitops/sched.h
--- linux-2.6.30.9/include/asm-generic/bitops/sched.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/asm-generic/bitops/sched.h	2011-12-05 15:50:14.000000000 +0000
@@ -11,11 +11,6 @@
  */
 static inline int sched_find_first_bit(const unsigned long *b)
 {
-#if BITS_PER_LONG == 64
-	if (b[0])
-		return __ffs(b[0]);
-	return __ffs(b[1]) + 64;
-#elif BITS_PER_LONG == 32
 	if (b[0])
 		return __ffs(b[0]);
 	if (b[1])
@@ -23,9 +18,6 @@
 	if (b[2])
 		return __ffs(b[2]) + 64;
 	return __ffs(b[3]) + 96;
-#else
-#error BITS_PER_LONG not defined
-#endif
 }
 
 #endif /* _ASM_GENERIC_BITOPS_SCHED_H_ */
diff -uNr --ignore-all-space linux-2.6.30.9/include/asm-generic/int-ll64.h linux-2.6.30.9-rsdk/include/asm-generic/int-ll64.h
--- linux-2.6.30.9/include/asm-generic/int-ll64.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/asm-generic/int-ll64.h	2011-12-05 15:50:14.000000000 +0000
@@ -8,6 +8,8 @@
 #ifndef _ASM_GENERIC_INT_LL64_H
 #define _ASM_GENERIC_INT_LL64_H
 
+#include <asm-generic/bitsperlong.h>
+
 #ifndef __ASSEMBLY__
 /*
  * __xx is ok: it doesn't pollute the POSIX namespace. Use these in the
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/crypto.h linux-2.6.30.9-rsdk/include/linux/crypto.h
--- linux-2.6.30.9/include/linux/crypto.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/crypto.h	2011-12-05 15:50:14.000000000 +0000
@@ -367,7 +367,22 @@
 /*
  * Algorithm query interface.
  */
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#ifdef CONFIG_CRYPTO
+int crypto_alg_available(const char *name, u32 flags)
+       __deprecated_for_modules;
 int crypto_has_alg(const char *name, u32 type, u32 mask);
+#else
+static int crypto_alg_available(const char *name, u32 flags)
+       __deprecated_for_modules;
+static inline int crypto_has_alg(const char *name, u32 type, u32 mask)
+{
+       return 0;
+}
+#endif
+#else
+int crypto_has_alg(const char *name, u32 type, u32 mask);
+#endif
 
 /*
  * Transforms: user-instantiated objects which encapsulate algorithms
@@ -1173,6 +1188,18 @@
 						dst, src);
 }
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+void crypto_digest_init(struct crypto_tfm *tfm) __deprecated_for_modules;
+void crypto_digest_update(struct crypto_tfm *tfm,
+                         struct scatterlist *sg, unsigned int nsg)
+       __deprecated_for_modules;
+void crypto_digest_final(struct crypto_tfm *tfm, u8 *out)
+       __deprecated_for_modules;
+void crypto_digest_digest(struct crypto_tfm *tfm,
+                         struct scatterlist *sg, unsigned int nsg, u8 *out)
+       __deprecated_for_modules;
+#endif
+
 static inline struct crypto_hash *__crypto_hash_cast(struct crypto_tfm *tfm)
 {
 	return (struct crypto_hash *)tfm;
@@ -1185,6 +1212,16 @@
 	return __crypto_hash_cast(tfm);
 }
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+static int crypto_digest_setkey(struct crypto_tfm *tfm, const u8 *key,
+                               unsigned int keylen) __deprecated;
+static inline int crypto_digest_setkey(struct crypto_tfm *tfm,
+                                       const u8 *key, unsigned int keylen)
+{
+       return tfm->crt_hash.setkey(crypto_hash_cast(tfm), key, keylen);
+}
+#endif
+
 static inline struct crypto_hash *crypto_alloc_hash(const char *alg_name,
 						    u32 type, u32 mask)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/decompress/mm.h linux-2.6.30.9-rsdk/include/linux/decompress/mm.h
--- linux-2.6.30.9/include/linux/decompress/mm.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/decompress/mm.h	2011-12-05 15:50:14.000000000 +0000
@@ -53,8 +53,6 @@
 
 #define set_error_fn(x)
 
-#define INIT
-
 #else /* STATIC */
 
 /* Code active when compiled standalone for use when loading ramdisk: */
@@ -77,7 +75,6 @@
 static void(*error)(char *m);
 #define set_error_fn(x) error = x;
 
-#define INIT __init
 #define STATIC
 
 #include <linux/init.h>
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/gfp.h linux-2.6.30.9-rsdk/include/linux/gfp.h
--- linux-2.6.30.9/include/linux/gfp.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/gfp.h	2011-12-05 15:50:14.000000000 +0000
@@ -5,6 +5,7 @@
 #include <linux/stddef.h>
 #include <linux/linkage.h>
 #include <linux/topology.h>
+#include <linux/mmdebug.h>
 
 struct vm_area_struct;
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/hardirq.h linux-2.6.30.9-rsdk/include/linux/hardirq.h
--- linux-2.6.30.9/include/linux/hardirq.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/hardirq.h	2011-12-05 15:50:14.000000000 +0000
@@ -2,7 +2,9 @@
 #define LINUX_HARDIRQ_H
 
 #include <linux/preempt.h>
+#ifdef CONFIG_PREEMPT
 #include <linux/smp_lock.h>
+#endif
 #include <linux/lockdep.h>
 #include <linux/ftrace_irq.h>
 #include <asm/hardirq.h>
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/if_bridge.h linux-2.6.30.9-rsdk/include/linux/if_bridge.h
--- linux-2.6.30.9/include/linux/if_bridge.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/if_bridge.h	2011-12-05 15:50:14.000000000 +0000
@@ -49,6 +49,16 @@
 #define BR_STATE_FORWARDING 3
 #define BR_STATE_BLOCKING 4
 
+#if defined CONFIG_RTK_MESH
+//brian
+#define BRCTL_SET_MESH_PATHSELPID 111
+#define BRCTL_GET_PORTSTAT 112
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#define BRCTL_SET_IGMPPROXY_PID 200
+#endif
+
 struct __bridge_info
 {
 	__u64 designated_root;
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/in.h linux-2.6.30.9-rsdk/include/linux/in.h
--- linux-2.6.30.9/include/linux/in.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/in.h	2011-12-05 15:50:14.000000000 +0000
@@ -251,6 +251,17 @@
 #include <asm/byteorder.h> 
 
 #ifdef __KERNEL__
+/* Some random defines to make it easier in the kernel.. */
+#define LOOPBACK(x)	(((x) & htonl(0xff000000)) == htonl(0x7f000000))
+#define MULTICAST(x)	(((x) & htonl(0xf0000000)) == htonl(0xe0000000))
+#define BADCLASS(x)	(((x) & htonl(0xf0000000)) == htonl(0xf0000000))
+#define ZERONET(x)	(((x) & htonl(0xff000000)) == htonl(0x00000000))
+#define LOCAL_MCAST(x)	(((x) & htonl(0xFFFFFF00)) == htonl(0xE0000000))
+
+#endif
+
+
+#ifdef __KERNEL__
 
 static inline bool ipv4_is_loopback(__be32 addr)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/irqflags.h linux-2.6.30.9-rsdk/include/linux/irqflags.h
--- linux-2.6.30.9/include/linux/irqflags.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/irqflags.h	2011-12-05 15:50:14.000000000 +0000
@@ -12,6 +12,7 @@
 #define _LINUX_TRACE_IRQFLAGS_H
 
 #include <linux/typecheck.h>
+#include <asm/irqflags.h>
 
 #ifdef CONFIG_TRACE_IRQFLAGS
   extern void trace_softirqs_on(unsigned long ip);
@@ -52,10 +53,7 @@
 # define start_critical_timings() do { } while (0)
 #endif
 
-#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT
-
-#include <asm/irqflags.h>
-
+#if defined(CONFIG_TRACE_IRQFLAGS_SUPPORT)
 #define local_irq_enable() \
 	do { trace_hardirqs_on(); raw_local_irq_enable(); } while (0)
 #define local_irq_disable() \
@@ -84,6 +82,7 @@
  * The local_irq_*() APIs are equal to the raw_local_irq*()
  * if !TRACE_IRQFLAGS.
  */
+ #if 0
 # define raw_local_irq_disable()	local_irq_disable()
 # define raw_local_irq_enable()		local_irq_enable()
 # define raw_local_irq_save(flags)			\
@@ -96,9 +95,32 @@
 		typecheck(unsigned long, flags);	\
 		local_irq_restore(flags);		\
 	} while (0)
+#endif
+
+#define local_irq_enable() \
+	do { raw_local_irq_enable(); } while (0)
+#define local_irq_disable() \
+	do { raw_local_irq_disable();} while (0)
+#define local_irq_save(flags)				\
+	do {					\
+		typecheck(unsigned long, flags);	\
+		raw_local_irq_save(flags);	\
+	} while (0)
+
+
+#define local_irq_restore(flags)			\
+	do {						\
+		typecheck(unsigned long, flags);	\
+		if (raw_irqs_disabled_flags(flags)) {	\
+			raw_local_irq_restore(flags);	\
+		} else {				\
+			raw_local_irq_restore(flags);	\
+		}					\
+	} while (0)
+
 #endif /* CONFIG_TRACE_IRQFLAGS_SUPPORT */
 
-#ifdef CONFIG_TRACE_IRQFLAGS_SUPPORT
+#if defined(CONFIG_TRACE_IRQFLAGS_SUPPORT)
 #define safe_halt()						\
 	do {							\
 		trace_hardirqs_on();				\
@@ -124,6 +146,31 @@
 	typecheck(unsigned long, flags);	\
 	raw_irqs_disabled_flags(flags);		\
 })
-#endif		/* CONFIG_X86 */
+#elif defined(CONFIG_RTL_819X)
+#define safe_halt()						\
+	do {							\
+		raw_safe_halt();				\
+	} while (0)
+
+#define local_save_flags(flags)				\
+	do {						\
+		typecheck(unsigned long, flags);	\
+		raw_local_save_flags(flags);		\
+	} while (0)
+
+#define irqs_disabled()						\
+({								\
+	unsigned long _flags;					\
+								\
+	raw_local_save_flags(_flags);				\
+	raw_irqs_disabled_flags(_flags);			\
+})
+
+#define irqs_disabled_flags(flags)		\
+({						\
+	typecheck(unsigned long, flags);	\
+	raw_irqs_disabled_flags(flags);		\
+})
+#endif
 
 #endif
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/irq.h linux-2.6.30.9-rsdk/include/linux/irq.h
--- linux-2.6.30.9/include/linux/irq.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/irq.h	2011-12-05 15:50:14.000000000 +0000
@@ -205,7 +205,9 @@
 extern void arch_free_chip_data(struct irq_desc *old_desc, struct irq_desc *desc);
 
 #ifndef CONFIG_SPARSE_IRQ
+#if !defined(CONFIG_RTL_819X)
 extern struct irq_desc irq_desc[NR_IRQS];
+#endif
 #else /* CONFIG_SPARSE_IRQ */
 extern struct irq_desc *move_irq_desc(struct irq_desc *old_desc, int cpu);
 #endif /* CONFIG_SPARSE_IRQ */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/jiffies.h linux-2.6.30.9-rsdk/include/linux/jiffies.h
--- linux-2.6.30.9/include/linux/jiffies.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/jiffies.h	2011-12-05 15:50:14.000000000 +0000
@@ -71,7 +71,11 @@
  * but that can only take up to, say, 4-byte variables. jiffies being part of
  * an 8-byte variable may not be correctly accessed unless we force the issue
  */
+ #if defined(CONFIG_RTL_819X)
+ #define __jiffy_data  __attribute__((section(".dram-gen")))
+ #else
 #define __jiffy_data  __attribute__((section(".data")))
+#endif
 
 /*
  * The 64-bit value is not atomic - you MUST NOT read it
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/kernel.h linux-2.6.30.9-rsdk/include/linux/kernel.h
--- linux-2.6.30.9/include/linux/kernel.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/kernel.h	2011-12-05 15:50:14.000000000 +0000
@@ -232,11 +232,16 @@
 #define FW_WARN		"[Firmware Warn]: "
 #define FW_INFO		"[Firmware Info]: "
 
-#ifdef CONFIG_PRINTK
+#if defined(CONFIG_PRINTK) || defined(CONFIG_PANIC_PRINTK)
 asmlinkage int vprintk(const char *fmt, va_list args)
 	__attribute__ ((format (printf, 1, 0)));
+#endif
+
+#ifdef CONFIG_PRINTK
 asmlinkage int printk(const char * fmt, ...)
 	__attribute__ ((format (printf, 1, 2))) __cold;
+asmlinkage int panic_printk(const char * fmt, ...)
+	__attribute__ ((format (printf, 1, 2))) __cold;
 
 extern struct ratelimit_state printk_ratelimit_state;
 extern int printk_ratelimit(void);
@@ -257,11 +262,15 @@
 
 void log_buf_kexec_setup(void);
 #else
+#if !defined(CONFIG_PANIC_PRINTK)
 static inline int vprintk(const char *s, va_list args)
 	__attribute__ ((format (printf, 1, 0)));
 static inline int vprintk(const char *s, va_list args) { return 0; }
+#endif
 static inline int printk(const char *s, ...)
 	__attribute__ ((format (printf, 1, 2)));
+asmlinkage int panic_printk(const char * fmt, ...)
+	__attribute__ ((format (printf, 1, 2))) __cold;
 static inline int __cold printk(const char *s, ...) { return 0; }
 static inline int printk_ratelimit(void) { return 0; }
 static inline bool printk_timed_ratelimit(unsigned long *caller_jiffies, \
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/major.h linux-2.6.30.9-rsdk/include/linux/major.h
--- linux-2.6.30.9/include/linux/major.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/major.h	2011-12-05 15:50:14.000000000 +0000
@@ -54,6 +54,7 @@
 #define ACSI_MAJOR		28
 #define AZTECH_CDROM_MAJOR	29
 #define FB_MAJOR		29   /* /dev/fb* framebuffers */
+#define MTDBLK_MAJOR      31  /*/dev/mtdblock*/
 #define CM206_CDROM_MAJOR	32
 #define IDE2_MAJOR		33
 #define IDE3_MAJOR		34
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/mm.h linux-2.6.30.9-rsdk/include/linux/mm.h
--- linux-2.6.30.9/include/linux/mm.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/mm.h	2011-12-05 15:50:14.000000000 +0000
@@ -7,7 +7,6 @@
 
 #include <linux/gfp.h>
 #include <linux/list.h>
-#include <linux/mmdebug.h>
 #include <linux/mmzone.h>
 #include <linux/rbtree.h>
 #include <linux/prio_tree.h>
@@ -823,8 +822,12 @@
 extern int make_pages_present(unsigned long addr, unsigned long end);
 extern int access_process_vm(struct task_struct *tsk, unsigned long addr, void *buf, int len, int write);
 
-int get_user_pages(struct task_struct *tsk, struct mm_struct *mm, unsigned long start,
-		int len, int write, int force, struct page **pages, struct vm_area_struct **vmas);
+int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
+            unsigned long start, int nr_pages, int write, int force,
+            struct page **pages, struct vm_area_struct **vmas);
+int get_user_pages_fast(unsigned long start, int nr_pages, int write,
+            struct page **pages);
+
 
 extern int try_to_release_page(struct page * page, gfp_t gfp_mask);
 extern void do_invalidatepage(struct page *page, unsigned long offset);
@@ -849,16 +852,9 @@
 			  unsigned long end, unsigned long newflags);
 
 /*
- * get_user_pages_fast provides equivalent functionality to get_user_pages,
- * operating on current and current->mm (force=0 and doesn't return any vmas).
- *
- * get_user_pages_fast may take mmap_sem and page tables, so no assumptions
- * can be made about locking. get_user_pages_fast is to be implemented in a
- * way that is advantageous (vs get_user_pages()) when the user memory area is
- * already faulted in and present in ptes. However if the pages have to be
- * faulted in, it may turn out to be slightly slower).
+ * doesn't attempt to fault and will return short.
  */
-int get_user_pages_fast(unsigned long start, int nr_pages, int write,
+int __get_user_pages_fast(unsigned long start, int nr_pages, int write,
 			struct page **pages);
 
 /*
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/mmzone.h linux-2.6.30.9-rsdk/include/linux/mmzone.h
--- linux-2.6.30.9/include/linux/mmzone.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/mmzone.h	2011-12-05 15:50:14.000000000 +0000
@@ -86,13 +86,8 @@
 	NR_ACTIVE_ANON,		/*  "     "     "   "       "         */
 	NR_INACTIVE_FILE,	/*  "     "     "   "       "         */
 	NR_ACTIVE_FILE,		/*  "     "     "   "       "         */
-#ifdef CONFIG_UNEVICTABLE_LRU
 	NR_UNEVICTABLE,		/*  "     "     "   "       "         */
 	NR_MLOCK,		/* mlock()ed pages found and moved off LRU */
-#else
-	NR_UNEVICTABLE = NR_ACTIVE_FILE, /* avoid compiler errors in dead code */
-	NR_MLOCK = NR_ACTIVE_FILE,
-#endif
 	NR_ANON_PAGES,	/* Mapped anonymous pages */
 	NR_FILE_MAPPED,	/* pagecache pages mapped into pagetables.
 			   only modified from process context */
@@ -135,11 +130,7 @@
 	LRU_ACTIVE_ANON = LRU_BASE + LRU_ACTIVE,
 	LRU_INACTIVE_FILE = LRU_BASE + LRU_FILE,
 	LRU_ACTIVE_FILE = LRU_BASE + LRU_FILE + LRU_ACTIVE,
-#ifdef CONFIG_UNEVICTABLE_LRU
 	LRU_UNEVICTABLE,
-#else
-	LRU_UNEVICTABLE = LRU_ACTIVE_FILE, /* avoid compiler errors in dead code */
-#endif
 	NR_LRU_LISTS
 };
 
@@ -159,11 +150,7 @@
 
 static inline int is_unevictable_lru(enum lru_list l)
 {
-#ifdef CONFIG_UNEVICTABLE_LRU
 	return (l == LRU_UNEVICTABLE);
-#else
-	return 0;
-#endif
 }
 
 struct per_cpu_pages {
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/mroute.h linux-2.6.30.9-rsdk/include/linux/mroute.h
--- linux-2.6.30.9/include/linux/mroute.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/mroute.h	2011-12-05 15:50:14.000000000 +0000
@@ -198,6 +198,9 @@
 #endif
 	__be32 mfc_mcastgrp;			/* Group the entry belongs to 	*/
 	__be32 mfc_origin;			/* Source of packet 		*/
+	#if defined (CONFIG_RTL_IGMP_PROXY)
+	__u32 mfc_firstone;
+	#endif
 	vifi_t mfc_parent;			/* Source interface		*/
 	int mfc_flags;				/* Flags on line		*/
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/mtd/mtd.h linux-2.6.30.9-rsdk/include/linux/mtd/mtd.h
--- linux-2.6.30.9/include/linux/mtd/mtd.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/mtd/mtd.h	2011-12-05 15:50:14.000000000 +0000
@@ -343,5 +343,127 @@
 	} while(0)
 
 #endif /* CONFIG_MTD_DEBUG */
+/*****************************************************************************/
+/*
+*          Added by alva_zhang
+*/
+/*****************************************************************************/
+
+__asm__ (
+	".macro\t__sti\n\t"
+	".set\tpush\n\t"
+	".set\treorder\n\t"
+	".set\tnoat\n\t"
+	"mfc0\t$1,$12\n\t"
+	"ori\t$1,0x1f\n\t"
+	"xori\t$1,0x1e\n\t"
+	"mtc0\t$1,$12\n\t"
+	".set\tpop\n\t"
+	".endm");
+
+extern __inline__ void
+mtd_sti(void)
+{
+	__asm__ __volatile__(
+		"__sti"
+		: /* no outputs */
+		: /* no inputs */
+		: "memory");
+}
+
+/*
+ * For cli() we have to insert nops to make sure that the new value
+ * has actually arrived in the status register before the end of this
+ * macro.
+ * R4000/R4400 need three nops, the R4600 two nops and the R10000 needs
+ * no nops at all.
+ */
+__asm__ (
+	".macro\t__cli\n\t"
+	".set\tpush\n\t"
+	".set\tnoat\n\t"
+	"mfc0\t$1,$12\n\t"
+	"ori\t$1,1\n\t"
+	"xori\t$1,1\n\t"
+	".set\tnoreorder\n\t"
+	"mtc0\t$1,$12\n\t"
+	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	".set\tpop\n\t"
+	".endm");
+
+extern __inline__ void
+mtd_cli(void)
+{
+	__asm__ __volatile__(
+		"__cli"
+		: /* no outputs */
+		: /* no inputs */
+		: "memory");
+}
+
+__asm__ (
+	".macro\t__save_flags flags\n\t"
+	".set\tpush\n\t"
+	".set\treorder\n\t"
+	"mfc0\t\\flags, $12\n\t"
+	".set\tpop\n\t"
+	".endm");
+
+#define mtd_save_flags(x)			\
+__asm__ __volatile__(					\
+	"__save_flags %0"					\
+	: "=r" (x))
+
+__asm__ (
+	".macro\t__save_and_cli result\n\t"
+	".set\tpush\n\t"
+	".set\treorder\n\t"
+	".set\tnoat\n\t"
+	"mfc0\t\\result, $12\n\t"
+	"ori\t$1, \\result, 1\n\t"
+	"xori\t$1, 1\n\t"
+	".set\tnoreorder\n\t"
+	"mtc0\t$1, $12\n\t"
+	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	"sll\t$0, $0, 1\t\t\t# nop\n\t"
+	".set\tpop\n\t"	
+	".endm");
+
+#define mtd_save_and_cli(x)						\
+__asm__ __volatile__(							\
+	"__save_and_cli\t%0"						\
+	: "=r" (x)							\
+	: /* no inputs */						\
+	: "memory")
+
+__asm__(".macro\t__restore_flags flags\n\t"
+	".set\tnoreorder\n\t"
+	".set\tnoat\n\t"
+	"mfc0\t$1, $12\n\t"
+	"andi\t\\flags, 1\n\t"
+	"ori\t$1, 1\n\t"
+	"xori\t$1, 1\n\t"
+	"or\t\\flags, $1\n\t"
+	"mtc0\t\\flags, $12\n\t"
+	"nop\n\t"
+	"nop\n\t"
+	"nop\n\t"
+	".set\tat\n\t"
+	".set\treorder\n\t"
+	".endm");
+
+#define mtd_restore_flags(flags)						\
+do {									\
+	unsigned long __tmp1;						\
+									\
+	__asm__ __volatile__(						\
+		"__restore_flags\t%0"					\
+		: "=r" (__tmp1)						\
+		: "0" (flags)						\
+		: "memory");						\
+} while(0)
 
 #endif /* __MTD_MTD_H__ */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netdevice.h linux-2.6.30.9-rsdk/include/linux/netdevice.h
--- linux-2.6.30.9/include/linux/netdevice.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netdevice.h	2011-12-05 15:50:14.000000000 +0000
@@ -75,7 +75,11 @@
 #define NET_RX_CN_MOD		3   /* Storm on its way! */
 #define NET_RX_CN_HIGH		4   /* The storm is here */
 #define NET_RX_BAD		5  /* packet dropped due to kernel error */
+#define NET_RX_PASSBY	6 /* packet pass by for next process */
 
+#if defined 	(CONFIG_RTL865X_LANPORT_RESTRICTION)	
+#define NET_RX_AUTH_BLOCK	6 
+#endif
 /* NET_XMIT_CN is special. It does not guarantee that this packet is lost. It
  * indicates that the device will soon be dropping packets, or already drops
  * some packets of the same priority; prompting us to send less aggressively. */
@@ -712,6 +716,7 @@
 	/* Instance data managed by the core of Wireless Extensions. */
 	struct iw_public_data *	wireless_data;
 #endif
+	void			*priv;	/* pointer to private data	*/
 	/* Management operations */
 	const struct net_device_ops *netdev_ops;
 	const struct ethtool_ops *ethtool_ops;
@@ -905,6 +910,12 @@
 #endif
 	};
 #endif
+
+	#if	defined(CONFIG_RTL_HARDWARE_NAT) || defined(CONFIG_RTL_HW_NAPT)
+	/*2007-12-19*/
+	int			wanif;
+	#endif
+
 };
 #define to_net_dev(d) container_of(d, struct net_device, dev)
 
@@ -1098,6 +1109,7 @@
 						  unsigned short mask);
 extern struct net_device	*dev_get_by_name(struct net *net, const char *name);
 extern struct net_device	*__dev_get_by_name(struct net *net, const char *name);
+extern int rtl865x_getDevIpAndNetmask(struct net_device * dev, unsigned int *ipAddr, unsigned int *netMask );
 extern int		dev_alloc_name(struct net_device *dev, const char *name);
 extern int		dev_open(struct net_device *dev);
 extern int		dev_close(struct net_device *dev);
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netfilter/nf_conntrack_common.h linux-2.6.30.9-rsdk/include/linux/netfilter/nf_conntrack_common.h
--- linux-2.6.30.9/include/linux/netfilter/nf_conntrack_common.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netfilter/nf_conntrack_common.h	2011-12-05 15:50:14.000000000 +0000
@@ -73,6 +73,13 @@
 	/* Connection has fixed timeout. */
 	IPS_FIXED_TIMEOUT_BIT = 10,
 	IPS_FIXED_TIMEOUT = (1 << IPS_FIXED_TIMEOUT_BIT),
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	/* Connection is bt session: identify for bt session */
+	IPS_BT_SESSION_BIT = 11,
+	IPS_BT_SESSION = (1 << IPS_BT_SESSION_BIT),
+#endif	
+
 };
 
 /* Connection tracking event bits */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netfilter/x_tables.h linux-2.6.30.9-rsdk/include/linux/netfilter/x_tables.h
--- linux-2.6.30.9/include/linux/netfilter/x_tables.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netfilter/x_tables.h	2011-12-05 15:50:14.000000000 +0000
@@ -5,6 +5,11 @@
 
 #define XT_FUNCTION_MAXNAMELEN 30
 #define XT_TABLE_MAXNAMELEN 32
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#define RTL865X_SKIP_THIS_RULE 0x8
+#define RTL865X_ESTABLISH_RULE 0x10
+#define RTL865X_MATCH_NOT_SUPPORTED 0xFFFF;
+#endif
 
 struct xt_entry_match
 {
@@ -292,6 +297,15 @@
 	void (*compat_from_user)(void *dst, void *src);
 	int (*compat_to_user)(void __user *dst, void *src);
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	int (*match2acl)(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *rule,
+			  unsigned int *invflag);
+#endif
+
 	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
 	struct module *me;
 
@@ -336,6 +350,16 @@
 	/* Set this to THIS_MODULE if you are a module, otherwise NULL */
 	struct module *me;
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	int (*target2acl)(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			 void *rule,
+			  unsigned int hook_mask, 
+			  void **data);
+#endif
+
 	const char *table;
 	unsigned int targetsize;
 	unsigned int compatsize;
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netfilter/xt_mac.h linux-2.6.30.9-rsdk/include/linux/netfilter/xt_mac.h
--- linux-2.6.30.9/include/linux/netfilter/xt_mac.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netfilter/xt_mac.h	2011-12-05 15:50:14.000000000 +0000
@@ -1,8 +1,20 @@
 #ifndef _XT_MAC_H
 #define _XT_MAC_H
 
+#define MAC_SRC		0x01	/* Match source MAC address */
+#define MAC_DST		0x02	/* Match destination MAC address */
+#define MAC_SRC_INV		0x10	/* Negate the condition */
+#define MAC_DST_INV		0x20	/* Negate the condition */
+
+struct xt_mac{
+    unsigned char macaddr[ETH_ALEN];
+};
+
 struct xt_mac_info {
-    unsigned char srcaddr[ETH_ALEN];
-    int invert;
+   struct xt_mac srcaddr;
+   struct xt_mac dstaddr;
+//    int invert;
+    u_int8_t flags;
 };
+
 #endif /*_XT_MAC_H*/
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netfilter_ipv4/ip_tables.h linux-2.6.30.9-rsdk/include/linux/netfilter_ipv4/ip_tables.h
--- linux-2.6.30.9/include/linux/netfilter_ipv4/ip_tables.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netfilter_ipv4/ip_tables.h	2011-12-05 15:50:14.000000000 +0000
@@ -73,6 +73,11 @@
 #define IPT_INV_PROTO		XT_INV_PROTO
 #define IPT_INV_MASK		0x7F	/* All possible flag bits mask. */
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+/* Values for special return value	*/
+#define	RTL_QOSFINDSPECIALNETIF		1
+#endif
+
 /* This structure defines each of the firewall rules.  Consists of 3
    parts which are 1) general IP header stuff 2) match specific
    stuff 3) the target to perform if the rule matches */
@@ -228,6 +233,25 @@
 	return (void *)e + e->target_offset;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+
+#define IPT_MATCH_NUMBER(e) \
+({					\
+	unsigned int __i;		\
+	int __ret = 0;			\
+	struct ipt_entry_match *__match;	\
+	for(__i = sizeof(struct ipt_entry);	\
+		__i < (e)->target_offset;		\
+		__i += __match->u.match_size)	\
+		{		\
+		__match = (void*)(e) + __i;		\
+		__ret++;		\
+		}		\
+		__ret;	\
+})
+
+#endif
+
 /* fn returns 0 to continue iteration */
 #define IPT_MATCH_ITERATE(e, fn, args...) \
 	XT_MATCH_ITERATE(struct ipt_entry, e, fn, ## args)
@@ -336,4 +360,37 @@
 
 #endif /* CONFIG_COMPAT */
 #endif /*__KERNEL__*/
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#define RTL865X_CHAINLIST_NUMBER_PER_TBL 5
+#define RTL865x_CHAINLIST_PRIORITY_LEVEL_0 0
+#define RTL865x_CHAINLIST_PRIORITY_LEVEL_1 1
+#define RTL865x_CHAINLIST_PRIORITY_LEVEL_2 2
+#define RTL865x_CHAINLIST_PRIORITY_LEVEL_3 3
+#define RTL865x_CHAINLIST_PRIORITY_LEVEL_4 4
+
+typedef struct _rtl865x_iptRule2Acl_tbl_
+{
+	struct list_head list;
+	/*chain list priority: 0 > 1 > ...> 4*/
+	struct list_head chainList[RTL865X_CHAINLIST_NUMBER_PER_TBL]; /*chain list head in this table*/
+	
+	int32_t priority; /*table priority*/
+	char tblName[32];
+}rtl865x_iptRule2Acl_tbl;
+//extern struct list_head rtl865x_iptRule2Acl_tbl_list;
+//extern struct list_head rtl865x_iptRule2Acl_def_rule_list;
+//extern struct list_head match_to_acl_rule_list;
+//extern struct list_head def_rule_list;
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+extern unsigned int (*IgmpRxFilter_Hook)(struct sk_buff *skb,
+	     unsigned int hook,
+	     const struct net_device *in,
+	     const struct net_device *out,
+	     struct xt_table *table);
+#endif
+
+
 #endif /* _IPTABLES_H */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netfilter_ipv4.h linux-2.6.30.9-rsdk/include/linux/netfilter_ipv4.h
--- linux-2.6.30.9/include/linux/netfilter_ipv4.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netfilter_ipv4.h	2011-12-05 15:50:14.000000000 +0000
@@ -36,6 +36,7 @@
 #define NFC_IP_DST_PT		0x0400
 /* Something else about the proto */
 #define NFC_IP_PROTO_UNKNOWN	0x2000
+#endif /* ! __KERNEL__ */
 
 /* IP Hooks */
 /* After promisc drops, checksum checks. */
@@ -49,7 +50,7 @@
 /* Packets about to hit the wire. */
 #define NF_IP_POST_ROUTING	4
 #define NF_IP_NUMHOOKS		5
-#endif /* ! __KERNEL__ */
+
 
 enum nf_ip_hook_priorities {
 	NF_IP_PRI_FIRST = INT_MIN,
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/netlink.h linux-2.6.30.9-rsdk/include/linux/netlink.h
--- linux-2.6.30.9/include/linux/netlink.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/netlink.h	2011-12-05 15:50:14.000000000 +0000
@@ -24,6 +24,9 @@
 /* leave room for NETLINK_DM (DM Events) */
 #define NETLINK_SCSITRANSPORT	18	/* SCSI Transports */
 #define NETLINK_ECRYPTFS	19
+#define NETLINK_RTK_DEBUG 	21
+#define NETLINK_RTK_FILTER 	22
+#define NETLINK_MULTICAST_DELETE 	23
 
 #define MAX_LINKS 32		
 
@@ -174,8 +177,10 @@
 
 #define NETLINK_CB(skb)		(*(struct netlink_skb_parms*)&((skb)->cb))
 #define NETLINK_CREDS(skb)	(&NETLINK_CB((skb)).creds)
-
-
+#if defined(CONFIG_RTL_819X)
+extern int rtk_nlrecvmsg(struct sk_buff *_skb,int _len, void *_recv_data);
+extern int rtk_nlsendmsg (int _pid,struct sock *_nl_sk,int _len,void *_send_info);
+#endif
 extern struct sock *netlink_kernel_create(struct net *net,
 					  int unit,unsigned int groups,
 					  void (*input)(struct sk_buff *skb),
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/page-flags.h linux-2.6.30.9-rsdk/include/linux/page-flags.h
--- linux-2.6.30.9/include/linux/page-flags.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/page-flags.h	2011-12-05 15:50:14.000000000 +0000
@@ -95,9 +95,7 @@
 	PG_reclaim,		/* To be reclaimed asap */
 	PG_buddy,		/* Page is free, on buddy lists */
 	PG_swapbacked,		/* Page is backed by RAM/swap */
-#ifdef CONFIG_UNEVICTABLE_LRU
 	PG_unevictable,		/* Page is "unevictable"  */
-#endif
 #ifdef CONFIG_HAVE_MLOCKED_PAGE_BIT
 	PG_mlocked,		/* Page is vma mlocked */
 #endif
@@ -248,14 +246,8 @@
 	SETPAGEFLAG_NOOP(SwapCache) CLEARPAGEFLAG_NOOP(SwapCache)
 #endif
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 PAGEFLAG(Unevictable, unevictable) __CLEARPAGEFLAG(Unevictable, unevictable)
 	TESTCLEARFLAG(Unevictable, unevictable)
-#else
-PAGEFLAG_FALSE(Unevictable) TESTCLEARFLAG_FALSE(Unevictable)
-	SETPAGEFLAG_NOOP(Unevictable) CLEARPAGEFLAG_NOOP(Unevictable)
-	__CLEARPAGEFLAG_NOOP(Unevictable)
-#endif
 
 #ifdef CONFIG_HAVE_MLOCKED_PAGE_BIT
 #define MLOCK_PAGES 1
@@ -382,11 +374,7 @@
 
 #endif /* !PAGEFLAGS_EXTENDED */
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 #define __PG_UNEVICTABLE	(1 << PG_unevictable)
-#else
-#define __PG_UNEVICTABLE	0
-#endif
 
 #ifdef CONFIG_HAVE_MLOCKED_PAGE_BIT
 #define __PG_MLOCKED		(1 << PG_mlocked)
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/pagemap.h linux-2.6.30.9-rsdk/include/linux/pagemap.h
--- linux-2.6.30.9/include/linux/pagemap.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/pagemap.h	2011-12-05 15:50:14.000000000 +0000
@@ -22,9 +22,7 @@
 	AS_EIO		= __GFP_BITS_SHIFT + 0,	/* IO error on async write */
 	AS_ENOSPC	= __GFP_BITS_SHIFT + 1,	/* ENOSPC on async write */
 	AS_MM_ALL_LOCKS	= __GFP_BITS_SHIFT + 2,	/* under mm_take_all_locks() */
-#ifdef CONFIG_UNEVICTABLE_LRU
 	AS_UNEVICTABLE	= __GFP_BITS_SHIFT + 3,	/* e.g., ramdisk, SHM_LOCK */
-#endif
 };
 
 static inline void mapping_set_error(struct address_space *mapping, int error)
@@ -37,8 +35,6 @@
 	}
 }
 
-#ifdef CONFIG_UNEVICTABLE_LRU
-
 static inline void mapping_set_unevictable(struct address_space *mapping)
 {
 	set_bit(AS_UNEVICTABLE, &mapping->flags);
@@ -55,14 +51,6 @@
 		return test_bit(AS_UNEVICTABLE, &mapping->flags);
 	return !!mapping;
 }
-#else
-static inline void mapping_set_unevictable(struct address_space *mapping) { }
-static inline void mapping_clear_unevictable(struct address_space *mapping) { }
-static inline int mapping_unevictable(struct address_space *mapping)
-{
-	return 0;
-}
-#endif
 
 static inline gfp_t mapping_gfp_mask(struct address_space * mapping)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/ppp_channel.h linux-2.6.30.9-rsdk/include/linux/ppp_channel.h
--- linux-2.6.30.9/include/linux/ppp_channel.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/ppp_channel.h	2011-12-05 15:50:14.000000000 +0000
@@ -81,5 +81,10 @@
  * that ppp_unregister_channel returns.
  */
 
+ #ifdef CONFIG_RTL_PPPOE_HWACC
+extern void ppp_channel_pppoe(struct ppp_channel *chan);
+#endif
+
+
 #endif /* __KERNEL__ */
 #endif
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/ppp-comp.h linux-2.6.30.9-rsdk/include/linux/ppp-comp.h
--- linux-2.6.30.9/include/linux/ppp-comp.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/ppp-comp.h	2011-12-05 15:50:14.000000000 +0000
@@ -26,7 +26,7 @@
  */
 
 /*
- *  ==FILEVERSION 980319==
+ *  ==FILEVERSION 20040509==
  *
  *  NOTE TO MAINTAINERS:
  *     If you modify this file at all, please set the above date.
@@ -109,8 +109,11 @@
 
 	/* Used in locking compressor modules */
 	struct module *owner;
+	
+#if !defined(CONFIG_PPP_MPPE_MPPC)
 	/* Extra skb space needed by the compressor algorithm */
 	unsigned int comp_extra;
+#endif
 };
 
 /*
@@ -191,12 +194,43 @@
 #define DEFLATE_CHK_SEQUENCE	0
 
 /*
- * Definitions for MPPE.
+ * Definitions for MPPE/MPPC.
  */
 
 #define CI_MPPE                18      /* config option for MPPE */
 #define CILEN_MPPE              6      /* length of config option */
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#define MPPE_OVHD              4       /* MPPE overhead */
+#define MPPE_MAX_KEY_LEN       16      /* largest key length (128-bit) */
+
+#define MPPE_STATELESS          0x01   /* configuration bit H */
+#define MPPE_40BIT              0x20   /* configuration bit L */
+#define MPPE_56BIT              0x80   /* configuration bit M */
+#define MPPE_128BIT             0x40   /* configuration bit S */
+#define MPPE_MPPC               0x01   /* configuration bit C */
+
+/*
+ * Definitions for Stac LZS.
+ */
+
+#define CI_LZS                 17      /* config option for Stac LZS */
+#define CILEN_LZS              5       /* length of config option */
+
+#define LZS_OVHD               4       /* max. LZS overhead */
+#define LZS_HIST_LEN           2048    /* LZS history size */
+#define LZS_MAX_CCOUNT         0x0FFF  /* max. coherency counter value */
+
+#define LZS_MODE_NONE          0
+#define LZS_MODE_LCB           1
+#define LZS_MODE_CRC           2
+#define LZS_MODE_SEQ           3
+#define LZS_MODE_EXT           4
+
+#define LZS_EXT_BIT_FLUSHED    0x80    /* bit A */
+#define LZS_EXT_BIT_COMP       0x20    /* bit C */
+#endif
+
 /*
  * Definitions for other, as yet unsupported, compression methods.
  */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/rmap.h linux-2.6.30.9-rsdk/include/linux/rmap.h
--- linux-2.6.30.9/include/linux/rmap.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/rmap.h	2011-12-05 15:50:14.000000000 +0000
@@ -105,18 +105,11 @@
  */
 int page_mkclean(struct page *);
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 /*
  * called in munlock()/munmap() path to check for other vmas holding
  * the page mlocked.
  */
 int try_to_munlock(struct page *);
-#else
-static inline int try_to_munlock(struct page *page)
-{
-	return 0;	/* a.k.a. SWAP_SUCCESS */
-}
-#endif
 
 #else	/* !CONFIG_MMU */
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/root_dev.h linux-2.6.30.9-rsdk/include/linux/root_dev.h
--- linux-2.6.30.9/include/linux/root_dev.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/root_dev.h	2011-12-05 15:50:14.000000000 +0000
@@ -16,6 +16,7 @@
 	Root_SDA2 = MKDEV(SCSI_DISK0_MAJOR, 2),
 	Root_HDC1 = MKDEV(IDE1_MAJOR, 1),
 	Root_SR0 = MKDEV(SCSI_CDROM_MAJOR, 0),
+	Root_MTDBLK1=MKDEV(MTDBLK_MAJOR, 1),
 };
 
 extern dev_t ROOT_DEV;
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/rtnetlink.h linux-2.6.30.9-rsdk/include/linux/rtnetlink.h
--- linux-2.6.30.9/include/linux/rtnetlink.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/rtnetlink.h	2011-12-05 15:50:14.000000000 +0000
@@ -113,6 +113,11 @@
 	RTM_SETDCB,
 #define RTM_SETDCB RTM_SETDCB
 
+#ifdef CONFIG_RTK_VOIP
+        RTM_LINKCHANGE,
+#define RTM_LINKCHANGE RTM_LINKCHANGE
+#endif
+
 	__RTM_MAX,
 #define RTM_MAX		(((__RTM_MAX + 3) & ~3) - 1)
 };
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/sched.h linux-2.6.30.9-rsdk/include/linux/sched.h
--- linux-2.6.30.9/include/linux/sched.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/sched.h	2011-12-05 15:50:14.000000000 +0000
@@ -482,6 +482,15 @@
 		.sum_exec_runtime = 0,				\
 	}
 
+/*
+ * Disable preemption until the scheduler is running.
+ * Reset by start_kernel()->sched_init()->init_idle().
+ *
+ * We include PREEMPT_ACTIVE to avoid cond_resched() from working
+ * before the scheduler is active -- see should_resched().
+ */
+#define INIT_PREEMPT_COUNT  (1 + PREEMPT_ACTIVE)
+
 /**
  * struct thread_group_cputimer - thread group interval timer counts
  * @cputime:		thread group interval timers.
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/serial_8250.h linux-2.6.30.9-rsdk/include/linux/serial_8250.h
--- linux-2.6.30.9/include/linux/serial_8250.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/serial_8250.h	2011-12-05 15:50:14.000000000 +0000
@@ -50,6 +50,7 @@
 	PLAT8250_DEV_MCA,
 	PLAT8250_DEV_AU1X00,
 	PLAT8250_DEV_SM501,
+	PLAT8250_DEV_SC16IS7X0, // I2C
 };
 
 /*
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/serial_core.h linux-2.6.30.9-rsdk/include/linux/serial_core.h
--- linux-2.6.30.9/include/linux/serial_core.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/serial_core.h	2011-12-05 15:50:14.000000000 +0000
@@ -273,6 +273,7 @@
 #define UPIO_TSI		(5)			/* Tsi108/109 type IO */
 #define UPIO_DWAPB		(6)			/* DesignWare APB UART */
 #define UPIO_RM9000		(7)			/* RM9000 type IO */
+#define UPIO_I2C		(8)			/* I2C */
 
 	unsigned int		read_status_mask;	/* driver specific */
 	unsigned int		ignore_status_mask;	/* driver specific */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/skbuff.h linux-2.6.30.9-rsdk/include/linux/skbuff.h
--- linux-2.6.30.9/include/linux/skbuff.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/skbuff.h	2011-12-05 15:50:14.000000000 +0000
@@ -28,6 +28,20 @@
 #include <linux/rcupdate.h>
 #include <linux/dmaengine.h>
 #include <linux/hrtimer.h>
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+#include <net/rtl/rtk_vlan.h>
+#endif
+
+#if defined(CONFIG_RTL_819X) || defined(CONFIG_RTL8192CD) || defined(CONFIG_RTL8190) || defined(CONFIG_RTL8192SE)
+#define RTL_PRIV_DATA_SIZE		128
+#endif
+
+#if defined(CONFIG_RTL_QOS_PATCH)
+#define	QOS_PATCH_HIGH_QUEUE_PRIO	7
+#define	QOS_PATCH_RX_FROM_LOCAL		0xff
+#define QOS_PATCH_RX_FROM_WIRELESS      7
+#endif
+
 
 /* Don't change this without changing skb_csum_unnecessary! */
 #define CHECKSUM_NONE 0
@@ -334,6 +348,9 @@
 	 */
 	char			cb[48];
 
+	/*This field is only needed by RTL8190 Driver.FIX ME!!!*/
+	unsigned char 	__unused;
+
 	unsigned int		len,
 				data_len;
 	__u16			mac_len,
@@ -391,6 +408,40 @@
 	__u32			secmark;
 #endif
 
+#if defined( CONFIG_RTL_HARDWARE_MULTICAST) || defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
+	__u16			srcPort;
+	__u16			srcVlanId:12;
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	__u16			srcVlanPriority:3;
+#endif
+
+/* #if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT)|| defined(CONFIG_RTL_FAST_FILTER) */
+	__u8			srcPhyPort;		// 0~4
+	__u8			dstPhyPort;		// 0~4
+/* #endif */
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	struct vlan_tag tag;
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	__u32 srcLocalPublicIp;
+	__u8 fromLocalPublic;
+	__u8 toLocalPublic;
+	__u8 localPublicFlags;
+#endif 
+#if defined(CONFIG_RTL_FAST_BRIDGE)
+	__u8 fast_br_forwarding_flags;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+/* #if defined(IMPROVE_QOS) && defined(CONFIG_NET_SCHED) */
+	/* This member is only used at fastpath when both IMPROVE_QOS and CONFIG_NET_SCHED are defined. */
+	struct net_device	*inDev;
+/* end of IMPROVE_QOS and CONFIG_NET_SCHED */
+#endif
+
 	__u32			mark;
 
 	__u16			vlan_tci;
@@ -1423,11 +1474,19 @@
  *	list lock and the caller must hold the relevant locks to use it.
  */
 extern void skb_queue_purge(struct sk_buff_head *list);
+extern void dev_kfree_skb_any(struct sk_buff *skb);
 static inline void __skb_queue_purge(struct sk_buff_head *list)
 {
 	struct sk_buff *skb;
 	while ((skb = __skb_dequeue(list)) != NULL)
+	{
+		#if CONFIG_RTL_819X
+		dev_kfree_skb_any(skb);
+		#else
 		kfree_skb(skb);
+		#endif
+	}
+
 }
 
 /**
@@ -2044,5 +2103,9 @@
 }
 
 bool skb_partial_csum_set(struct sk_buff *skb, u16 start, u16 off);
+
+#if defined(CONFIG_RTL_ETH_PRIV_SKB) && (defined(CONFIG_NET_WIRELESS_AGN) || defined(CONFIG_NET_WIRELESS_AG))
+void copy_skb_header(struct sk_buff *new, const struct sk_buff *old);
+#endif
 #endif	/* __KERNEL__ */
 #endif	/* _LINUX_SKBUFF_H */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/string.h linux-2.6.30.9-rsdk/include/linux/string.h
--- linux-2.6.30.9/include/linux/string.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/string.h	2011-12-05 15:50:14.000000000 +0000
@@ -14,6 +14,7 @@
 
 extern char *strndup_user(const char __user *, long);
 extern void *memdup_user(const void __user *, size_t);
+extern char * strtok(char *,const char *);
 
 /*
  * Include machine specific inline routines
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/swap.h linux-2.6.30.9-rsdk/include/linux/swap.h
--- linux-2.6.30.9/include/linux/swap.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/swap.h	2011-12-05 15:50:14.000000000 +0000
@@ -235,7 +235,6 @@
 }
 #endif
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 extern int page_evictable(struct page *page, struct vm_area_struct *vma);
 extern void scan_mapping_unevictable_pages(struct address_space *);
 
@@ -244,24 +243,6 @@
 					void __user *, size_t *, loff_t *);
 extern int scan_unevictable_register_node(struct node *node);
 extern void scan_unevictable_unregister_node(struct node *node);
-#else
-static inline int page_evictable(struct page *page,
-						struct vm_area_struct *vma)
-{
-	return 1;
-}
-
-static inline void scan_mapping_unevictable_pages(struct address_space *mapping)
-{
-}
-
-static inline int scan_unevictable_register_node(struct node *node)
-{
-	return 0;
-}
-
-static inline void scan_unevictable_unregister_node(struct node *node) { }
-#endif
 
 extern int kswapd_run(int nid);
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/sysctl.h linux-2.6.30.9-rsdk/include/linux/sysctl.h
--- linux-2.6.30.9/include/linux/sysctl.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/sysctl.h	2011-12-05 15:50:14.000000000 +0000
@@ -335,6 +335,11 @@
 	NET_NF_CONNTRACK_FRAG6_LOW_THRESH=30,
 	NET_NF_CONNTRACK_FRAG6_HIGH_THRESH=31,
 	NET_NF_CONNTRACK_CHECKSUM=32,
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	NET_NF_CONNTRACK_GARBAGE_TCP,
+	NET_NF_CONNTRACK_GARBAGE_UDP,
+#endif
+
 };
 
 /* /proc/sys/net/ipv4 */
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/usb/ch9.h linux-2.6.30.9-rsdk/include/linux/usb/ch9.h
--- linux-2.6.30.9/include/linux/usb/ch9.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/usb/ch9.h	2011-12-05 15:50:14.000000000 +0000
@@ -191,6 +191,8 @@
 #define USB_DT_WIRE_ADAPTER		0x21
 #define USB_DT_RPIPE			0x22
 #define USB_DT_CS_RADIO_CONTROL		0x23
+/* USB 3.0 */
+#define USB_DT_SS_ENDPOINT_COMP 0x30
 
 /* Conventional codes for class-specific descriptors.  The convention is
  * defined in the USB "Common Class" Spec (3.11).  Individual class specs
@@ -715,6 +717,15 @@
 #define USB_ENDPOINT_SWITCH_SCALE	2
 } __attribute__((packed));
 
+/* USB 3.0 */
+struct usb_superspeed_ep_comp_descriptor {
+  __u8 bLength;
+  __u8 bDescriptorType;
+  __u8 bMaxBurst;
+  __u8 bmAttributes;
+  __u16 wBytesPerInterval;
+} __attribute__((packed));
+
 /*-------------------------------------------------------------------------*/
 
 /* USB_REQ_SET_HANDSHAKE is a four-way handshake used between a wireless
@@ -752,6 +763,7 @@
 	USB_SPEED_LOW, USB_SPEED_FULL,		/* usb 1.1 */
 	USB_SPEED_HIGH,				/* usb 2.0 */
 	USB_SPEED_VARIABLE,			/* wireless (usb 2.5) */
+    USB_SPEED_SUPER,            /* usb 3.0 */
 };
 
 enum usb_device_state {
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/usb/gadget.h linux-2.6.30.9-rsdk/include/linux/usb/gadget.h
--- linux-2.6.30.9/include/linux/usb/gadget.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/usb/gadget.h	2011-12-05 15:50:14.000000000 +0000
@@ -83,6 +83,11 @@
 	unsigned		zero:1;
 	unsigned		short_not_ok:1;
 
+#ifdef DWC_UASP_GADGET
+    unsigned        padding:13;  // align stream_id to 16-bit boundary
+    unsigned        stream_id:16;
+#endif
+
 	void			(*complete)(struct usb_ep *ep,
 					struct usb_request *req);
 	void			*context;
diff -uNr --ignore-all-space linux-2.6.30.9/include/linux/vmstat.h linux-2.6.30.9-rsdk/include/linux/vmstat.h
--- linux-2.6.30.9/include/linux/vmstat.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/linux/vmstat.h	2011-12-05 15:50:14.000000000 +0000
@@ -44,7 +44,6 @@
 #ifdef CONFIG_HUGETLB_PAGE
 		HTLB_BUDDY_PGALLOC, HTLB_BUDDY_PGALLOC_FAIL,
 #endif
-#ifdef CONFIG_UNEVICTABLE_LRU
 		UNEVICTABLE_PGCULLED,	/* culled to noreclaim list */
 		UNEVICTABLE_PGSCANNED,	/* scanned for reclaimability */
 		UNEVICTABLE_PGRESCUED,	/* rescued from noreclaim list */
@@ -53,7 +52,6 @@
 		UNEVICTABLE_PGCLEARED,	/* on COW, page truncate */
 		UNEVICTABLE_PGSTRANDED,	/* unable to isolate on unlock */
 		UNEVICTABLE_MLOCKFREED,
-#endif
 		NR_VM_EVENT_ITEMS
 };
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/dst.h linux-2.6.30.9-rsdk/include/net/dst.h
--- linux-2.6.30.9/include/net/dst.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/dst.h	2011-12-05 15:50:14.000000000 +0000
@@ -124,6 +124,15 @@
 	struct net              *dst_net;
 };
 
+struct dst_gc
+{
+	spinlock_t		lock;
+	struct dst_entry 	*list;
+	unsigned long		timer_inc;
+	unsigned long		timer_expires;
+};
+
+
 #ifdef __KERNEL__
 
 static inline u32
@@ -271,6 +280,22 @@
 /* Input packet from network to transport.  */
 static inline int dst_input(struct sk_buff *skb)
 {
+	if(skb->dst == NULL)
+	{
+             //printk("Func[%s] Line[%d], skb(0x%p),skb->dst(0x%p)\n", __FUNCTION__, __LINE__, skb,skb->dst);
+		kfree_skb(skb);
+             return -EHOSTUNREACH;
+	}
+
+        if(skb->dst->output == NULL)
+        {
+                //printk("Func[%s] Line[%d], func 0x%p,skb(0x%p),skb->dst(0x%p)\n", __FUNCTION__, __LINE__, skb->dst->output,skb,skb->dst);
+                //if(skb->dst->dev)
+                        //printk("skb->dst->dev->name(%s)\n",skb->dst->dev->name);
+                kfree_skb(skb);
+                return -EHOSTUNREACH;
+        }
+		
 	return skb->dst->input(skb);
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/ip_vs.h linux-2.6.30.9-rsdk/include/net/ip_vs.h
--- linux-2.6.30.9/include/net/ip_vs.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/ip_vs.h	2011-12-05 15:50:14.000000000 +0000
@@ -383,6 +383,10 @@
 	void                    *app_data;      /* Application private data */
 	struct ip_vs_seq        in_seq;         /* incoming seq. struct */
 	struct ip_vs_seq        out_seq;        /* outgoing seq. struct */
+	#if defined(CONFIG_RTL_HARDWARE_NAT)
+	/*2007-12-19*/
+	__u32				hw_acc; /* 1: hardware acceleration, 0: software only */
+	#endif
 };
 
 
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/netfilter/nf_conntrack_core.h linux-2.6.30.9-rsdk/include/net/netfilter/nf_conntrack_core.h
--- linux-2.6.30.9/include/net/netfilter/nf_conntrack_core.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/netfilter/nf_conntrack_core.h	2011-12-05 15:50:14.000000000 +0000
@@ -51,6 +51,7 @@
 extern struct nf_conntrack_tuple_hash *
 nf_conntrack_find_get(struct net *net, const struct nf_conntrack_tuple *tuple);
 
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 extern int __nf_conntrack_confirm(struct sk_buff *skb);
 
 /* Confirm a connection: returns NF_DROP if packet must be dropped. */
@@ -67,6 +68,7 @@
 	}
 	return ret;
 }
+#endif
 
 int
 print_tuple(struct seq_file *s, const struct nf_conntrack_tuple *tuple,
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/netfilter/nf_conntrack.h linux-2.6.30.9-rsdk/include/net/netfilter/nf_conntrack.h
--- linux-2.6.30.9/include/net/netfilter/nf_conntrack.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/netfilter/nf_conntrack.h	2011-12-05 15:50:14.000000000 +0000
@@ -12,6 +12,13 @@
 #ifndef _NF_CONNTRACK_H
 #define _NF_CONNTRACK_H
 
+#if defined(CONFIG_RTL_819X)
+/* by default disable */
+#if defined(CONFIG_FAST_PATH_SPI_ENABLED)
+#define FAST_PATH_SPI_ENABLED		1
+#endif
+#endif
+
 #include <linux/netfilter/nf_conntrack_common.h>
 
 #ifdef __KERNEL__
@@ -92,9 +99,11 @@
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
 
 struct nf_conn {
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 	/* Usage count in here is 1 for hash table/destruct timer, 1 per skb,
            plus 1 for any connection(s) we are `master' for */
 	struct nf_conntrack ct_general;
+#endif
 
 	/* XXX should I move this to the tail ? - Y.K */
 	/* These are my tuples; original and reply */
@@ -109,22 +118,27 @@
 	/* Timer function; drops refcnt when it goes off. */
 	struct timer_list timeout;
 
-#if defined(CONFIG_NF_CONNTRACK_MARK)
-	u_int32_t mark;
-#endif
-
-#ifdef CONFIG_NF_CONNTRACK_SECMARK
-	u_int32_t secmark;
-#endif
-
 	/* Storage reserved for other modules: */
 	union nf_conntrack_proto proto;
 
 	/* Extensions */
 	struct nf_ct_ext *ext;
+
 #ifdef CONFIG_NET_NS
 	struct net *ct_net;
 #endif
+
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+       struct list_head 	state_tuple;
+	#endif
+
+	#if defined(CONFIG_NF_CONNTRACK_MARK)
+	u_int32_t mark;
+	#endif
+
+	#ifdef CONFIG_NF_CONNTRACK_SECMARK
+	u_int32_t secmark;
+	#endif
 };
 
 static inline struct nf_conn *
@@ -169,6 +183,8 @@
 nf_conntrack_tuple_taken(const struct nf_conntrack_tuple *tuple,
 			 const struct nf_conn *ignored_conntrack);
 
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
+
 /* Return conntrack_info and tuple hash for given skb. */
 static inline struct nf_conn *
 nf_ct_get(const struct sk_buff *skb, enum ip_conntrack_info *ctinfo)
@@ -183,6 +199,7 @@
 	NF_CT_ASSERT(ct);
 	nf_conntrack_put(&ct->ct_general);
 }
+#endif
 
 /* Protocol module loading */
 extern int nf_ct_l3proto_try_module_get(unsigned short l3proto);
@@ -215,6 +232,37 @@
 				 unsigned long extra_jiffies,
 				 int do_acct);
 
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+extern void __nf_ct_refresh_acct_proto(struct nf_conn *ct, 
+				      enum ip_conntrack_info ctinfo,
+				      const struct sk_buff *skb,
+				      unsigned long extra_jiffies,
+				      int do_acct,
+				      unsigned char proto, 
+				      void * extra1,
+				      void * extra2);
+
+static inline void nf_ct_refresh_acct_tcp(struct nf_conn *ct, 
+				      enum ip_conntrack_info ctinfo,
+				      const struct sk_buff *skb,
+				      unsigned long extra_jiffies,
+				      enum tcp_conntrack oldstate,
+				      enum tcp_conntrack newstate) 
+{
+	__nf_ct_refresh_acct_proto(ct, ctinfo, skb, extra_jiffies, 1, 6, (void *)oldstate, (void *)newstate);
+}
+
+
+static inline void nf_ct_refresh_acct_udp(struct nf_conn *ct, 
+				      enum ip_conntrack_info ctinfo,
+				      const struct sk_buff *skb,
+				      unsigned long extra_jiffies, char * status) 
+{
+	__nf_ct_refresh_acct_proto(ct, ctinfo, skb, extra_jiffies, 1, 17, (void *)status, (void *)0);
+}
+#endif
+
+
 /* Refresh conntrack for this many jiffies and do accounting */
 static inline void nf_ct_refresh_acct(struct nf_conn *ct,
 				      enum ip_conntrack_info ctinfo,
@@ -282,10 +330,12 @@
 	return test_bit(IPS_DYING_BIT, &ct->status);
 }
 
+#if defined(CONFIG_NF_CONNTRACK) || defined(CONFIG_NF_CONNTRACK_MODULE)
 static inline int nf_ct_is_untracked(const struct sk_buff *skb)
 {
 	return (skb->nfct == &nf_conntrack_untracked.ct_general);
 }
+#endif
 
 extern int nf_conntrack_set_hashsize(const char *val, struct kernel_param *kp);
 extern unsigned int nf_conntrack_htable_size;
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/netfilter/nf_conntrack_tuple.h linux-2.6.30.9-rsdk/include/net/netfilter/nf_conntrack_tuple.h
--- linux-2.6.30.9/include/net/netfilter/nf_conntrack_tuple.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/netfilter/nf_conntrack_tuple.h	2011-12-05 15:50:14.000000000 +0000
@@ -152,8 +152,7 @@
 	struct nf_conntrack_tuple tuple;
 };
 
-#endif /* __KERNEL__ */
-
+#ifdef CONFIG_NETFILTER
 static inline bool __nf_ct_tuple_src_equal(const struct nf_conntrack_tuple *t1,
 					   const struct nf_conntrack_tuple *t2)
 { 
@@ -216,5 +215,6 @@
 	return nf_ct_tuple_src_mask_cmp(t, tuple, mask) &&
 	       __nf_ct_tuple_dst_equal(t, tuple);
 }
-
+#endif
+#endif /* __KERNEL__ */
 #endif /* _NF_CONNTRACK_TUPLE_H */
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/netfilter/nf_nat_core.h linux-2.6.30.9-rsdk/include/net/netfilter/nf_nat_core.h
--- linux-2.6.30.9/include/net/netfilter/nf_nat_core.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/netfilter/nf_nat_core.h	2011-12-05 15:50:14.000000000 +0000
@@ -33,4 +33,6 @@
 				  enum nf_nat_manip_type manip,
 				  struct nlattr *attr);
 
+
 #endif /* _NF_NAT_CORE_H */
+
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/netfilter/nf_nat.h linux-2.6.30.9-rsdk/include/net/netfilter/nf_nat.h
--- linux-2.6.30.9/include/net/netfilter/nf_nat.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/netfilter/nf_nat.h	2011-12-05 15:50:14.000000000 +0000
@@ -76,6 +76,11 @@
     defined(CONFIG_IP_NF_TARGET_MASQUERADE_MODULE)
 	int masq_index;
 #endif
+
+#if defined(CONFIG_RTL_HARDWARE_NAT)
+/*2007-12-19*/
+	int hw_acc; /* 1: hardware acceleration, 0: software only */
+#endif
 };
 
 /* Set up the info structure to map into this range. */
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/pkt_cls.h linux-2.6.30.9-rsdk/include/net/pkt_cls.h
--- linux-2.6.30.9/include/net/pkt_cls.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/pkt_cls.h	2011-12-05 15:50:14.000000000 +0000
@@ -362,4 +362,8 @@
 }
 #endif /* CONFIG_NET_CLS_IND */
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+int tc_getHandleByKey(__u32 key, __u32 *handle, struct net_device *d, struct net_device **m);
+#endif	/*	CONFIG_RTL_HW_QOS_SUPPORT	*/
+
 #endif
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/sch_generic.h linux-2.6.30.9-rsdk/include/net/sch_generic.h
--- linux-2.6.30.9/include/net/sch_generic.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/sch_generic.h	2011-12-05 15:50:14.000000000 +0000
@@ -103,6 +103,11 @@
 					struct sk_buff *skb, struct tcmsg*);
 	int			(*dump_stats)(struct Qdisc *, unsigned long,
 					struct gnet_dump *);
+#if     defined(CONFIG_RTL_HW_QOS_SUPPORT)
+        /* used for hw qos */
+        int                     (*syncHwQueue)(struct net_device *);
+        int                     (*getHandleByKey)(__u32, __u32 *, struct Qdisc *);
+#endif
 };
 
 struct Qdisc_ops
@@ -156,7 +161,10 @@
 	/* rtnetlink specific */
 	int			(*dump)(struct tcf_proto*, unsigned long,
 					struct sk_buff *skb, struct tcmsg*);
-
+#if     defined(CONFIG_RTL_HW_QOS_SUPPORT)
+        int                     (*classifyMark)(__u32, struct tcf_proto*,
+                                        struct tcf_result *);
+#endif
 	struct module		*owner;
 };
 
@@ -556,4 +564,8 @@
 }
 #endif
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+int tc_classifyMark(__u32 mark, struct tcf_proto *tp, struct tcf_result *res);
+#endif
+
 #endif
diff -uNr --ignore-all-space linux-2.6.30.9/include/net/slhc_vj.h linux-2.6.30.9-rsdk/include/net/slhc_vj.h
--- linux-2.6.30.9/include/net/slhc_vj.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/include/net/slhc_vj.h	2011-12-05 15:50:14.000000000 +0000
@@ -117,7 +117,8 @@
  */
 
 typedef __u8 byte_t;
-typedef __u32 int32;
+//typedef __u32 int32;
+#define int32 __u32
 
 /*
  * "state" data for each active tcp conversation on the wire.  This is
diff -uNr --ignore-all-space linux-2.6.30.9/init/do_mounts.c linux-2.6.30.9-rsdk/init/do_mounts.c
--- linux-2.6.30.9/init/do_mounts.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/init/do_mounts.c	2011-12-05 15:50:14.000000000 +0000
@@ -24,13 +24,21 @@
 
 int __initdata rd_doload;	/* 1 = load RAM disk, 0 = don't load */
 
+#if defined( CONFIG_ROOTFS_RAMFS ) || defined( CONFIG_ROOTFS_JFFS2 )
+int root_mountflags = MS_SILENT;
+#elif defined( CONFIG_ROOTFS_SQUASH )
 int root_mountflags = MS_RDONLY | MS_SILENT;
+#else
+int root_mountflags = MS_RDONLY | MS_SILENT;
+#endif
+
 static char * __initdata root_device_name;
 static char __initdata saved_root_name[64];
 static int __initdata root_wait;
 
 dev_t ROOT_DEV;
 
+
 static int __init load_ramdisk(char *str)
 {
 	rd_doload = simple_strtol(str,NULL,0) & 3;
@@ -97,6 +105,13 @@
 	}
 
 	name += 5;
+
+        /*special for RTK Solution*/
+#ifdef CONFIG_RTL_819X
+        res = Root_MTDBLK1;
+        if(strcmp(name,"mtdblock1") == 0)
+                goto done;
+#endif
 	res = Root_NFS;
 	if (strcmp(name, "nfs") == 0)
 		goto done;
@@ -357,7 +372,6 @@
 	mount_block_root("/dev/root", root_mountflags);
 #endif
 }
-
 /*
  * Prepare the namespace - decide what/where to mount, load ramdisks, etc.
  */
@@ -389,6 +403,11 @@
 			mount_block_root(root_device_name, root_mountflags);
 			goto out;
 		}
+#ifdef CONFIG_RTL_FLASH_DUAL_IMAGE_ENABLE
+extern int is_bank2_root();  //extern from rtl_gpio.c
+		if(is_bank2_root()) //assume bank1 root is mtdblock1 , bank2's root is mtdblock3
+			strcpy(root_device_name,"/dev/mtdblock3");		
+#endif
 		ROOT_DEV = name_to_dev_t(root_device_name);
 		if (strncmp(root_device_name, "/dev/", 5) == 0)
 			root_device_name += 5;
diff -uNr --ignore-all-space linux-2.6.30.9/init/Kconfig linux-2.6.30.9-rsdk/init/Kconfig
--- linux-2.6.30.9/init/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/init/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -825,15 +825,25 @@
 	  disabling this option for embedded systems that do not use modules, a
 	  dynamic /dev tree, or dynamic device discovery.  Just say Y.
 
+config PRINTK_FUNC
+	default n
+	bool "Enable support for printk log" if EMBEDDED
+	depends on RTL_819X
+
 config PRINTK
-	default y
-	bool "Enable support for printk" if EMBEDDED
+	default n
+	bool "Enable support for printk console" if EMBEDDED 
+	depends on  (!RTL_819X) || (RTL_819X && PRINTK_FUNC) 
 	help
 	  This option enables normal printk support. Removing it
 	  eliminates most of the message strings from the kernel image
 	  and makes the kernel more or less silent. As this makes it
 	  very difficult to diagnose system problems, saying N here is
 	  strongly discouraged.
+config PANIC_PRINTK
+	default y
+	bool
+	depends on (!PRINTK)
 
 config BUG
 	bool "BUG() support" if EMBEDDED
diff -uNr --ignore-all-space linux-2.6.30.9/init/main.c linux-2.6.30.9-rsdk/init/main.c
--- linux-2.6.30.9/init/main.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/init/main.c	2011-12-05 15:50:14.000000000 +0000
@@ -223,7 +223,11 @@
  * This should be approx 2 Bo*oMips to start (note initial shift), and will
  * still work even if initially too large, it will just take slightly longer
  */
+#ifdef CONFIG_SERIAL_SC16IS7X0_CONSOLE
+unsigned long loops_per_jiffy = (2490368);	// @498.07
+#else
 unsigned long loops_per_jiffy = (1<<12);
+#endif
 
 EXPORT_SYMBOL(loops_per_jiffy);
 
diff -uNr --ignore-all-space linux-2.6.30.9/kernel/exit.c linux-2.6.30.9-rsdk/kernel/exit.c
--- linux-2.6.30.9/kernel/exit.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/kernel/exit.c	2011-12-05 15:50:14.000000000 +0000
@@ -920,6 +920,10 @@
 		 */
 		tsk->flags |= PF_EXITPIDONE;
 		set_current_state(TASK_UNINTERRUPTIBLE);
+#if defined(CONFIG_RTL_WTDOG)
+		panic("Fixing recursive fault but reboot is needed!");
+		{ extern int is_fault; is_fault=1; } // set kernel fault flag	
+#endif		
 		schedule();
 	}
 
@@ -934,9 +938,15 @@
 	spin_unlock_wait(&tsk->pi_lock);
 
 	if (unlikely(in_atomic()))
+{
 		printk(KERN_INFO "note: %s[%d] exited with preempt_count %d\n",
 				current->comm, task_pid_nr(current),
 				preempt_count());
+#if defined(CONFIG_RTL_WTDOG)
+		panic("note: %s[%d] exited with preempt_count %d\n", current->comm, current->pid, preempt_count());
+		{ extern int is_fault; is_fault=1; } // set kernel fault flag	
+#endif		
+}
 
 	acct_update_integrals(tsk);
 
diff -uNr --ignore-all-space linux-2.6.30.9/kernel/irq/handle.c linux-2.6.30.9-rsdk/kernel/irq/handle.c
--- linux-2.6.30.9/kernel/irq/handle.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/kernel/irq/handle.c	2011-12-05 15:50:14.000000000 +0000
@@ -9,7 +9,6 @@
  * Detailed information is available in Documentation/DocBook/genericirq
  *
  */
-
 #include <linux/irq.h>
 #include <linux/module.h>
 #include <linux/random.h>
@@ -19,7 +18,9 @@
 #include <linux/hash.h>
 #include <trace/irq.h>
 #include <linux/bootmem.h>
-
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/rtl_types.h>
+#endif
 #include "internals.h"
 
 /*
@@ -126,7 +127,6 @@
  * Protect the sparse_irqs:
  */
 DEFINE_SPINLOCK(sparse_irq_lock);
-
 struct irq_desc **irq_desc_ptrs __read_mostly;
 
 static struct irq_desc irq_desc_legacy[NR_IRQS_LEGACY] __cacheline_aligned_in_smp = {
@@ -229,6 +229,10 @@
 }
 
 #else /* !CONFIG_SPARSE_IRQ */
+#if defined(CONFIG_RTL_819X)
+__DRAM_GEN
+#endif
+static unsigned int kstat_irqs_all[NR_IRQS][NR_CPUS];
 
 struct irq_desc irq_desc[NR_IRQS] __cacheline_aligned_in_smp = {
 	[0 ... NR_IRQS-1] = {
@@ -240,7 +244,6 @@
 	}
 };
 
-static unsigned int kstat_irqs_all[NR_IRQS][NR_CPUS];
 int __init early_irq_init(void)
 {
 	struct irq_desc *desc;
@@ -258,10 +261,17 @@
 		desc[i].irq = i;
 		init_alloc_desc_masks(&desc[i], 0, true);
 		desc[i].kstat_irqs = kstat_irqs_all[i];
+		#if defined(CONFIG_RTL_819X)
+		memset(kstat_irqs_all, 0, NR_IRQS*NR_CPUS*sizeof(unsigned int));
+		#endif
 	}
+	
 	return arch_early_irq_init();
 }
 
+#if defined(CONFIG_RTL_819X)
+__IRAM_GEN
+#endif
 struct irq_desc *irq_to_desc(unsigned int irq)
 {
 	return (irq < NR_IRQS) ? irq_desc + irq : NULL;
diff -uNr --ignore-all-space linux-2.6.30.9/kernel/Makefile linux-2.6.30.9-rsdk/kernel/Makefile
--- linux-2.6.30.9/kernel/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/kernel/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -2,6 +2,17 @@
 # Makefile for the linux kernel.
 #
 
+ifdef CONFIG_RTL_819X
+obj-y     = sched.o fork.o exec_domain.o panic.o printk_log.o \
+	    cpu.o exit.o itimer.o time.o softirq.o resource.o \
+	    sysctl.o capability.o ptrace.o timer.o user.o \
+	    signal.o sys.o kmod.o workqueue.o pid.o \
+	    rcupdate.o extable.o params.o posix-timers.o \
+	    kthread.o wait.o kfifo.o sys_ni.o posix-cpu-timers.o mutex.o \
+	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
+	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
+	    async.o
+else
 obj-y     = sched.o fork.o exec_domain.o panic.o printk.o \
 	    cpu.o exit.o itimer.o time.o softirq.o resource.o \
 	    sysctl.o capability.o ptrace.o timer.o user.o \
@@ -11,6 +22,7 @@
 	    hrtimer.o rwsem.o nsproxy.o srcu.o semaphore.o \
 	    notifier.o ksysfs.o pm_qos_params.o sched_clock.o cred.o \
 	    async.o
+endif
 
 ifdef CONFIG_FUNCTION_TRACER
 # Do not trace debug files and internal ftrace files
diff -uNr --ignore-all-space linux-2.6.30.9/kernel/panic.c linux-2.6.30.9-rsdk/kernel/panic.c
--- linux-2.6.30.9/kernel/panic.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/kernel/panic.c	2011-12-05 15:50:14.000000000 +0000
@@ -23,6 +23,10 @@
 #include <linux/nmi.h>
 #include <linux/dmi.h>
 
+#ifdef CONFIG_PANIC_PRINTK
+#define printk panic_printk
+#endif
+
 int panic_on_oops;
 static unsigned long tainted_mask;
 static int pause_on_oops;
@@ -93,6 +97,16 @@
 	if (!panic_blink)
 		panic_blink = no_blink;
 
+#if defined(CONFIG_RTL_WTDOG)
+	{ extern int is_fault; is_fault=1; } // set kernel fault flag	
+#if 0
+	{
+		static void (*hw_restart)(void) = (void (*)(void)) 0xbfc00000;
+		hw_restart();
+	}
+#endif
+#endif
+
 	if (panic_timeout > 0) {
 		/*
 		 * Delay timeout seconds before rebooting the machine.
diff -uNr --ignore-all-space linux-2.6.30.9/kernel/softirq.c linux-2.6.30.9-rsdk/kernel/softirq.c
--- linux-2.6.30.9/kernel/softirq.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/kernel/softirq.c	2011-12-05 15:50:14.000000000 +0000
@@ -27,6 +27,9 @@
 #include <trace/irq.h>
 
 #include <asm/irq.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/rtl_types.h>
+#endif
 /*
    - No shared variables, all the data are CPU local.
    - If a softirq needs serialization, let it serialize itself
@@ -50,9 +53,16 @@
 EXPORT_SYMBOL(irq_stat);
 #endif
 
+#if defined(CONFIG_RTL_819X)
+#define RTL_DEFINE_PER_CPU(type, name)			\
+	PER_CPU_ATTRIBUTES PER_CPU_DEF_ATTRIBUTES			\
+	__typeof__(type) per_cpu__##name
+__DRAM_GEN static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
+__DRAM_GEN static RTL_DEFINE_PER_CPU(struct task_struct *, ksoftirqd);
+#else
 static struct softirq_action softirq_vec[NR_SOFTIRQS] __cacheline_aligned_in_smp;
-
 static DEFINE_PER_CPU(struct task_struct *, ksoftirqd);
+#endif
 
 char *softirq_to_name[NR_SOFTIRQS] = {
 	"HI", "TIMER", "NET_TX", "NET_RX", "BLOCK",
@@ -184,7 +194,11 @@
  * we want to handle softirqs as soon as possible, but they
  * should not be able to lock up the box.
  */
+ #if defined(CONFIG_RTL_819X)
+#define MAX_SOFTIRQ_RESTART 2000
+#else
 #define MAX_SOFTIRQ_RESTART 10
+#endif
 
 DEFINE_TRACE(softirq_entry);
 DEFINE_TRACE(softirq_exit);
@@ -352,8 +366,13 @@
 	struct tasklet_struct **tail;
 };
 
+#if defined(CONFIG_RTL_819X)
+__DRAM_GEN static RTL_DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
+__DRAM_GEN static RTL_DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);
+#else
 static DEFINE_PER_CPU(struct tasklet_head, tasklet_vec);
 static DEFINE_PER_CPU(struct tasklet_head, tasklet_hi_vec);
+#endif
 
 void __tasklet_schedule(struct tasklet_struct *t)
 {
@@ -626,6 +645,9 @@
 
 static int ksoftirqd(void * __bind_cpu)
 {
+	#if defined(CONFIG_RTL_819X)
+	set_user_nice(current, -20);
+	#endif
 	set_current_state(TASK_INTERRUPTIBLE);
 
 	while (!kthread_should_stop()) {
diff -uNr --ignore-all-space linux-2.6.30.9/kernel/timer.c linux-2.6.30.9-rsdk/kernel/timer.c
--- linux-2.6.30.9/kernel/timer.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/kernel/timer.c	2011-12-05 15:50:14.000000000 +0000
@@ -43,7 +43,13 @@
 #include <asm/div64.h>
 #include <asm/timex.h>
 #include <asm/io.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/rtl_types.h>
+#endif
 
+#if defined(CONFIG_RTL_819X)
+__DRAM_GEN
+#endif
 u64 jiffies_64 __cacheline_aligned_in_smp = INITIAL_JIFFIES;
 
 EXPORT_SYMBOL(jiffies_64);
@@ -77,9 +83,20 @@
 	struct tvec tv5;
 } ____cacheline_aligned;
 
+#if defined(CONFIG_RTL_819X)
+__DRAM_GEN
+#endif
 struct tvec_base boot_tvec_bases;
 EXPORT_SYMBOL(boot_tvec_bases);
+
+#if defined(CONFIG_RTL_819X) && !defined(CONFIG_SMP)
+#define RTL_DEFINE_PER_CPU(type, name)			\
+	PER_CPU_ATTRIBUTES PER_CPU_DEF_ATTRIBUTES			\
+	__typeof__(type) per_cpu__##name
+__DRAM_GEN static RTL_DEFINE_PER_CPU(struct tvec_base *, tvec_bases);
+#else
 static DEFINE_PER_CPU(struct tvec_base *, tvec_bases) = &boot_tvec_bases;
+#endif
 
 /*
  * Note that all tvec_bases are 2 byte aligned and lower bit of
@@ -1628,8 +1645,19 @@
 
 void __init init_timers(void)
 {
+#if defined(CONFIG_RTL_819X)
+	int err;
+
+	jiffies_64 = INITIAL_JIFFIES;
+	#if !defined(CONFIG_SMP)
+	__raw_get_cpu_var(tvec_bases) = &boot_tvec_bases;
+	#endif
+	err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
+				(void *)(long)smp_processor_id());
+#else
 	int err = timer_cpu_notify(&timers_nb, (unsigned long)CPU_UP_PREPARE,
 				(void *)(long)smp_processor_id());
+#endif
 
 	init_timer_stats();
 
diff -uNr --ignore-all-space linux-2.6.30.9/lib/decompress_bunzip2.c linux-2.6.30.9-rsdk/lib/decompress_bunzip2.c
--- linux-2.6.30.9/lib/decompress_bunzip2.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/lib/decompress_bunzip2.c	2011-12-05 15:50:14.000000000 +0000
@@ -45,12 +45,15 @@
 */
 
 
-#ifndef STATIC
+#ifdef STATIC
+#define PREBOOT
+#else
 #include <linux/decompress/bunzip2.h>
-#endif /* !STATIC */
+#include <linux/slab.h>
+#endif /* STATIC */
 
+#include <linux/decompress/bunzip2_mm.h>
 #include <linux/decompress/mm.h>
-#include <linux/slab.h>
 
 #ifndef INT_MAX
 #define INT_MAX 0x7fffffff
@@ -681,9 +684,7 @@
 	set_error_fn(error_fn);
 	if (flush)
 		outbuf = malloc(BZIP2_IOBUF_SIZE);
-	else
-		len -= 4; /* Uncompressed size hack active in pre-boot
-			     environment */
+
 	if (!outbuf) {
 		error("Could not allocate output bufer");
 		return -1;
@@ -733,4 +734,14 @@
 	return i;
 }
 
-#define decompress bunzip2
+#ifdef PREBOOT
+STATIC int INIT decompress(unsigned char *buf, int len,
+			int(*fill)(void*, unsigned int),
+			int(*flush)(void*, unsigned int),
+			unsigned char *outbuf,
+			int *pos,
+			void(*error_fn)(char *x))
+{
+	return bunzip2(buf, len - 4, fill, flush, outbuf, pos, error_fn);
+}
+#endif
diff -uNr --ignore-all-space linux-2.6.30.9/lib/decompress_inflate.c linux-2.6.30.9-rsdk/lib/decompress_inflate.c
--- linux-2.6.30.9/lib/decompress_inflate.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/lib/decompress_inflate.c	2011-12-05 15:50:14.000000000 +0000
@@ -19,13 +19,19 @@
 #include "zlib_inflate/inflate.h"
 
 #include "zlib_inflate/infutil.h"
+#include <linux/slab.h>
 
 #endif /* STATIC */
 
+#include <linux/decompress/inflate_mm.h>
 #include <linux/decompress/mm.h>
-#include <linux/slab.h>
 
-#define INBUF_LEN (16*1024)
+#define GZIP_IOBUF_SIZE (16*1024)
+
+static int nofill(void *buffer, unsigned int len)
+{
+	return -1;
+}
 
 /* Included from initramfs et al code */
 STATIC int INIT gunzip(unsigned char *buf, int len,
@@ -55,7 +61,7 @@
 	if (buf)
 		zbuf = buf;
 	else {
-		zbuf = malloc(INBUF_LEN);
+		zbuf = malloc(GZIP_IOBUF_SIZE);
 		len = 0;
 	}
 	if (!zbuf) {
@@ -76,8 +82,11 @@
 		goto gunzip_nomem4;
 	}
 
+	if (!fill)
+		fill = nofill;
+
 	if (len == 0)
-		len = fill(zbuf, INBUF_LEN);
+		len = fill(zbuf, GZIP_IOBUF_SIZE);
 
 	/* verify the gzip header */
 	if (len < 10 ||
@@ -113,7 +122,7 @@
 	while (rc == Z_OK) {
 		if (strm->avail_in == 0) {
 			/* TODO: handle case where both pos and fill are set */
-			len = fill(zbuf, INBUF_LEN);
+			len = fill(zbuf, GZIP_IOBUF_SIZE);
 			if (len < 0) {
 				rc = -1;
 				error("read error");
diff -uNr --ignore-all-space linux-2.6.30.9/lib/decompress_unlzma.c linux-2.6.30.9-rsdk/lib/decompress_unlzma.c
--- linux-2.6.30.9/lib/decompress_unlzma.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/lib/decompress_unlzma.c	2011-12-05 15:50:14.000000000 +0000
@@ -29,12 +29,15 @@
  *Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
  */
 
-#ifndef STATIC
+#ifdef STATIC
+#define PREBOOT
+#else
 #include <linux/decompress/unlzma.h>
+#include <linux/slab.h>
 #endif /* STATIC */
 
+#include <linux/decompress/unlzma_mm.h>
 #include <linux/decompress/mm.h>
-#include <linux/slab.h>
 
 #define	MIN(a, b) (((a) < (b)) ? (a) : (b))
 
@@ -80,6 +83,11 @@
 #define RC_MODEL_TOTAL_BITS 11
 
 
+static int nofill(void *buffer, unsigned int len)
+{
+	return -1;
+}
+
 /* Called twice: once at startup and once in rc_normalize() */
 static void INIT rc_read(struct rc *rc)
 {
@@ -95,7 +103,10 @@
 				       int (*fill)(void*, unsigned int),
 				       char *buffer, int buffer_size)
 {
+	if (fill)
 	rc->fill = fill;
+	else
+		rc->fill = nofill;
 	rc->buffer = (uint8_t *)buffer;
 	rc->buffer_size = buffer_size;
 	rc->buffer_end = rc->buffer + rc->buffer_size;
@@ -521,7 +532,7 @@
 
 
 
-STATIC inline int INIT unlzma(unsigned char *buf, int in_len,
+STATIC int INIT unlzma(unsigned char *buf, int in_len,
 			      int(*fill)(void*, unsigned int),
 			      int(*flush)(void*, unsigned int),
 			      unsigned char *output,
@@ -543,9 +554,7 @@
 	int ret = -1;
 
 	set_error_fn(error_fn);
-	if (!flush)
-		in_len -= 4; /* Uncompressed size hack active in pre-boot
-				environment */
+
 	if (buf)
 		inbuf = buf;
 	else
@@ -645,4 +654,17 @@
 	return ret;
 }
 
-#define decompress unlzma
+#ifdef PREBOOT
+STATIC int INIT decompress(unsigned char *buf, int in_len,
+			      int(*fill)(void*, unsigned int),
+			      int(*flush)(void*, unsigned int),
+			      unsigned char *output,
+			      int *posp,
+			      void(*error_fn)(char *x)
+	)
+{
+	return unlzma(buf, in_len - 4, fill, flush, output, posp, error_fn);
+}
+#elif defined(CONFIG_DECOMPRESS_LZMA_NEEDED)
+EXPORT_SYMBOL(unlzma);
+#endif
diff -uNr --ignore-all-space linux-2.6.30.9/lib/Kconfig linux-2.6.30.9-rsdk/lib/Kconfig
--- linux-2.6.30.9/lib/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/lib/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -10,6 +10,9 @@
 config BITREVERSE
 	tristate
 
+config RATIONAL
+	boolean
+
 config GENERIC_FIND_FIRST_BIT
 	bool
 
@@ -114,6 +117,9 @@
 config DECOMPRESS_LZMA
 	tristate
 
+config DECOMPRESS_LZMA_NEEDED
+	 boolean
+
 #
 # Generic allocator support is selected if needed
 #
@@ -191,4 +197,10 @@
 config NLATTR
 	bool
 
+#
+# Generic 64-bit atomic support is selected if needed
+#
+config GENERIC_ATOMIC64
+       bool
+
 endmenu
diff -uNr --ignore-all-space linux-2.6.30.9/Makefile linux-2.6.30.9-rsdk/Makefile
--- linux-2.6.30.9/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -2,7 +2,7 @@
 PATCHLEVEL = 6
 SUBLEVEL = 30
 EXTRAVERSION = .9
-NAME = Man-Eating Seals of Antiquity
+NAME = ON748BDD
 
 # *DOCUMENTATION*
 # To see a list of typical targets execute "make help"
@@ -159,18 +159,6 @@
 export srctree objtree VPATH TOPDIR
 
 
-# SUBARCH tells the usermode build what the underlying arch is.  That is set
-# first, and if a usermode build is happening, the "ARCH=um" on the command
-# line overrides the setting of ARCH below.  If a native build is happening,
-# then ARCH is assigned, getting whatever value it gets normally, and 
-# SUBARCH is subsequently ignored.
-
-SUBARCH := $(shell uname -m | sed -e s/i.86/i386/ -e s/sun4u/sparc64/ \
-				  -e s/arm.*/arm/ -e s/sa110/arm/ \
-				  -e s/s390x/s390/ -e s/parisc64/parisc/ \
-				  -e s/ppc.*/powerpc/ -e s/mips.*/mips/ \
-				  -e s/sh[234].*/sh/ )
-
 # Cross compiling and selecting different set of gcc/bin-utils
 # ---------------------------------------------------------------------------
 #
@@ -189,41 +177,23 @@
 # Alternatively CROSS_COMPILE can be set in the environment.
 # Default value for CROSS_COMPILE is not to prefix executables
 # Note: Some architectures assign CROSS_COMPILE in their arch/*/Makefile
-export KBUILD_BUILDHOST := $(SUBARCH)
-ARCH		?= $(SUBARCH)
-CROSS_COMPILE	?=
 
-# Architecture as present in compile.h
+ARCH		  := rlx
+#ARCH		  := mips
 UTS_MACHINE 	:= $(ARCH)
 SRCARCH 	:= $(ARCH)
+SUBARCH       := $(ARCH)
+ARCH_VMLINUX  := arch/$(ARCH)/bsp/vmlinux.lds
+#ARCH_VMLINUX  := arch/$(ARCH)/kernel/vmlinux.lds
 
-# Additional ARCH settings for x86
-ifeq ($(ARCH),i386)
-        SRCARCH := x86
-endif
-ifeq ($(ARCH),x86_64)
-        SRCARCH := x86
-endif
-
-# Additional ARCH settings for sparc
-ifeq ($(ARCH),sparc64)
-       SRCARCH := sparc
-endif
-
-# Additional ARCH settings for sh
-ifeq ($(ARCH),sh64)
-       SRCARCH := sh
-endif
-
-# Where to locate arch specific headers
-hdr-arch  := $(SRCARCH)
+CROSS_COMPILE ?= rsdk-linux-
 
-ifeq ($(ARCH),m68knommu)
-       hdr-arch  := m68k
-endif
+# Architecture as present in compile.h
 
 KCONFIG_CONFIG	?= .config
 
+export KBUILD_BUILDHOST := $(ARCH)
+
 # SHELL used by kbuild
 CONFIG_SHELL := $(shell if [ -x "$$BASH" ]; then echo $$BASH; \
 	  else if [ -x /bin/bash ]; then echo /bin/bash; \
@@ -344,7 +314,7 @@
 # Needed to be compatible with the O= option
 LINUXINCLUDE    := -Iinclude \
                    $(if $(KBUILD_SRC),-Iinclude2 -I$(srctree)/include) \
-                   -I$(srctree)/arch/$(hdr-arch)/include               \
+                   -I$(srctree)/arch/$(ARCH)/include               \
                    -include include/linux/autoconf.h
 
 KBUILD_CPPFLAGS := -D__KERNEL__
@@ -479,6 +449,13 @@
 net-y		:= net/
 libs-y		:= lib/
 core-y		:= usr/
+
+include .config
+
+ifeq ($(CONFIG_RTK_VOIP),y)
+drivers-y	+= rtk_voip/
+endif
+
 endif # KBUILD_EXTMOD
 
 ifeq ($(dot-config),1)
@@ -499,6 +476,8 @@
 # we execute the config step to be sure to catch updated Kconfig files
 include/config/auto.conf: $(KCONFIG_CONFIG) include/config/auto.conf.cmd
 	$(Q)$(MAKE) -f $(srctree)/Makefile silentoldconfig
+
+ictest-$(CONFIG_RTL_ICTEST)		:= ictestbsp/
 else
 # external modules needs include/linux/autoconf.h and include/config/auto.conf
 # but do not care if they are up-to-date. Use auto.conf to trigger the test
@@ -651,7 +630,7 @@
 
 vmlinux-dirs	:= $(patsubst %/,%,$(filter %/, $(init-y) $(init-m) \
 		     $(core-y) $(core-m) $(drivers-y) $(drivers-m) \
-		     $(net-y) $(net-m) $(libs-y) $(libs-m)))
+		     $(net-y) $(net-m) $(ictest-y) $(libs-y) $(libs-m)))
 
 vmlinux-alldirs	:= $(sort $(vmlinux-dirs) $(patsubst %/,%,$(filter %/, \
 		     $(init-n) $(init-) \
@@ -662,6 +641,7 @@
 core-y		:= $(patsubst %/, %/built-in.o, $(core-y))
 drivers-y	:= $(patsubst %/, %/built-in.o, $(drivers-y))
 net-y		:= $(patsubst %/, %/built-in.o, $(net-y))
+ictest-y		:= $(patsubst %/, %/built-in.o, $(ictest-y))
 libs-y1		:= $(patsubst %/, %/lib.a, $(libs-y))
 libs-y2		:= $(patsubst %/, %/built-in.o, $(libs-y))
 libs-y		:= $(libs-y1) $(libs-y2)
@@ -694,9 +674,9 @@
 # System.map is generated to document addresses of all kernel symbols
 
 vmlinux-init := $(head-y) $(init-y)
-vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y)
+vmlinux-main := $(core-y) $(libs-y) $(drivers-y) $(net-y) $(ictest-y)
 vmlinux-all  := $(vmlinux-init) $(vmlinux-main)
-vmlinux-lds  := arch/$(SRCARCH)/kernel/vmlinux.lds
+vmlinux-lds  := $(ARCH_VMLINUX) 
 export KBUILD_VMLINUX_OBJS := $(vmlinux-all)
 
 # Rule to link vmlinux - also used during CONFIG_KALLSYMS
@@ -976,7 +956,7 @@
 prepare2: prepare3 outputmakefile
 
 prepare1: prepare2 include/linux/version.h include/linux/utsrelease.h \
-                   include/asm include/config/auto.conf
+                   include/asm include/config/auto.conf ictestbsp_link
 	$(cmd_crmodverdir)
 
 archprepare: prepare1 scripts_basic
@@ -1029,6 +1009,18 @@
 	$(Q)$(check-symlink)
 	$(Q)$(create-symlink)
 
+define create-symlink-ictestbsp
+	if [ ! -L ictestbsp ]; then                                      \
+			echo '  SYMLINK ictestbsp -> ../../../ICTest/bsp/'; \
+			ln -fsn ../../../ICTest/bsp/ ictestbsp;    \
+	fi
+endef
+
+ictestbsp_link: FORCE
+ifeq ($(CONFIG_RTL_ICTEST),y)
+	@$(create-symlink-ictestbsp)
+endif
+
 # Generate some files
 # ---------------------------------------------------------------------------
 
@@ -1086,11 +1078,11 @@
 # Find out where the Kbuild file is located to support
 # arch/$(ARCH)/include/asm
 hdr-dir = $(strip                                                         \
-          $(if $(wildcard $(srctree)/arch/$(hdr-arch)/include/asm/Kbuild), \
-               arch/$(hdr-arch)/include/asm, include/asm-$(hdr-arch)))
+          $(if $(wildcard $(srctree)/arch/$(ARCH)/include/asm/Kbuild), \
+               arch/$(ARCH)/include/asm, include/asm-$(ARCH)))
 
 # If we do an all arch process set dst to asm-$(hdr-arch)
-hdr-dst = $(if $(KBUILD_HEADERS), dst=include/asm-$(hdr-arch), dst=include/asm)
+hdr-dst = $(if $(KBUILD_HEADERS), dst=include/asm-$(ARCH), dst=include/asm)
 
 PHONY += __headers
 __headers: include/linux/version.h scripts_basic FORCE
@@ -1103,7 +1095,7 @@
 PHONY += headers_install
 headers_install: __headers
 	$(if $(wildcard $(srctree)/$(hdr-dir)/Kbuild),, \
-	$(error Headers not exportable for the $(SRCARCH) architecture))
+	$(error Headers not exportable for the $(ARCH) architecture))
 	$(Q)$(MAKE) $(hdr-inst)=include
 	$(Q)$(MAKE) $(hdr-inst)=$(hdr-dir) $(hdr-dst)
 
@@ -1180,11 +1172,8 @@
 
 modules modules_install: FORCE
 	@echo
-	@echo "The present kernel configuration has modules disabled."
-	@echo "Type 'make config' and enable loadable module support."
-	@echo "Then build a kernel with module support enabled."
+	@echo "modules disabled in current config, skipping ..."
 	@echo
-	@exit 1
 
 endif # CONFIG_MODULES
 
@@ -1216,7 +1205,7 @@
 
 PHONY += $(clean-dirs) clean archclean
 $(clean-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+	- - - $(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
 
 clean: archclean $(clean-dirs)
 	$(call cmd,rmdirs)
@@ -1269,9 +1258,9 @@
 # Brief documentation of the typical targets used
 # ---------------------------------------------------------------------------
 
-boards := $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*_defconfig)
+boards := $(wildcard $(srctree)/arch/$(ARCH)/configs/*_defconfig)
 boards := $(notdir $(boards))
-board-dirs := $(dir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/*/*_defconfig))
+board-dirs := $(dir $(wildcard $(srctree)/arch/$(ARCH)/configs/*/*_defconfig))
 board-dirs := $(sort $(notdir $(board-dirs:/=)))
 
 help:
@@ -1317,9 +1306,9 @@
 	@echo  'Documentation targets:'
 	@$(MAKE) -f $(srctree)/Documentation/DocBook/Makefile dochelp
 	@echo  ''
-	@echo  'Architecture specific targets ($(SRCARCH)):'
+	@echo  'Architecture specific targets ($(ARCH)):'
 	@$(if $(archhelp),$(archhelp),\
-		echo '  No architecture specific help defined for $(SRCARCH)')
+		echo '  No architecture specific help defined for $(ARCH)')
 	@echo  ''
 	@$(if $(boards), \
 		$(foreach b, $(boards), \
@@ -1345,10 +1334,10 @@
 
 help-boards: $(help-board-dirs)
 
-boards-per-dir = $(notdir $(wildcard $(srctree)/arch/$(SRCARCH)/configs/$*/*_defconfig))
+boards-per-dir = $(notdir $(wildcard $(srctree)/arch/$(ARCH)/configs/$*/*_defconfig))
 
 $(help-board-dirs): help-%:
-	@echo  'Architecture specific targets ($(SRCARCH) $*):'
+	@echo  'Architecture specific targets ($(ARCH) $*):'
 	@$(if $(boards-per-dir), \
 		$(foreach b, $(boards-per-dir), \
 		printf "  %-24s - Build for %s\\n" $*/$(b) $(subst _defconfig,,$(b));) \
@@ -1419,7 +1408,7 @@
 
 PHONY += $(clean-dirs) clean
 $(clean-dirs):
-	$(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
+	- - - $(Q)$(MAKE) $(clean)=$(patsubst _clean_%,%,$@)
 
 clean:	rm-dirs := $(MODVERDIR)
 clean: rm-files := $(KBUILD_EXTMOD)/Module.symvers \
@@ -1480,15 +1469,7 @@
 
 PHONY += checkstack kernelrelease kernelversion
 
-# UML needs a little special treatment here.  It wants to use the host
-# toolchain, so needs $(SUBARCH) passed to checkstack.pl.  Everyone
-# else wants $(ARCH), including people doing cross-builds, which means
-# that $(SUBARCH) doesn't work here.
-ifeq ($(ARCH), um)
-CHECKSTACK_ARCH := $(SUBARCH)
-else
 CHECKSTACK_ARCH := $(ARCH)
-endif
 checkstack:
 	$(OBJDUMP) -d vmlinux $$(find . -name '*.ko') | \
 	$(PERL) $(src)/scripts/checkstack.pl $(CHECKSTACK_ARCH)
diff -uNr --ignore-all-space linux-2.6.30.9/mm/bootmem.c linux-2.6.30.9-rsdk/mm/bootmem.c
--- linux-2.6.30.9/mm/bootmem.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/bootmem.c	2011-12-05 15:50:14.000000000 +0000
@@ -318,6 +318,7 @@
 		pos = bdata->node_low_pfn;
 	}
 	BUG();
+	return 0;
 }
 
 /**
diff -uNr --ignore-all-space linux-2.6.30.9/mm/internal.h linux-2.6.30.9-rsdk/mm/internal.h
--- linux-2.6.30.9/mm/internal.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/internal.h	2011-12-05 15:50:14.000000000 +0000
@@ -74,7 +74,6 @@
 }
 #endif
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 /*
  * unevictable_migrate_page() called only from migrate_page_copy() to
  * migrate unevictable flag to new page.
@@ -86,11 +85,6 @@
 	if (TestClearPageUnevictable(old))
 		SetPageUnevictable(new);
 }
-#else
-static inline void unevictable_migrate_page(struct page *new, struct page *old)
-{
-}
-#endif
 
 #ifdef CONFIG_HAVE_MLOCKED_PAGE_BIT
 /*
diff -uNr --ignore-all-space linux-2.6.30.9/mm/Kconfig linux-2.6.30.9-rsdk/mm/Kconfig
--- linux-2.6.30.9/mm/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -128,11 +128,11 @@
 config MEMORY_HOTPLUG
 	bool "Allow for memory hot-add"
 	depends on SPARSEMEM || X86_64_ACPI_NUMA
-	depends on HOTPLUG && !HIBERNATION && ARCH_ENABLE_MEMORY_HOTPLUG
+	depends on HOTPLUG && !(HIBERNATION && !S390) && ARCH_ENABLE_MEMORY_HOTPLUG
 	depends on (IA64 || X86 || PPC64 || SUPERH || S390)
 
 comment "Memory hotplug is currently incompatible with Software Suspend"
-	depends on SPARSEMEM && HOTPLUG && HIBERNATION
+	depends on SPARSEMEM && HOTPLUG && HIBERNATION && !S390
 
 config MEMORY_HOTPLUG_SPARSE
 	def_bool y
@@ -203,25 +203,13 @@
 	def_bool y
 	depends on !ARCH_NO_VIRT_TO_BUS
 
-config UNEVICTABLE_LRU
-	bool "Add LRU list to track non-evictable pages"
-	default y
-	help
-	  Keeps unevictable pages off of the active and inactive pageout
-	  lists, so kswapd will not waste CPU time or have its balancing
-	  algorithms thrown off by scanning these pages.  Selecting this
-	  will use one page flag and increase the code size a little,
-	  say Y unless you know what you are doing.
-
-	  See Documentation/vm/unevictable-lru.txt for more information.
-
 config HAVE_MLOCK
 	bool
 	default y if MMU=y
 
 config HAVE_MLOCKED_PAGE_BIT
 	bool
-	default y if HAVE_MLOCK=y && UNEVICTABLE_LRU=y
+	default y if HAVE_MLOCK=y
 
 config MMU_NOTIFIER
 	bool
@@ -237,9 +225,9 @@
 	  For most ia64, ppc64 and x86 users with lots of address space
 	  a value of 65536 is reasonable and should cause no problems.
 	  On arm and other archs it should not be higher than 32768.
-	  Programs which use vm86 functionality would either need additional
-	  permissions from either the LSM or the capabilities module or have
-	  this protection disabled.
+	  Programs which use vm86 functionality or have some need to map
+	  this low address space will need CAP_SYS_RAWIO or disable this
+	  protection by setting the value to 0.
 
 	  This value can be changed after boot using the
 	  /proc/sys/vm/mmap_min_addr tunable.
diff -uNr --ignore-all-space linux-2.6.30.9/mm/Kconfig.debug linux-2.6.30.9-rsdk/mm/Kconfig.debug
--- linux-2.6.30.9/mm/Kconfig.debug	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/Kconfig.debug	2011-12-05 15:50:14.000000000 +0000
@@ -2,6 +2,7 @@
 	bool "Debug page memory allocations"
 	depends on DEBUG_KERNEL && ARCH_SUPPORTS_DEBUG_PAGEALLOC
 	depends on !HIBERNATION || !PPC && !SPARC
+	depends on !KMEMCHECK
 	---help---
 	  Unmap pages from the kernel linear mapping after free_pages().
 	  This results in a large slowdown, but helps to find certain types
diff -uNr --ignore-all-space linux-2.6.30.9/mm/memory.c linux-2.6.30.9-rsdk/mm/memory.c
--- linux-2.6.30.9/mm/memory.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/memory.c	2011-12-05 15:50:14.000000000 +0000
@@ -493,13 +493,13 @@
 {
 	unsigned long pfn = pte_pfn(pte);
 
-	if (HAVE_PTE_SPECIAL) {
+#ifdef __HAVE_ARCH_PTE_SPECIAL
 		if (likely(!pte_special(pte)))
 			goto check_pfn;
 		if (!(vma->vm_flags & (VM_PFNMAP | VM_MIXEDMAP)))
 			print_bad_pte(vma, addr, pte, NULL);
 		return NULL;
-	}
+#endif
 
 	/* !HAVE_PTE_SPECIAL case follows: */
 
@@ -518,7 +518,9 @@
 		}
 	}
 
+#ifdef __HAVE_ARCH_PTE_SPECIAL
 check_pfn:
+#endif
 	if (unlikely(pfn > highest_memmap_pfn)) {
 		print_bad_pte(vma, addr, pte, NULL);
 		return NULL;
@@ -1207,7 +1209,7 @@
 
 
 int __get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
-		     unsigned long start, int len, int flags,
+		     unsigned long start, int nr_pages, int flags,
 		struct page **pages, struct vm_area_struct **vmas)
 {
 	int i;
@@ -1217,7 +1219,7 @@
 	int ignore = !!(flags & GUP_FLAGS_IGNORE_VMA_PERMISSIONS);
 	int ignore_sigkill = !!(flags & GUP_FLAGS_IGNORE_SIGKILL);
 
-	if (len <= 0)
+	if (nr_pages <= 0)
 		return 0;
 	/* 
 	 * Require read or write permissions.
@@ -1269,7 +1271,7 @@
 				vmas[i] = gate_vma;
 			i++;
 			start += PAGE_SIZE;
-			len--;
+			nr_pages--;
 			continue;
 		}
 
@@ -1280,7 +1282,7 @@
 
 		if (is_vm_hugetlb_page(vma)) {
 			i = follow_hugetlb_page(mm, vma, pages, vmas,
-						&start, &len, i, write);
+						&start, &nr_pages, i, write);
 			continue;
 		}
 
@@ -1354,14 +1356,14 @@
 				vmas[i] = vma;
 			i++;
 			start += PAGE_SIZE;
-			len--;
-		} while (len && start < vma->vm_end);
-	} while (len);
+			nr_pages--;
+		} while (nr_pages && start < vma->vm_end);
+	} while (nr_pages);
 	return i;
 }
 
 int get_user_pages(struct task_struct *tsk, struct mm_struct *mm,
-		unsigned long start, int len, int write, int force,
+		unsigned long start, int nr_pages, int write, int force,
 		struct page **pages, struct vm_area_struct **vmas)
 {
 	int flags = 0;
@@ -1372,7 +1374,7 @@
 		flags |= GUP_FLAGS_FORCE;
 
 	return __get_user_pages(tsk, mm,
-				start, len, flags,
+				start, nr_pages, flags,
 				pages, vmas);
 }
 
@@ -1557,12 +1559,14 @@
 	 * refcount the page if pfn_valid is true (hence insert_page rather
 	 * than insert_pfn).
 	 */
-	if (!HAVE_PTE_SPECIAL && pfn_valid(pfn)) {
+#ifndef __HAVE_ARCH_PTE_SPECIAL
+	if (pfn_valid(pfn)) {
 		struct page *page;
 
 		page = pfn_to_page(pfn);
 		return insert_page(vma, addr, page, vma->vm_page_prot);
 	}
+#endif
 	return insert_pfn(vma, addr, pfn, vma->vm_page_prot);
 }
 EXPORT_SYMBOL(vm_insert_mixed);
diff -uNr --ignore-all-space linux-2.6.30.9/mm/mlock.c linux-2.6.30.9-rsdk/mm/mlock.c
--- linux-2.6.30.9/mm/mlock.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/mlock.c	2011-12-05 15:50:14.000000000 +0000
@@ -31,7 +31,6 @@
 }
 EXPORT_SYMBOL(can_do_mlock);
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 /*
  * Mlocked pages are marked with PageMlocked() flag for efficient testing
  * in vmscan and, possibly, the fault path; and to support semi-accurate
@@ -261,27 +260,6 @@
 	return retval;
 }
 
-#else /* CONFIG_UNEVICTABLE_LRU */
-
-/*
- * Just make pages present if VM_LOCKED.  No-op if unlocking.
- */
-static long __mlock_vma_pages_range(struct vm_area_struct *vma,
-				   unsigned long start, unsigned long end,
-				   int mlock)
-{
-	if (mlock && (vma->vm_flags & VM_LOCKED))
-		return make_pages_present(start, end);
-	return 0;
-}
-
-static inline int __mlock_posix_error_return(long retval)
-{
-	return 0;
-}
-
-#endif /* CONFIG_UNEVICTABLE_LRU */
-
 /**
  * mlock_vma_pages_range() - mlock pages in specified vma range.
  * @vma - the vma containing the specfied address range
diff -uNr --ignore-all-space linux-2.6.30.9/mm/page_alloc.c linux-2.6.30.9-rsdk/mm/page_alloc.c
--- linux-2.6.30.9/mm/page_alloc.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/page_alloc.c	2011-12-05 15:50:14.000000000 +0000
@@ -1783,7 +1783,7 @@
 		unsigned long alloc_end = addr + (PAGE_SIZE << order);
 		unsigned long used = addr + PAGE_ALIGN(size);
 
-		split_page(virt_to_page(addr), order);
+		split_page(virt_to_page((void *)addr), order);
 		while (used < alloc_end) {
 			free_page(used);
 			used += PAGE_SIZE;
@@ -1917,19 +1917,14 @@
 
 	printk("Active_anon:%lu active_file:%lu inactive_anon:%lu\n"
 		" inactive_file:%lu"
-//TODO:  check/adjust line lengths
-#ifdef CONFIG_UNEVICTABLE_LRU
 		" unevictable:%lu"
-#endif
 		" dirty:%lu writeback:%lu unstable:%lu\n"
 		" free:%lu slab:%lu mapped:%lu pagetables:%lu bounce:%lu\n",
 		global_page_state(NR_ACTIVE_ANON),
 		global_page_state(NR_ACTIVE_FILE),
 		global_page_state(NR_INACTIVE_ANON),
 		global_page_state(NR_INACTIVE_FILE),
-#ifdef CONFIG_UNEVICTABLE_LRU
 		global_page_state(NR_UNEVICTABLE),
-#endif
 		global_page_state(NR_FILE_DIRTY),
 		global_page_state(NR_WRITEBACK),
 		global_page_state(NR_UNSTABLE_NFS),
@@ -1953,9 +1948,7 @@
 			" inactive_anon:%lukB"
 			" active_file:%lukB"
 			" inactive_file:%lukB"
-#ifdef CONFIG_UNEVICTABLE_LRU
 			" unevictable:%lukB"
-#endif
 			" present:%lukB"
 			" pages_scanned:%lu"
 			" all_unreclaimable? %s"
@@ -1969,9 +1962,7 @@
 			K(zone_page_state(zone, NR_INACTIVE_ANON)),
 			K(zone_page_state(zone, NR_ACTIVE_FILE)),
 			K(zone_page_state(zone, NR_INACTIVE_FILE)),
-#ifdef CONFIG_UNEVICTABLE_LRU
 			K(zone_page_state(zone, NR_UNEVICTABLE)),
-#endif
 			K(zone->present_pages),
 			zone->pages_scanned,
 			(zone_is_all_unreclaimable(zone) ? "yes" : "no")
@@ -4352,9 +4343,13 @@
 			 */
 			zone->pages_min = tmp;
 		}
-
+#if defined(CONFIG_RTL_819X)
+		zone->pages_low = 128;
+		zone->pages_high = 145;
+#else
 		zone->pages_low   = zone->pages_min + (tmp >> 2);
 		zone->pages_high  = zone->pages_min + (tmp >> 1);
+#endif
 		setup_zone_migrate_reserve(zone);
 		spin_unlock_irqrestore(&zone->lock, flags);
 	}
@@ -4438,6 +4433,11 @@
 		min_free_kbytes = 128;
 	if (min_free_kbytes > 65536)
 		min_free_kbytes = 65536;
+	
+#if defined(CONFIG_RTL_819X)
+	min_free_kbytes = 128;
+#endif
+	
 	setup_per_zone_pages_min();
 	setup_per_zone_lowmem_reserve();
 	setup_per_zone_inactive_ratio();
diff -uNr --ignore-all-space linux-2.6.30.9/mm/pdflush.c linux-2.6.30.9-rsdk/mm/pdflush.c
--- linux-2.6.30.9/mm/pdflush.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/pdflush.c	2011-12-05 15:50:14.000000000 +0000
@@ -27,8 +27,13 @@
 /*
  * Minimum and maximum number of pdflush instances
  */
+#if defined(CONFIG_RTL_819X)
+#define MIN_PDFLUSH_THREADS	1
+#define MAX_PDFLUSH_THREADS	4
+#else
 #define MIN_PDFLUSH_THREADS	2
 #define MAX_PDFLUSH_THREADS	8
+#endif
 
 static void start_one_pdflush_thread(void);
 
diff -uNr --ignore-all-space linux-2.6.30.9/mm/rmap.c linux-2.6.30.9-rsdk/mm/rmap.c
--- linux-2.6.30.9/mm/rmap.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/rmap.c	2011-12-05 15:50:14.000000000 +0000
@@ -1202,7 +1202,6 @@
 	return ret;
 }
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 /**
  * try_to_munlock - try to munlock a page
  * @page: the page to be munlocked
@@ -1226,4 +1225,3 @@
 	else
 		return try_to_unmap_file(page, 1, 0);
 }
-#endif
diff -uNr --ignore-all-space linux-2.6.30.9/mm/vmscan.c linux-2.6.30.9-rsdk/mm/vmscan.c
--- linux-2.6.30.9/mm/vmscan.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/vmscan.c	2011-12-05 15:50:14.000000000 +0000
@@ -514,7 +514,6 @@
  *
  * lru_lock must not be held, interrupts must be enabled.
  */
-#ifdef CONFIG_UNEVICTABLE_LRU
 void putback_lru_page(struct page *page)
 {
 	int lru;
@@ -568,20 +567,6 @@
 	put_page(page);		/* drop ref from isolate */
 }
 
-#else /* CONFIG_UNEVICTABLE_LRU */
-
-void putback_lru_page(struct page *page)
-{
-	int lru;
-	VM_BUG_ON(PageLRU(page));
-
-	lru = !!TestClearPageActive(page) + page_is_file_cache(page);
-	lru_cache_add_lru(page, lru);
-	put_page(page);
-}
-#endif /* CONFIG_UNEVICTABLE_LRU */
-
-
 /*
  * shrink_page_list() returns the number of reclaimed pages
  */
@@ -2460,7 +2445,6 @@
 }
 #endif
 
-#ifdef CONFIG_UNEVICTABLE_LRU
 /*
  * page_evictable - test whether a page is evictable
  * @page: the page to test
@@ -2706,5 +2690,3 @@
 {
 	sysdev_remove_file(&node->sysdev, &attr_scan_unevictable_pages);
 }
-
-#endif
diff -uNr --ignore-all-space linux-2.6.30.9/mm/vmstat.c linux-2.6.30.9-rsdk/mm/vmstat.c
--- linux-2.6.30.9/mm/vmstat.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/mm/vmstat.c	2011-12-05 15:50:14.000000000 +0000
@@ -629,10 +629,8 @@
 	"nr_active_anon",
 	"nr_inactive_file",
 	"nr_active_file",
-#ifdef CONFIG_UNEVICTABLE_LRU
 	"nr_unevictable",
 	"nr_mlock",
-#endif
 	"nr_anon_pages",
 	"nr_mapped",
 	"nr_file_pages",
@@ -690,7 +688,6 @@
 	"htlb_buddy_alloc_success",
 	"htlb_buddy_alloc_fail",
 #endif
-#ifdef CONFIG_UNEVICTABLE_LRU
 	"unevictable_pgs_culled",
 	"unevictable_pgs_scanned",
 	"unevictable_pgs_rescued",
@@ -700,7 +697,6 @@
 	"unevictable_pgs_stranded",
 	"unevictable_pgs_mlockfreed",
 #endif
-#endif
 };
 
 static void zoneinfo_show_print(struct seq_file *m, pg_data_t *pgdat,
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br.c linux-2.6.30.9-rsdk/net/bridge/br.c
--- linux-2.6.30.9/net/bridge/br.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br.c	2011-12-05 15:50:14.000000000 +0000
@@ -22,6 +22,123 @@
 
 #include "br_private.h"
 
+#include <linux/proc_fs.h>
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+#include "lan_restrict.h"
+#endif
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+extern int __init br_filter_init(void);
+extern void __exit br_filter_exit(void);
+#endif
+
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+#include <linux/inetdevice.h>
+#define NIPQUAD_HTTP(addr) \
+	((unsigned char *)&addr)[0], \
+	((unsigned char *)&addr)[1], \
+	((unsigned char *)&addr)[2], \
+	((unsigned char *)&addr)[3]
+struct proc_dir_entry *http_file_server_root=NULL;
+struct proc_dir_entry *http_file_server_root_res1=NULL;
+extern unsigned int _lan_ip;
+extern unsigned int _lan_mask;
+void get_lan_ip_mask(void)
+{
+	struct in_device *in_dev;	
+	struct net_device *landev;
+	struct in_ifaddr *ifap = NULL;
+	
+      	if ((landev = __dev_get_by_name(&init_net, "br0")) != NULL){
+		in_dev=(struct in_device *)(landev->ip_ptr);
+		if (in_dev != NULL) {
+			for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+				if (strcmp("br0", ifap->ifa_label) == 0){
+					_lan_ip = ifap->ifa_address;
+					_lan_mask = ifap->ifa_mask;
+					return; 
+				}
+			}
+		}
+	}	
+}
+static int getLanIp_read(char *page, char **start, off_t off,
+		     int count, int *eof, void *data)
+{
+
+      int len=0;
+
+      len = sprintf(page, "Lan IP=%u.%u.%u.%u\n", NIPQUAD_HTTP(_lan_ip));
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+   	
+      return len;
+
+}
+static int getLanIp_write(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char tmpbuf[80];
+
+      if (count < 2)
+	    return -EFAULT;
+	    
+	if (buffer && !copy_from_user(tmpbuf, buffer, 80))  {
+		get_lan_ip_mask();
+		return count;
+	}	
+      return -EFAULT;
+}
+int __init http_file_init(void)
+{
+#if defined(CONFIG_PROC_FS)
+
+	struct proc_dir_entry *devices = NULL,*pvc = NULL,*svc = NULL;
+	http_file_server_root = proc_mkdir("http_file",NULL);
+	if (!http_file_server_root){
+		printk("create folder fail\n");
+		return -ENOMEM;
+	}
+	http_file_server_root_res1 = create_proc_entry("getLanIp", 0, http_file_server_root);
+	if (http_file_server_root_res1) {
+		http_file_server_root_res1->write_proc = getLanIp_write;
+		http_file_server_root_res1->read_proc = getLanIp_read;
+	}
+#endif
+	return 0;
+}
+
+void __exit http_file_exit(void)
+{
+#if defined(CONFIG_PROC_FS)
+	if (http_file_server_root_res1) {
+		remove_proc_entry("getLanIp", http_file_server_root);
+		http_file_server_root_res1 = NULL;
+	}
+	remove_proc_entry("http_file",NULL);
+#endif 
+}
+
+#endif
+
+
+
+
+
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <linux/inetdevice.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_multicast.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+#endif
+int IGMPProxyOpened = 0;
+
 int (*br_should_route_hook)(struct sk_buff *skb);
 
 static const struct stp_proto br_stp_proto = {
@@ -32,6 +149,1027 @@
 	.exit	= br_net_exit,
 };
 
+//it's for host-slave hostapd EAP hack  amd inband hostip hack
+#if defined (CONFIG_RTL_EAP_RELAY) || defined (CONFIG_RTK_INBAND_HOST_HACK)
+struct proc_dir_entry *procHostMac=NULL;
+unsigned char inband_Hostmac[6]={0x00,0xE0,0x4C,0x81,0x96,0xC1}; 
+
+static int br_hostmac_read_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%x:%x:%x:%x:%x:%x\n", inband_Hostmac[0],inband_Hostmac[1]
+	  										, inband_Hostmac[2],inband_Hostmac[3]
+	  										, inband_Hostmac[4],inband_Hostmac[5]);
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_hostmac_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char br_tmp[48]; 
+       int mac[6];		  
+	
+      if (count < 2) 
+	    return -EFAULT;
+
+	
+      if (buffer && !copy_from_user(&br_tmp, buffer, 48)) {
+	  	int num=0;	
+		int i=0;
+             num = sscanf(br_tmp, "%d:%d:%d:%d:%d:%d",&mac[0],&mac[1]
+	  										, &mac[2],&mac[3]
+	  										, &mac[4],&mac[5]);
+            
+		for(i=0;i<6;i++)
+			inband_Hostmac[i] = (unsigned char)(mac[i] & 0x000000ff);	  	 
+            
+                if (num !=  6) {
+                        printk("br_hostmac_write_proc invalid vlan parameter!\n");
+                }
+	    return count;
+      }
+      return -EFAULT;
+}
+#endif
+
+#if defined (CONFIG_RTK_INBAND_HOST_HACK)
+struct proc_dir_entry *procHostIp=NULL;
+unsigned int inband_HostIP=0xC0A801FE;
+int br_hackMac_enable=0; //only wps will need hack now!!!
+extern void init_listen_endpoint(); //from br_input.c
+static int br_hostip_read_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%d %d.%d.%d.%d\n", br_hackMac_enable,(unsigned char)((inband_HostIP>>24)&0x000000ff),
+								  	(unsigned char)((inband_HostIP>>16)&0x000000ff),
+								  	(unsigned char)((inband_HostIP>>8)&0x000000ff),
+								  	(unsigned char)((inband_HostIP>>0)&0x000000ff)
+								  	);
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+
+      return len;
+
+}
+
+static int br_hostip_write_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      char br_tmp[48]; 
+       unsigned int tmp_ip[4];		  
+	
+      if (count < 2) 
+	    return -EFAULT;
+
+	
+      if (buffer && !copy_from_user(&br_tmp, buffer, 48)) {
+	  	int num=0;	
+             num = sscanf(br_tmp, "%d %d.%d.%d.%d",&br_hackMac_enable,&tmp_ip[0],&tmp_ip[1]
+	  										, &tmp_ip[2],&tmp_ip[3]);
+            inband_HostIP =  ((tmp_ip[0] << 24) & 0xff000000) |
+						((tmp_ip[1] << 16) & 0x00ff0000) |
+						((tmp_ip[2] << 8) & 0x0000ff00) |
+						((tmp_ip[3] << 0) & 0x000000ff) ;
+							
+  		  		init_listen_endpoint();	//in br_input.c	            
+                if (num !=  5) {
+                        printk("br_hostip_write_proc invalid vlan parameter!\n");
+                }
+
+	    return count;
+      }
+      return -EFAULT;
+}
+#endif
+
+#if defined(CONFIG_RTL_WLAN_BLOCK_RELAY)
+int rtl_wlan_block_relay_enable=0;
+struct proc_dir_entry *procwlanblockrelay=NULL;
+static int br_wlanblockread_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+	int len;
+	len = sprintf(page, "wlanblock:%c\n\n",rtl_wlan_block_relay_enable+'0');
+	if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+}
+static int br_wlanblockwrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char block_tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&block_tmp, buffer, 1)) {
+		rtl_wlan_block_relay_enable = block_tmp - '0';
+		if(rtl_wlan_block_relay_enable)
+		{
+			rtl_wlan_block_relay_enable=1;
+		}
+		else
+			rtl_wlan_block_relay_enable=0;	
+	    	return count;
+      }
+	return -EFAULT;
+}
+#endif
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
+struct proc_dir_entry *procIgmpSnoop=NULL;
+int igmpsnoopenabled=0;	// Should be 0(default), set 1 when igmpproxy up!
+extern struct net_bridge *bridge0;
+static int br_igmpSnoopRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+      int i,j,k;
+   
+    len = sprintf(page, "igmpsnoopenabled:%c\n\n", igmpsnoopenabled + '0');
+    len += sprintf(page+len, "bridge multicast fdb:\n");
+
+
+	for (i = 0; i < BR_HASH_SIZE; i++) {
+		struct net_bridge_fdb_entry *f;
+		struct hlist_node *h, *n;
+		
+		j=0;
+		hlist_for_each_entry_safe(f, h, n, &bridge0->hash[i], hlist) {
+			if(MULTICAST_MAC(f->addr.addr) )
+			{
+				  len += sprintf(page+len,"[%d][%d]mCastMac:0x%x:%x:%x:%x:%x:%x,use_count is %d,ageing_timer is %lu\n",
+					i,j,f->addr.addr[0],f->addr.addr[1],f->addr.addr[2],f->addr.addr[3],f->addr.addr[4],f->addr.addr[5],f->use_count,(jiffies<f->ageing_timer) ?0:(jiffies-f->ageing_timer));
+				
+				for(k=0;k<FDB_IGMP_EXT_NUM;k++)
+				{
+					if(f->igmp_fdb_arr[k].valid)
+					{
+						len += sprintf(page+len,"\t<%d>clientMac:0x%x:%x:%x:%x:%x:%x,ageing_time:%lu\n",
+						k,f->igmp_fdb_arr[k].SrcMac[0],f->igmp_fdb_arr[k].SrcMac[1],f->igmp_fdb_arr[k].SrcMac[2],f->igmp_fdb_arr[k].SrcMac[3],f->igmp_fdb_arr[k].SrcMac[4],f->igmp_fdb_arr[k].SrcMac[5],(jiffies<f->igmp_fdb_arr[k].ageing_time) ?0:(jiffies-f->igmp_fdb_arr[k].ageing_time));
+					}
+				}
+
+				j++;
+				len += sprintf(page+len,"--------------------------------------------\n");
+			}
+
+		}
+		
+	}
+
+	
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_igmpSnoopWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char br_tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&br_tmp, buffer, 1)) {
+		igmpsnoopenabled = br_tmp - '0';
+		if(igmpsnoopenabled)
+		{
+			igmpsnoopenabled=1;
+		}
+		else
+		{
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)		
+			rtl865x_reinitMulticast();
+#endif
+			rtl_flushAllIgmpRecord();
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+static struct proc_dir_entry *procIgmpDb;
+extern int igmp_show(struct seq_file *s, void *v);
+extern int igmp_write(struct file *file, const char __user *buffer, size_t count, loff_t *data);
+int igmp_db_open(struct inode *inode, struct file *file)
+{
+        return(single_open(file, igmp_show, NULL));
+}
+
+int igmp_db_write(struct file *file, const char __user *buffer, size_t count, loff_t *data)
+{
+         igmp_write(file, buffer, count,data);
+}
+
+struct file_operations igmp_db_seq_file_operations = {
+        .open           = igmp_db_open,
+        .read           = seq_read,
+        .write		= igmp_db_write,
+        .llseek         = seq_lseek,
+        .release        = single_release,
+};
+
+struct proc_dir_entry *procMCastFastFwd=NULL;
+int ipMulticastFastFwd=0;
+int needCheckMfc=0;
+static int br_mCastFastFwdRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c,%c\n", ipMulticastFastFwd + '0',needCheckMfc + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_mCastFastFwdWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+	unsigned int tmp=0; 
+	char 		tmpbuf[512];
+	char		*strptr;
+	char		*tokptr;
+	
+
+	if (count < 2) 
+		return -EFAULT;
+
+	if (buffer && !copy_from_user(tmpbuf, buffer, count)) 
+	{
+		tmpbuf[count] = '\0';
+
+		strptr=tmpbuf;
+
+		
+		tokptr = strsep(&strptr,",");
+		if (tokptr==NULL)
+		{
+			tmp=simple_strtol(strptr, NULL, 0);
+			printk("tmp=%d\n",tmp);
+			if(tmp==0)
+			{
+				ipMulticastFastFwd=0;
+			}
+			return -EFAULT;
+		}
+		
+		ipMulticastFastFwd = simple_strtol(tokptr, NULL, 0);
+		//printk("ipMulticastFastFwd=%d\n",ipMulticastFastFwd);
+		if(ipMulticastFastFwd)
+		{
+			ipMulticastFastFwd=1;
+		}
+
+		tokptr = strsep(&strptr,",");
+		if (tokptr==NULL)
+		{
+			return -EFAULT;
+		}
+		
+		needCheckMfc = simple_strtol(tokptr, NULL, 0);
+
+		if(needCheckMfc)
+		{
+			needCheckMfc=1;
+		}
+
+		return count;
+	}
+	return -EFAULT;
+}
+
+struct proc_dir_entry *procIgmpQuery=NULL;
+int igmpQueryEnabled=0;	
+static int br_igmpQueryRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", igmpQueryEnabled + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_igmpQueryWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		igmpQueryEnabled = tmp - '0';
+		if(igmpQueryEnabled)
+		{
+			igmpQueryEnabled=1;
+		}
+		else
+		{
+			igmpQueryEnabled=0;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+struct proc_dir_entry *procIgmpVersion=NULL;
+int igmpVersion=2;
+static int br_igmpVersionRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", igmpVersion + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_igmpVersionWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		igmpVersion = tmp - '0';
+		if(igmpVersion>=3)
+		{
+			igmpVersion=3;
+		}
+		else if (igmpVersion<=2)
+		{
+			igmpVersion=2;
+		}
+		else
+		{
+			igmpVersion=2;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+
+/*igmpv3 general query*/
+static unsigned char igmpV3QueryBuf[64]={	0x01,0x00,0x5e,0x00,0x00,0x01,		/*destination mac*/
+									0x00,0x00,0x00,0x00,0x00,0x00,		/*offset:6*/
+									0x08,0x00,						/*offset:12*/
+									0x46,0x00,0x00,0x24,				/*offset:14*/
+									0x00,0x00,0x40,0x00,				/*offset:18*/
+									0x01,0x02,0x00,0x00,				/*offset:22*/
+									0x00,0x00,0x00,0x00,				/*offset:26,source ip*/
+									0xe0,0x00,0x00,0x01,				/*offset:30,destination ip*/
+									0x94,0x04,0x00,0x00,				/*offset:34,router alert option*/
+									0x11,0x01,0x00,0x00,				/*offset:38*/
+									0x00,0x00,0x00,0x00,				/*offset:42,queried multicast ip address*/
+									0x0a,0x3c,0x00,0x00,				/*offset:46*/
+									0x00,0x00,0x00,0x00,				/*offset:50*/
+									0x00,0x00,0x00,0x00,				/*offset:54*/
+									0x00,0x00,0x00,0x00,				/*offset:58*/
+									0x00,0x00							/*offset:62*/
+									
+								};			
+
+
+
+/*igmpv2 general query*/
+static unsigned char igmpV2QueryBuf[64]={	0x01,0x00,0x5e,0x00,0x00,0x01,		/*destination mac*/
+									0x00,0x00,0x00,0x00,0x00,0x00,		/*offset:6*/
+									0x08,0x00,						/*offset:12*/
+									0x45,0x00,0x00,0x1c,				/*offset:14*/
+									0x00,0x00,0x40,0x00,				/*offset:18*/
+									0x01,0x02,0x00,0x00,				/*offset:22*/
+									0x00,0x00,0x00,0x00,				/*offset:26*/
+									0xe0,0x00,0x00,0x01,				/*offset:30*/
+									0x11,0x01,0x0c,0xfa,				/*offset:34*/
+									0x00,0x00,0x00,0x00,				/*offset:38*/
+									0x00,0x00,0x00,0x00,				/*offset:42*/
+									0x00,0x00,0x00,0x00,				/*offset:46*/
+									0x00,0x00,0x00,0x00,				/*offset:50*/
+									0x00,0x00,0x00,0x00,				/*offset:54*/
+									0x00,0x00,0x00,0x00,				/*offset:58*/
+									0x00,0x00							/*offset:62*/
+									
+								};			
+
+
+
+static unsigned short  br_ipv4Checksum(unsigned char *pktBuf, unsigned int pktLen)
+{
+	/*note: the first bytes of  packetBuf should be two bytes aligned*/
+	unsigned int  checksum=0;
+	unsigned int  count=pktLen;
+	unsigned short   *ptr= (unsigned short *)pktBuf;	
+	
+	 while(count>1)
+	 {
+		  checksum+= ntohs(*ptr);
+		  ptr++;
+		  count -= 2;
+	 }
+	 
+	if(count>0)
+	{
+		checksum+= *(pktBuf+pktLen-1)<<8; /*the last odd byte is treated as bit 15~8 of unsigned short*/
+	}
+
+	/* Roll over carry bits */
+	checksum = (checksum >> 16) + (checksum & 0xffff);
+	checksum += (checksum >> 16);
+
+	/* Return checksum */
+	return ((unsigned short) ~ checksum);
+
+}
+
+static unsigned char* br_generateIgmpQuery(struct net_bridge * br)
+{
+	struct net_device* brDev = NULL;
+	unsigned short checkSum=0;
+	struct in_device *in_dev;	
+	struct net_device *landev;
+	struct in_ifaddr *ifap = NULL;
+	
+      
+	if(br==NULL)
+	{
+		return NULL;
+	}
+	
+	brDev = br->dev;
+	if(igmpVersion==3)
+	{
+		memcpy(&igmpV3QueryBuf[6],brDev->dev_addr,6);			/*set source mac address*/
+	}
+	else
+	{
+		memcpy(&igmpV2QueryBuf[6],brDev->dev_addr,6);			/*set source mac address*/
+	}
+	
+	/*set source ip address*/
+	if ((landev = __dev_get_by_name(&init_net, RTL_PS_BR0_DEV_NAME)) != NULL){
+		in_dev=(struct net_device *)(landev->ip_ptr);
+		if (in_dev != NULL) {
+			for (ifap=in_dev->ifa_list; ifap != NULL; ifap=ifap->ifa_next) {
+				if (strcmp(RTL_PS_BR0_DEV_NAME, ifap->ifa_label) == 0){
+					if(igmpVersion==3)
+					{
+						memcpy(&igmpV3QueryBuf[26],&ifap->ifa_address,4);
+					}
+					else
+					{
+						memcpy(&igmpV2QueryBuf[26],&ifap->ifa_address,4);
+					}
+					
+				}
+			}
+			
+		}
+	}
+	else
+	{
+		return NULL;
+	}
+	
+	if(igmpVersion==3)
+	{
+		igmpV3QueryBuf[24]=0;
+		igmpV3QueryBuf[25]=0;
+	}
+	else
+	{
+		igmpV2QueryBuf[24]=0;
+		igmpV2QueryBuf[25]=0;
+	}
+	
+	if(igmpVersion==3)
+	{
+		checkSum=br_ipv4Checksum(&igmpV3QueryBuf[14],24);
+	}
+	else
+	{
+		checkSum=br_ipv4Checksum(&igmpV2QueryBuf[14],20);
+	}
+
+	if(igmpVersion==3)
+	{
+		igmpV3QueryBuf[24]=(checkSum&0xff00)>>8;
+		igmpV3QueryBuf[25]=(checkSum&0x00ff);
+
+	}
+	else
+	{
+		igmpV2QueryBuf[24]=(checkSum&0xff00)>>8;
+		igmpV2QueryBuf[25]=(checkSum&0x00ff);
+
+	}
+	
+
+	if(igmpVersion==3)
+	{
+		igmpV3QueryBuf[40]=0;
+		igmpV3QueryBuf[41]=0;
+		checkSum=br_ipv4Checksum(&igmpV3QueryBuf[38],12);
+		igmpV3QueryBuf[40]=(checkSum&0xff00)>>8;
+		igmpV3QueryBuf[41]=(checkSum&0x00ff);
+	}
+	else
+	{
+		igmpV2QueryBuf[36]=0;
+		igmpV2QueryBuf[37]=0;
+		checkSum=br_ipv4Checksum(&igmpV2QueryBuf[34],8);
+		igmpV2QueryBuf[36]=(checkSum&0xff00)>>8;
+		igmpV2QueryBuf[37]=(checkSum&0x00ff);
+	}
+
+	if(igmpVersion==3)
+	{
+		return igmpV3QueryBuf;
+	}
+	else
+	{
+		return igmpV2QueryBuf;
+	}
+	
+	return NULL;
+}
+
+
+void br_igmpQueryTimerExpired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge*) arg;
+	unsigned char *igmpBuf=NULL;
+	struct sk_buff *skb;
+	struct sk_buff *skb2;
+	struct net_bridge_port *p, *n;
+	struct net_bridge_port *prev;
+	unsigned int fwdCnt=0;
+
+	if(IGMPProxyOpened)
+	{
+		return ;
+	}
+	
+	if(igmpQueryEnabled==0)
+	{
+		return;
+	}
+
+	
+	
+	skb=dev_alloc_skb(1024);
+	if(skb==NULL)
+	{
+		return;
+	}
+
+	memset(skb->data,64,0);
+	igmpBuf=br_generateIgmpQuery(br);
+	if(igmpBuf==NULL)
+	{
+		return;
+	}
+
+	memcpy(skb->data,igmpBuf,64);
+
+	skb->len = 0;
+	if(igmpVersion==3)
+	{
+		skb_put(skb, 50);
+	}
+	else
+	{
+		skb_put(skb, 42);
+	}
+	
+	skb->dev=br->dev;
+	
+	prev = NULL;
+	fwdCnt=0;
+	list_for_each_entry_safe(p, n, &br->port_list, list) 
+	{ 
+		if ((p->state == BR_STATE_FORWARDING) && (strncmp(p->dev->name, "peth",4)!=0) && (strncmp(p->dev->name, "pwlan",5)!=0)) 
+		{
+			if (prev != NULL) 
+			{                                                                                       
+				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+				{
+					br->dev->stats.tx_dropped++;
+					kfree_skb(skb);
+					return 0;
+				} 
+				skb2->dev=prev->dev;
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb2, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+				#endif                  
+				fwdCnt++;
+			}
+				                                                                               
+			prev = p;
+		}
+	}
+
+	if (prev != NULL) 
+	{
+		skb->dev=prev->dev;
+	       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+		prev->dev->hard_start_xmit(skb, prev->dev);
+		#else
+		prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+		#endif                            
+		fwdCnt++;
+	}
+
+	if(fwdCnt==0)
+	{
+		/*to avoid memory leak*/
+		kfree_skb(skb);
+	}
+	return;
+}
+
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+struct proc_dir_entry *procMldQuery=NULL;
+int mldQueryEnabled=0;	
+static int br_mldQueryRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+
+      int len;
+
+      len = sprintf(page, "%c\n", mldQueryEnabled + '0');
+
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+
+static int br_mldQueryWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+      unsigned char tmp; 
+      if (count < 2) 
+	    return -EFAULT;
+      
+	if (buffer && !copy_from_user(&tmp, buffer, 1)) {
+		mldQueryEnabled = tmp - '0';
+		if(mldQueryEnabled)
+		{
+			mldQueryEnabled=1;
+		}
+		else
+		{
+			mldQueryEnabled=0;
+		}
+	    return count;
+      }
+      return -EFAULT;
+}
+
+static unsigned char mldQueryBuf[86]={	0x33,0x33,0x00,0x00,0x00,0x01,		/*destination mac*/
+									0x00,0x00,0x00,0x00,0x00,0x00,		/*source mac*/	/*offset:6*/
+									0x86,0xdd,						/*ether type*/	/*offset:12*/
+									0x60,0x00,0x00,0x00,				/*version(1 byte)-traffic cliass(1 byte)- flow label(2 bytes)*/	/*offset:14*/
+									0x00,0x20,0x00,0x01,				/*payload length(2 bytes)-next header(1 byte)-hop limit(value:1 1byte)*//*offset:18*/
+									0xfe,0x80,0x00,0x00,				/*source address*/	/*offset:22*/
+									0x00,0x00,0x00,0x00,				/*be zero*/	/*offset:26*/
+									0x00,0x00,0x00,					/*upper 3 bytes mac address |0x02*/ /*offset:30*/
+									0xff,0xfe,						/*fixed*/
+									0x00,0x00,0x00,					/*lowert 3 bytes mac address*/	 /*offset:35*/
+									0xff,0x02,0x00,0x00,				/*destination address is fixed as FF02::1*/	/*offset:38*/
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x01,			
+									0x3a,0x00,						/*icmp type(1 byte)-length(1 byte)*/	 /*offset:54*/
+									0x05,0x02,0x00,0x00,				/*router alert option*/
+									0x01,0x00,						/*padN*/
+									0x82,0x00,						/*type(query:0x82)-code(0)*/	/*offset:62*/
+									0x00,0x00,						/*checksum*/	/*offset:64*/
+									0x00,0x0a,						/*maximum reponse code*/
+									0x00,0x00,						/*reserved*/
+									0x00,0x00,0x00,0x00,				/*multicast address,fixed as 0*/
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x00
+								};			
+
+static unsigned char ipv6PseudoHdrBuf[40]=	{	
+									0xfe,0x80,0x00,0x00,				/*source address*/
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0xff,			
+									0xfe,0x00,0x00,0x00,			 	
+									0xff,0x02,0x00,0x00,				/*destination address*/
+									0x00,0x00,0x00,0x00,		
+									0x00,0x00,0x00,0x00,			
+									0x00,0x00,0x00,0x01,				
+									0x00,0x00,0x00,0x18,				/*upper layer packet length*/
+									0x00,0x00,0x00,0x3a					/*zero padding(3 bytes)-next header(1 byte)*/
+									};		
+
+static unsigned short br_ipv6Checksum(unsigned char *pktBuf, unsigned int pktLen, unsigned char  *ipv6PseudoHdrBuf)
+{
+	unsigned int  checksum=0;
+	unsigned int count=pktLen;
+	unsigned short   *ptr;
+
+	/*compute ipv6 pseudo-header checksum*/
+	ptr= (unsigned short  *) (ipv6PseudoHdrBuf);	
+	for(count=0; count<20; count++) /*the pseudo header is 40 bytes long*/
+	{
+		  checksum+= ntohs(*ptr);
+		  ptr++;
+	}
+	
+	/*compute the checksum of mld buffer*/
+	 count=pktLen;
+	 ptr=(unsigned short  *) (pktBuf);	
+	 while(count>1)
+	 {
+		  checksum+= ntohs(*ptr);
+		  ptr++;
+		  count -= 2;
+	 }
+	 
+	if(count>0)
+	{
+		checksum+= *(pktBuf+pktLen-1)<<8; /*the last odd byte is treated as bit 15~8 of unsigned short*/
+	}
+
+	/* Roll over carry bits */
+	checksum = (checksum >> 16) + (checksum & 0xffff);
+	checksum += (checksum >> 16);
+
+	/* Return checksum */
+	return ((uint16) ~ checksum);
+	
+}
+static unsigned char* br_generateMldQuery(struct net_bridge * br)
+{
+	struct net_device* brDev = NULL;
+	unsigned short checkSum=0;
+	if(br==NULL)
+	{
+		return NULL;
+	}
+	
+	brDev = br->dev;
+	
+	memcpy(&mldQueryBuf[6],brDev->dev_addr,6);			/*set source mac address*/
+	
+	memcpy(&mldQueryBuf[30],brDev->dev_addr,3);		/*set  mld query packet source ip address*/
+	mldQueryBuf[30]=mldQueryBuf[30]|0x02;		
+	memcpy(&mldQueryBuf[35],&brDev->dev_addr[3],3);		
+
+	
+	memcpy(ipv6PseudoHdrBuf,&mldQueryBuf[22],16);			/*set pseudo-header source ip*/
+
+	mldQueryBuf[64]=0;/*reset checksum*/
+	mldQueryBuf[65]=0;
+	checkSum=br_ipv6Checksum(&mldQueryBuf[62],24,ipv6PseudoHdrBuf);
+	
+	mldQueryBuf[64]=(checkSum&0xff00)>>8;
+	mldQueryBuf[65]=(checkSum&0x00ff);
+	return mldQueryBuf;
+	
+	
+}
+
+
+void br_mldQueryTimerExpired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge*) arg;
+	struct sk_buff *skb;
+	struct sk_buff *skb2;
+	struct net_bridge_port *p, *n;
+	struct net_bridge_port *prev;
+	unsigned int fwdCnt=0;
+	unsigned char *mldBuf=NULL;
+
+	if(mldQueryEnabled==0)
+	{
+		return;
+	}
+	
+	skb=dev_alloc_skb(1024);
+	if(skb==NULL)
+	{
+		return;
+	}
+	
+	memset(skb->data,86,0);
+	mldBuf=br_generateMldQuery(br);
+	if(mldBuf==NULL)
+	{
+		return;
+	}
+	
+	memcpy(skb->data,mldBuf,86);
+	skb->len = 0;
+	skb_put(skb, 86);
+ 
+	prev = NULL;
+	fwdCnt=0;
+	list_for_each_entry_safe(p, n, &br->port_list, list) 
+	{ 
+		if ((p->state == BR_STATE_FORWARDING) && (strncmp(p->dev->name, "peth",4)!=0) && (strncmp(p->dev->name, "pwlan",5)!=0)) 
+		{
+			if (prev != NULL) 
+			{                                                                                       
+				if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+				{
+					br->dev->stats.tx_dropped++;
+					kfree_skb(skb);
+					return 0;
+				} 
+				skb2->dev=prev->dev;
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb2, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+				#endif                  
+				fwdCnt++;
+			}
+				                                                                               
+			prev = p;
+		}
+	}
+
+	if (prev != NULL) 
+	{
+		skb->dev=prev->dev;
+	       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+		prev->dev->hard_start_xmit(skb, prev->dev);
+		#else
+		prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+		#endif                            
+		fwdCnt++;
+	}
+
+	if(fwdCnt==0)
+	{
+		/*to avoid memory leak*/
+		kfree_skb(skb);
+	}
+	
+	return;
+}
+#endif
+
+static unsigned int mCastQueryTimerCnt=0;
+void br_mCastQueryTimerExpired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge*) arg;
+	
+	mod_timer(&br->mCastQuerytimer, jiffies+MCAST_QUERY_INTERVAL*HZ);
+	
+	if(mCastQueryTimerCnt%2==0)
+	{
+		br_igmpQueryTimerExpired(arg);
+	}
+	else
+	{
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+		br_mldQueryTimerExpired(arg);
+		#endif
+	}
+	mCastQueryTimerCnt++;
+	
+	return;
+}
+
+extern struct net_bridge *find_br_by_name(char *name);
+
+void br_signal_igmpProxy(void)
+{
+
+	struct task_struct *task;
+	struct net_bridge *br;
+
+	br = find_br_by_name(RTL_PS_BR0_DEV_NAME);
+	if(br==NULL)
+	{
+		return;
+	}
+
+	if(br->igmpProxy_pid==0)
+	{
+		return;
+	}
+	
+	read_lock(&tasklist_lock);
+//	task = find_task_by_pid(br->igmpProxy_pid);
+	task = find_task_by_vpid(br->igmpProxy_pid);
+	read_unlock(&tasklist_lock);
+	if(task)
+	{
+		send_sig(SIGUSR2,task,0);
+	}
+	else {
+	    //printk("Path selection daemon pid: %d does not exist\n", br->mesh_pathsel_pid);
+	}
+}
+
+#endif
+
+struct proc_dir_entry *procIgmpProxy = NULL;
+static int br_igmpProxyRead_proc(char *page, char **start, off_t off, 
+		int count, int *eof, void *data)
+{
+      int len;
+      len = sprintf(page, "%c\n", IGMPProxyOpened + '0');
+
+      if (len <= off+count) *eof = 1;
+      *start = page + off;
+      len -= off;
+      if (len>count) len = count;
+      if (len<0) len = 0;
+      return len;
+
+}
+static int br_igmpProxyWrite_proc(struct file *file, const char *buffer,
+		      unsigned long count, void *data)
+{
+    unsigned char chartmp; 
+	  
+    if (count > 1) {	//call from shell
+      	if (buffer && !copy_from_user(&chartmp, buffer, 1)) {
+	    	IGMPProxyOpened = chartmp - '0';			
+	    }
+	}else if(count==1){//call from demon(demon direct call br's ioctl)
+			//memcpy(&chartmp,buffer,1);
+			if(buffer){
+				get_user(chartmp,buffer);	
+		    		IGMPProxyOpened = chartmp - '0';
+			}else
+				return -EFAULT;
+
+	}else{
+
+		return -EFAULT;
+	}
+	return count;
+}
+
 static int __init br_init(void)
 {
 	int err;
@@ -50,6 +1188,84 @@
 	if (err)
 		goto err_out1;
 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+	lan_restrict_init();
+#endif
+
+#if defined (CONFIG_RTL_EAP_RELAY) || defined (CONFIG_RTK_INBAND_HOST_HACK)
+		procHostMac = create_proc_entry("br_hostmac", 0, NULL);
+		if (procHostMac) {
+		    procHostMac->read_proc = br_hostmac_read_proc;
+		    procHostMac->write_proc = br_hostmac_write_proc;
+		}
+#endif
+
+#if defined (CONFIG_RTK_INBAND_HOST_HACK)
+		procHostIp = create_proc_entry("br_hostip", 0, NULL);
+		if (procHostIp) {
+		    procHostIp->read_proc = br_hostip_read_proc;
+		    procHostIp->write_proc = br_hostip_write_proc;
+		}
+#endif
+
+
+#if defined(CONFIG_PROC_FS) && defined (CONFIG_RTL_WLAN_BLOCK_RELAY)
+		procwlanblockrelay = create_proc_entry("br_wlanblock", 0, NULL);
+		if(procwlanblockrelay) {
+			procwlanblockrelay->read_proc = br_wlanblockread_proc;
+			procwlanblockrelay->write_proc = br_wlanblockwrite_proc;
+		}
+#endif
+
+#if defined (CONFIG_PROC_FS) && defined (CONFIG_RTL_IGMP_SNOOPING)	
+		procIgmpSnoop = create_proc_entry("br_igmpsnoop", 0, NULL);
+		if (procIgmpSnoop) {
+		    procIgmpSnoop->read_proc = br_igmpSnoopRead_proc;
+		    procIgmpSnoop->write_proc = br_igmpSnoopWrite_proc;
+		}
+
+		procIgmpDb=create_proc_entry("br_igmpDb", 0, NULL);
+		if(procIgmpDb != NULL)
+		{
+			procIgmpDb->proc_fops = &igmp_db_seq_file_operations;
+
+		}
+
+		procMCastFastFwd= create_proc_entry("br_mCastFastFwd", 0, NULL);
+		if (procMCastFastFwd) {
+		    procMCastFastFwd->read_proc = br_mCastFastFwdRead_proc;
+		    procMCastFastFwd->write_proc = br_mCastFastFwdWrite_proc;
+		}
+
+		procIgmpVersion= create_proc_entry("br_igmpVersion", 0, NULL);
+		if (procIgmpVersion) {
+		    procIgmpVersion->read_proc = br_igmpVersionRead_proc;
+		    procIgmpVersion->write_proc = br_igmpVersionWrite_proc;
+		}
+		
+		procIgmpQuery= create_proc_entry("br_igmpquery", 0, NULL);
+		if (procIgmpQuery) {
+		    procIgmpQuery->read_proc = br_igmpQueryRead_proc;
+		    procIgmpQuery->write_proc = br_igmpQueryWrite_proc;
+		}
+
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+		procMldQuery= create_proc_entry("br_mldquery", 0, NULL);
+		if (procMldQuery) {
+		    procMldQuery->read_proc = br_mldQueryRead_proc;
+		    procMldQuery->write_proc = br_mldQueryWrite_proc;
+		}
+#endif
+#endif
+
+#if  defined (CONFIG_PROC_FS) 	
+		procIgmpProxy = create_proc_entry("br_igmpProxy", 0, NULL);
+		if (procIgmpProxy) {
+		    procIgmpProxy->read_proc = br_igmpProxyRead_proc;
+		    procIgmpProxy->write_proc = br_igmpProxyWrite_proc;
+		}
+#endif
 	err = br_netfilter_init();
 	if (err)
 		goto err_out2;
@@ -67,7 +1283,12 @@
 
 	br_fdb_get_hook = br_fdb_get;
 	br_fdb_put_hook = br_fdb_put;
-
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+	br_filter_init();
+#endif
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	http_file_init();
+#endif	
 	return 0;
 err_out4:
 	unregister_netdevice_notifier(&br_device_notifier);
@@ -86,6 +1307,47 @@
 {
 	stp_proto_unregister(&br_stp_proto);
 
+#if  defined (CONFIG_PROC_FS) && defined (CONFIG_RTL_IGMP_SNOOPING)
+	if (procIgmpSnoop) {
+		remove_proc_entry("br_igmpsnoop", procIgmpSnoop);		
+		procIgmpSnoop = NULL;
+	}
+
+	if(procIgmpDb!=NULL)
+	{
+		remove_proc_entry("br_igmpDb", procIgmpDb);
+	}
+	
+	if (procMCastFastFwd) {
+		remove_proc_entry("br_mCastFastFwd", procMCastFastFwd);		
+		procMCastFastFwd = NULL;
+	}
+
+	if (procIgmpVersion) {
+	 	 remove_proc_entry("br_igmpVersion", procIgmpVersion);		
+		procIgmpVersion = NULL;
+	}
+	
+	if (procIgmpQuery) {
+	 	 remove_proc_entry("br_igmpquery", procIgmpQuery);		
+		procIgmpQuery = NULL;
+	}
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+	if (procMldQuery) {
+		 remove_proc_entry("br_mldquery", procMldQuery);		
+		procMldQuery = NULL;
+	}
+#endif	
+
+#endif	
+
+#if  defined (CONFIG_PROC_FS) 
+	if (procIgmpProxy) {
+		remove_proc_entry("br_igmpProxy", procIgmpProxy);		
+		procIgmpProxy = NULL;
+	}
+#endif
 	br_netlink_fini();
 	unregister_netdevice_notifier(&br_device_notifier);
 	brioctl_set(NULL);
@@ -100,6 +1362,12 @@
 
 	br_handle_frame_hook = NULL;
 	br_fdb_fini();
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+	br_filter_exit();
+#endif
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	http_file_exit();
+#endif	
 }
 
 EXPORT_SYMBOL(br_should_route_hook);
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_device.c linux-2.6.30.9-rsdk/net/bridge/br_device.c
--- linux-2.6.30.9/net/bridge/br_device.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_device.c	2011-12-05 15:50:14.000000000 +0000
@@ -19,6 +19,47 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+/*2008-01-15,for porting igmp snooping to linux kernel 2.6*/
+#include <linux/ip.h>
+#include <linux/in.h>
+#include <linux/igmp.h>
+#include <net/checksum.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+extern int igmpsnoopenabled;
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+extern int mldSnoopEnabled;
+#endif
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+#include <net/rtl/rtl865x_multicast.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+#endif
+extern unsigned int br0SwFwdPortMask;
+extern unsigned int brIgmpModuleIndex;
+extern unsigned int nicIgmpModuleIndex;
+#endif
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
+												unsigned int srcPort,unsigned int srcVlanId, 
+												unsigned int srcIpAddr, unsigned int destIpAddr);
+#endif
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
+#endif
+
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+#define ETHER_HDR_LEN 14
+#define ARP_HRD_LEN 8
+extern unsigned char inband_Hostmac[];
+extern int br_hackMac_enable;
+extern void check_listen_info(struct sk_buff *skb);
+#endif
+
 /* net device transmit always called with no BH (preempt_disabled) */
 int br_dev_xmit(struct sk_buff *skb, struct net_device *dev)
 {
@@ -26,14 +67,139 @@
 	const unsigned char *dest = skb->data;
 	struct net_bridge_fdb_entry *dst;
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+	struct iphdr *iph=NULL;
+	unsigned char proto=0;
+	unsigned char reserved=0;
+#if defined (CONFIG_RTL_MLD_SNOOPING) 	
+	struct ipv6hdr *ipv6h=NULL;
+#endif
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo multicastFwdInfo;
+	int ret=FAILED;
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	unsigned int srcPort=skb->srcPort;
+	unsigned int srcVlanId=skb->srcVlanId;
+#endif
+#endif	
+
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+// send all paket that from local with hostmac (after bridge mac learning)	
+	//hex_dump(skb->data, 48);
+	if(br_hackMac_enable){			
+		if(memcmp(skb->data,inband_Hostmac,6)) //if destmac is not to host
+			memcpy(skb->data+6, inband_Hostmac,6); //then modify source mac to hostmac
+		else
+			goto ap_hcm_out;
+		// if it is arp then sender mac also need modify to hostmac
+		if( (skb->data[12] == 0x08) && (skb->data[13] == 0x06) ) //0806 = ARP
+		{
+			memcpy(skb->data+ETHER_HDR_LEN+ARP_HRD_LEN, inband_Hostmac,6); //modify arp sender mac			
+		}
+		else if((skb->data[12] == 0x08) && (skb->data[13] == 0x00)) //IP
+		{
+			check_listen_info(skb);
+		}
+	}
+ap_hcm_out:		
+#endif
+
 	dev->stats.tx_packets++;
 	dev->stats.tx_bytes += skb->len;
 
 	skb_reset_mac_header(skb);
 	skb_pull(skb, ETH_HLEN);
 
+
 	if (dest[0] & 1)
+	{
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+		if(igmpsnoopenabled) 
+		{	
+			if(MULTICAST_MAC(dest))
+			{
+			
+				iph=(struct iphdr *)skb_network_header(skb);
+				proto =  iph->protocol;
+				#if 0
+				if(( iph->daddr&0xFFFFFF00)==0xE0000000)
+				{
+				        reserved=1;
+				}
+				#endif
+
+				if( iph->daddr == 0xEFFFFFFA)
+				{
+					/*for microsoft upnp*/
+					reserved=1;
+				}
+				
+				if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))  && (reserved ==0))
+				{
+					multicastDataInfo.ipVersion=4;
+					multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
+					multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+			
+					br_multicast_deliver(br, multicastFwdInfo.fwdPortMask, skb, 0);
+					if((ret==SUCCESS) && (multicastFwdInfo.cpuFlag==0))
+					{
+						#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+						if((srcVlanId!=0) && (srcPort!=0xFFFF))
+						{
+							#if defined(CONFIG_RTK_VLAN_SUPPORT)
+							if(rtk_vlan_support_enable == 0)
+							{
+								rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+							}
+							#else
+							rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+							#endif
+						}
+						#endif		
+					}
+				
+				}
+				else
+				{
+					br_flood_deliver(br, skb);
+				}
+
+				
+			}
+#if defined(CONFIG_RTL_MLD_SNOOPING)	
+			else if(mldSnoopEnabled && IPV6_MULTICAST_MAC(dest))
+			{
+				ipv6h=(struct ipv6hdr *)skb_network_header(skb);
+				proto=re865x_getIpv6TransportProtocol(ipv6h);
+				if ((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
+				{
+					multicastDataInfo.ipVersion=6;
+					memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
+					memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+					br_multicast_deliver(br, multicastFwdInfo.fwdPortMask, skb, 0);
+				}
+				else
+				{
 		br_flood_deliver(br, skb);
+				}
+			}
+#endif		
+			else
+			{
+				br_flood_deliver(br, skb);
+			}
+		
+		}
+		else
+		{ 
+			br_flood_deliver(br, skb);
+		}	
+#else
+		br_flood_deliver(br, skb);
+#endif
+	}
 	else if ((dst = __br_fdb_get(br, dest)) != NULL)
 		br_deliver(dst->dst, skb);
 	else
@@ -180,8 +346,94 @@
 	SET_ETHTOOL_OPS(dev, &br_ethtool_ops);
 	dev->tx_queue_len = 0;
 	dev->priv_flags = IFF_EBRIDGE;
+#if defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+			NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
+			NETIF_F_NETNS_LOCAL | NETIF_F_GSO|NETIF_F_GRO|NETIF_F_LRO;
 
+#elif defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP)
+        dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
+                        NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
+                        NETIF_F_NETNS_LOCAL | NETIF_F_GSO|NETIF_F_GRO;
+#else
 	dev->features = NETIF_F_SG | NETIF_F_FRAGLIST | NETIF_F_HIGHDMA |
 			NETIF_F_GSO_MASK | NETIF_F_NO_CSUM | NETIF_F_LLTX |
 			NETIF_F_NETNS_LOCAL | NETIF_F_GSO;
+#endif
+}
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+
+int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
+												unsigned int srcPort,unsigned int srcVlanId, 
+												unsigned int srcIpAddr, unsigned int destIpAddr)
+{
+	int ret;
+	//int fwdDescCnt;
+	//unsigned short port_bitmask=0;
+
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo  multicastFwdInfo;
+	
+	rtl865x_tblDrv_mCast_t * existMulticastEntry;
+	rtl865x_mcast_fwd_descriptor_t  fwdDescriptor;
+
+	#if 0
+	printk("%s:%d,srcPort is %d,srcVlanId is %d,srcIpAddr is 0x%x,destIpAddr is 0x%x\n",__FUNCTION__,__LINE__,srcPort,srcVlanId,srcIpAddr,destIpAddr);
+	#endif
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0)
+	{
+		return -1;
 }
+
+	if(brFwdPortMask & br0SwFwdPortMask)
+	{
+		return -1;
+	}
+	//printk("%s:%d,destIpAddr is 0x%x, srcIpAddr is 0x%x, srcVlanId is %d, srcPort is %d\n",__FUNCTION__,__LINE__,destIpAddr, srcIpAddr, srcVlanId, srcPort);
+	existMulticastEntry=rtl865x_findMCastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort);
+	if(existMulticastEntry!=NULL)
+	{
+		/*it's already in cache */
+		return 0;
+
+	}
+
+	if(brFwdPortMask==0)
+	{
+		rtl865x_blockMulticastFlow(srcVlanId, srcPort, srcIpAddr, destIpAddr);
+		return 0;
+	}
+	
+	multicastDataInfo.ipVersion=4;
+	multicastDataInfo.sourceIp[0]=  srcIpAddr;
+	multicastDataInfo.groupAddr[0]=  destIpAddr;
+
+	/*add hardware multicast entry*/
+
+	memset(&fwdDescriptor, 0, sizeof(rtl865x_mcast_fwd_descriptor_t ));
+	strcpy(fwdDescriptor.netifName,"eth*");
+	fwdDescriptor.fwdPortMask=0xFFFFFFFF;
+	
+	ret= rtl_getMulticastDataFwdInfo(nicIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+	if(ret!=0)
+	{
+		return -1;
+	}
+	else
+	{
+		if(multicastFwdInfo.cpuFlag)
+		{
+			fwdDescriptor.toCpu=1;
+		}
+		fwdDescriptor.fwdPortMask=multicastFwdInfo.fwdPortMask & (~(1<<srcPort));
+	}
+
+	rtl865x_addMulticastEntry(destIpAddr, srcIpAddr, (unsigned short)srcVlanId, (unsigned short)srcPort, 
+						&fwdDescriptor, 1, 0, 0, 0);
+	
+	return 0;
+}
+
+#endif
+
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_fdb.c linux-2.6.30.9-rsdk/net/bridge/br_fdb.c
--- linux-2.6.30.9/net/bridge/br_fdb.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_fdb.c	2011-12-05 15:50:14.000000000 +0000
@@ -24,6 +24,33 @@
 #include <asm/unaligned.h>
 #include "br_private.h"
 
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_fdb_api.h>
+
+#if	defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+
+#if defined (CONFIG_RTL_LAYERED_DRIVER_L2)&& defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+#include "lan_restrict.h"
+#endif
+
+#endif	/*	defined(CONFIG_RTL_819X)	*/
+
+#if defined(CONFIG_RTL_819X)
+static int fdb_entry_max = 2048;
+static int fdb_entry_num = 0;
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+extern int IGMPProxyOpened;
+void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
+void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
+void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn );
+static void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent);
+#endif
+
 static struct kmem_cache *br_fdb_cache __read_mostly;
 static int fdb_insert(struct net_bridge *br, struct net_bridge_port *source,
 		      const unsigned char *addr);
@@ -75,6 +102,9 @@
 {
 	hlist_del_rcu(&f->hlist);
 	br_fdb_put(f);
+	#if defined(CONFIG_RTL_819X)
+	rtl_fdb_delete_hooks(f);
+	#endif
 }
 
 void br_fdb_changeaddr(struct net_bridge_port *p, const unsigned char *newaddr)
@@ -116,12 +146,114 @@
 	spin_unlock_bh(&br->hash_lock);
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+static void br_igmp_fdb_expired(struct net_bridge_fdb_entry *ent)
+{
+	int i2;
+	unsigned long igmp_walktimeout;	
+	unsigned char *DA;
+	unsigned char *SA;
+	#if defined	(MCAST_TO_UNICAST)
+	struct net_device *dev=NULL;
+	#endif
+	
+	igmp_walktimeout = 	jiffies - IGMP_EXPIRE_TIME;	
+	    
+	//IGMP_EXPIRE_TIME
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++)
+	{
+		if(ent->igmp_fdb_arr[i2].valid == 1){
+
+			// when timeout expire
+			if(time_before_eq(ent->igmp_fdb_arr[i2].ageing_time, igmp_walktimeout))
+			{
+				DEBUG_PRINT("%s:%d\n",__FUNCTION__,__LINE__);	
+				SA = ent->igmp_fdb_arr[i2].SrcMac;					
+				DEBUG_PRINT("expired src mac:%02x,%02x,%02x,%02x,%02x,%02x\n",
+					SA[0],SA[1],SA[2],SA[3],SA[4],SA[5]);								
+
+				DA = ent->addr.addr;					
+				DEBUG_PRINT("fdb:%02x:%02x:%02x-%02x:%02x:%02x\n",
+					DA[0],DA[1],DA[2],DA[3],DA[4],DA[5]);				
+
+
+
+				/*---for process wlan client expired start---*/								
+				#if defined	(MCAST_TO_UNICAST)
+				dev = __dev_get_by_name(&init_net, RTL_PS_WLAN0_DEV_NAME);	
+	
+				
+				if (dev) {		
+					unsigned char StaMacAndGroup[20];
+					memcpy(StaMacAndGroup, DA , 6);
+					memcpy(StaMacAndGroup+6, SA, 6);
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+					if (dev->do_ioctl != NULL) {
+						dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#else
+					if (dev->netdev_ops->ndo_do_ioctl != NULL) {
+						dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#endif
+						DEBUG_PRINT("(fdb expire) wlan0 ioctl to DEL! M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+							StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+							StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+					}
+				}
+					
+				#if defined (CONFIG_RTL_92D_SUPPORT)
+				dev = __dev_get_by_name(&init_net, RTL_PS_WLAN1_DEV_NAME);	
+	
+				if (dev) {		
+					unsigned char StaMacAndGroup[20];
+					memcpy(StaMacAndGroup, DA , 6);
+					memcpy(StaMacAndGroup+6, SA, 6);
+				#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+					if (dev->do_ioctl != NULL) {
+						dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#else
+					if (dev->netdev_ops->ndo_do_ioctl != NULL) {
+						dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);
+				#endif
+						DEBUG_PRINT("(fdb expire) wlan0 ioctl to DEL! M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+							StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+							StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+					}
+				}
+				#endif
+				#endif			
+				/*---for process wlan client expired end---*/
+
+			
+				del_igmp_ext_entry(ent , SA , ent->igmp_fdb_arr[i2].port);
+
+	
+				if ( (ent->portlist & 0x7f)==0){
+					ent->group_src &=  ~(1 << 1); // eth0 all leave
+				}
+			
+				if ( (ent->portlist & 0x80)==0){
+					ent->group_src &=  ~(1 << 2); // wlan0 all leave
+				}
+			
+			
+			}			
+			
+		}		
+		
+	}		
+	
+}
+#endif
 void br_fdb_cleanup(unsigned long _data)
 {
 	struct net_bridge *br = (struct net_bridge *)_data;
 	unsigned long delay = hold_time(br);
 	unsigned long next_timer = jiffies + br->forward_delay;
 	int i;
+	#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
+	int32 port_num;
+	unsigned char swap_addr[ETHER_ADDR_LEN];
+	#endif
 
 	spin_lock_bh(&br->hash_lock);
 	for (i = 0; i < BR_HASH_SIZE; i++) {
@@ -130,12 +262,54 @@
 
 		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
 			unsigned long this_timer;
+			#if defined	(CONFIG_RTL_IGMP_SNOOPING)
+			if(	f->is_static &&
+				f->igmpFlag &&
+				MULTICAST_MAC(f->addr.addr))
+			{
+										
+				br_igmp_fdb_expired(f);
+				if(time_before_eq(f->ageing_timer +300*HZ,  jiffies))
+				{
+					DEBUG_PRINT("fdb_delete:f->addr.addr is 0x%02x:%02x:%02x-%02x:%02x:%02x\n",
+					f->addr.addr[0],f->addr.addr[1],f->addr.addr[2],f->addr.addr[3],f->addr.addr[4],f->addr.addr[5]);	
+					fdb_delete(f);
+				}
+				
+			}
+			#endif
+
 			if (f->is_static)
 				continue;
+
+			#if defined(CONFIG_RTL_819X)
+			rtl_br_fdb_cleanup_hooks(br, f);
+			#endif
+			
 			this_timer = f->ageing_timer + delay;
-			if (time_before_eq(this_timer, jiffies))
+			if (time_before_eq(this_timer, jiffies)) {
+				#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
+				/*try to find blocked l2 entry, then set it to authed*/
+				if (port_num != -100)
+				{
+					if ((lan_restrict_getBlockAddr(port_num, swap_addr)) == SUCCESS)
+					{
+						/*									
+						printk("\n arrange block entry is %x %x %x %x %x %x\n", swap_addr[0],
+																swap_addr[1],
+																swap_addr[2],
+																swap_addr[3],
+																swap_addr[4],
+																swap_addr[5]);
+																
+						*/
+						rtl865x_addAuthFDBEntry(swap_addr, TRUE, port_num);
+					}
+				}
+				#endif	/* #if defined (CONFIG_RTL865X_LANPORT_RESTRICTION) && defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)	*/
+
 				fdb_delete(f);
-			else if (time_before(this_timer, next_timer))
+			} else if (time_before(this_timer, next_timer))
 				next_timer = this_timer;
 		}
 	}
@@ -156,6 +330,18 @@
 		struct net_bridge_fdb_entry *f;
 		struct hlist_node *h, *n;
 		hlist_for_each_entry_safe(f, h, n, &br->hash[i], hlist) {
+		#if defined (CONFIG_RTL_IGMP_SNOOPING)
+			if(	f->is_static && 
+				f->igmpFlag &&
+				MULTICAST_MAC(f->addr.addr) )
+			{
+				br_igmp_fdb_expired(f);
+				if(time_before_eq(f->ageing_timer + 300*HZ,  jiffies))
+				{
+					fdb_delete(f);
+				}
+			}
+		#endif
 			if (!f->is_static)
 				fdb_delete(f);
 		}
@@ -217,8 +403,15 @@
 
 	hlist_for_each_entry_rcu(fdb, h, &br->hash[br_mac_hash(addr)], hlist) {
 		if (!compare_ether_addr(fdb->addr.addr, addr)) {
-			if (unlikely(has_expired(br, fdb)))
+			if (unlikely(has_expired(br, fdb))) {
+			#if defined(CONFIG_RTL_819X)
+				if (rtl___br_fdb_get_timeout_hooks(br, fdb, addr)==RTL_PS_HOOKS_BREAK) {
+					break;
+				}
+			#else
 				break;
+			#endif
+			}
 			return fdb;
 		}
 	}
@@ -245,6 +438,14 @@
 	struct net_bridge_fdb_entry *ent
 		= container_of(head, struct net_bridge_fdb_entry, rcu);
 	kmem_cache_free(br_fdb_cache, ent);
+#if defined(CONFIG_RTL_819X)
+	fdb_entry_num--;
+	if(fdb_entry_num < 0)
+	{
+		printk("fdb entry num error!!!!\n");
+		fdb_entry_num = 0;
+	}
+#endif
 }
 
 /* Set entry up for deletion with RCU  */
@@ -322,17 +523,81 @@
 					       int is_local)
 {
 	struct net_bridge_fdb_entry *fdb;
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	int i3;
+#endif
+#if defined(CONFIG_RTL_819X)
+	if(fdb_entry_num >= fdb_entry_max)
+		return NULL;
+#endif
 
 	fdb = kmem_cache_alloc(br_fdb_cache, GFP_ATOMIC);
 	if (fdb) {
 		memcpy(fdb->addr.addr, addr, ETH_ALEN);
 		atomic_set(&fdb->use_count, 1);
+#if defined(CONFIG_RTL_819X)
+		fdb_entry_num++;
+#endif
 		hlist_add_head_rcu(&fdb->hlist, head);
 
 		fdb->dst = source;
 		fdb->is_local = is_local;
 		fdb->is_static = is_local;
 		fdb->ageing_timer = jiffies;
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+		fdb->group_src = 0;
+		fdb->igmpFlag=0;
+		for(i3=0 ; i3<FDB_IGMP_EXT_NUM ;i3++){
+			fdb->igmp_fdb_arr[i3].valid = 0;
+			fdb->portUsedNum[i3] = 0;		
+		}
+
+#endif
+
+
+#if defined(CONFIG_RTL_LAYERED_DRIVER) && defined(CONFIG_RTL_LAYERED_DRIVER_L2) && defined(CONFIG_RTL865X_SYNC_L2)
+		if (fdb->is_static == 0)
+		{
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+			/*lookup hw l2 table by mac */
+			ether_addr_t *macAddr;
+			int32 column;
+			rtl865x_tblAsicDrv_l2Param_t	fdbEntry;
+			int8 port_num = -1;
+			fdb->entry_timing = 300*HZ;
+			macAddr = (ether_addr_t *)(addr);
+			
+			if (rtl865x_Lookup_fdb_entry(RTL_LAN_FID, macAddr, FDB_DYNAMIC, &column,&fdbEntry) == SUCCESS)
+			{
+
+				port_num = rtl865x_ConvertPortMasktoPortNum(fdbEntry.memberPortMask);
+
+				/*function opened, and should be authed*/
+				if (lan_restrict_CheckStatusByport(port_num) == TRUE)
+				{
+					rtl865x_addAuthFDBEntry(addr, TRUE, port_num);
+				}
+				/*function opened, and set it to block*/
+				else if(lan_restrict_CheckStatusByport(port_num) == FALSE)
+				{
+					rtl865x_addAuthFDBEntry(addr, FALSE, port_num);
+				
+				}
+				/*function not open , no need to be authed*/
+				else  if(lan_restrict_CheckStatusByport(port_num) == FAILED)
+				{
+					rtl865x_addFDBEntry(addr);
+				}
+			}
+
+
+#else
+				fdb->entry_timing = 300*HZ;
+				rtl865x_addFDBEntry(addr);
+#endif
+		}
+#endif		
 	}
 	return fdb;
 }
@@ -342,10 +607,16 @@
 {
 	struct hlist_head *head = &br->hash[br_mac_hash(addr)];
 	struct net_bridge_fdb_entry *fdb;
-
+#if defined (CONFIG_RTL_IGMP_SNOOPING)	
+	if(((addr[0]==0xff) && (addr[1]==0xff) && (addr[2]==0xff) && (addr[3]==0xff) && (addr[4]==0xff) && (addr[5]==0xff))||
+		((addr[0]==0) && (addr[1]==0) && (addr[2]==0) && (addr[3]==0) && (addr[4]==0) && (addr[5]==0)))
+	{
+		return -EINVAL;
+	}
+#else	
 	if (!is_valid_ether_addr(addr))
 		return -EINVAL;
-
+#endif
 	fdb = fdb_find(head, addr);
 	if (fdb) {
 		/* it is okay to have multiple ports with same
@@ -402,6 +673,12 @@
 				       source->dev->name);
 		} else {
 			/* fastpath: update of existing entry */
+#if defined (CONFIG_RTL865X_ETH)
+//                       if (((unsigned long)fdb->dst) != ((unsigned long)source->br->dev->a)) { 
+				if (fdb->dst != source){
+                               update_hw_l2table(source->dev->name, addr);
+                       }
+#endif			
 			fdb->dst = source;
 			fdb->ageing_timer = jiffies;
 		}
@@ -415,3 +692,219 @@
 		spin_unlock(&br->hash_lock);
 	}
 }
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int chk_igmp_ext_entry(
+	struct net_bridge_fdb_entry *fdb ,
+	unsigned char *srcMac)
+{
+
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;
+
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 1){
+			if(!memcmp(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6)){
+				return 1;
+			}
+		}
+	}
+	return 0;
+}
+
+extern int bitmask_to_id(unsigned char val);
+
+void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,
+	unsigned char *srcMac , unsigned char portComeIn)
+{
+
+//	if(fdb->igmp_ext_array == NULL)
+//		return 0;
+
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;	
+
+	DEBUG_PRINT("add_igmp,DA=%02x:%02x:%02x:%02x:%02x:%02x ; SA=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		add[0],add[1],add[2],add[3],add[4],add[5],
+		srcMac[0],srcMac[1],srcMac[2],srcMac[3],srcMac[4],srcMac[5]);
+	
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 0){
+			fdb->igmp_fdb_arr[i2].valid = 1	;
+			fdb->igmp_fdb_arr[i2].ageing_time = jiffies ;			
+			memcpy(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6);
+			fdb->igmp_fdb_arr[i2].port = portComeIn ;
+			fdb->portlist |= portComeIn;
+			fdb->portUsedNum[bitmask_to_id(portComeIn)]++;
+			DEBUG_PRINT("portUsedNum[%d]=%d\n\n",bitmask_to_id(portComeIn) , fdb->portUsedNum[bitmask_to_id(portComeIn)]);
+			return ;
+		}
+	}
+	DEBUG_PRINT("%s:entry Rdy existed!!!\n", __FUNCTION__);	
+}
+
+void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,
+	unsigned char *srcMac , unsigned char portComeIn)
+{
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;	
+
+		DEBUG_PRINT("update_igmp,DA=%02x:%02x:%02x:%02x:%02x:%02x ; SA=%02x:%02x:%02x:%02x:%02x:%02x\n",
+		add[0],add[1],add[2],add[3],add[4],add[5],
+		srcMac[0],srcMac[1],srcMac[2],srcMac[3],srcMac[4],srcMac[5]);
+
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 1){
+			if(!memcmp(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6)){
+
+				fdb->igmp_fdb_arr[i2].ageing_time = jiffies ;
+				//DEBUG_PRINT("update jiffies ok!\n");
+				if(fdb->igmp_fdb_arr[i2].port != portComeIn){
+
+					unsigned char port_orig = fdb->igmp_fdb_arr[i2].port ;					
+					int index = bitmask_to_id(port_orig);
+
+					fdb->portUsedNum[index]-- ;
+					DEBUG_PRINT("(--) portUsedNum[%d]=%d\n",index , fdb->portUsedNum[index] );					
+					if(fdb->portUsedNum[index] <= 0){
+						fdb->portlist &= ~(port_orig);
+						if(fdb->portUsedNum[index]< 0){
+							DEBUG_PRINT("!! portNum[%d] < 0 at (update_igmp_ext_entry)\n",index);
+							fdb->portUsedNum[index] = 0 ;
+						}
+					}					
+
+					
+					fdb->portUsedNum[bitmask_to_id(portComeIn)]++;
+					DEBUG_PRINT("(++) portUsedNum[%d]=%d\n",bitmask_to_id(portComeIn) , fdb->portUsedNum[bitmask_to_id(portComeIn)] );										
+					fdb->portlist |= portComeIn;						
+
+					
+					fdb->igmp_fdb_arr[i2].port = portComeIn ;					
+					DEBUG_PRINT("	!!! portlist be updated:%x !!!!\n",fdb->portlist);
+					
+				}
+				return ;
+			}			
+		}		
+	}
+
+	DEBUG_PRINT("%s: ...fail!!\n", __FUNCTION__);
+}
+
+
+void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn )
+{
+	int i2;
+	unsigned char *add;
+	add = fdb->addr.addr;	
+
+
+				
+
+	
+	for(i2=0 ; i2 < FDB_IGMP_EXT_NUM ; i2++){
+		if(fdb->igmp_fdb_arr[i2].valid == 1){
+			if(!memcmp(fdb->igmp_fdb_arr[i2].SrcMac , srcMac ,6))
+			{
+				fdb->igmp_fdb_arr[i2].ageing_time -=  300*HZ; // make it expired	
+				fdb->igmp_fdb_arr[i2].valid = 0;
+				DEBUG_PRINT("\ndel_igmp_ext_entry,DA=%02x:%02x:%02x:%02x:%02x:%02x ; SA=%02x:%02x:%02x:%02x:%02x:%02x success!!!\n",
+				add[0],add[1],add[2],add[3],add[4],add[5],
+				srcMac[0],srcMac[1],srcMac[2],srcMac[3],srcMac[4],srcMac[5]);
+				
+				//DEBUG_PRINT("%s:success!!\n", __FUNCTION__);
+				
+				if(portComeIn != 0){
+					int index;
+					index = bitmask_to_id(portComeIn);
+					fdb->portUsedNum[index]--;
+					if(fdb->portUsedNum[index] <= 0){
+						DEBUG_PRINT("portUsedNum[%d] == 0 ,update portlist from (%x)  " ,index ,fdb->portlist);
+						fdb->portlist &= ~ portComeIn;
+						DEBUG_PRINT("to (%x) \n" ,fdb->portlist);
+						
+						if(fdb->portUsedNum[index] < 0){
+						DEBUG_PRINT("!! portUsedNum[%d]=%d < 0 at (del_igmp_ext_entry)  \n" ,index ,fdb->portUsedNum[index]);
+						fdb->portUsedNum[index] = 0;
+						}
+					}else{
+						DEBUG_PRINT("(del) portUsedNum[%d] = %d \n" ,index, fdb->portUsedNum[index]);
+					}
+				
+				}	
+				DEBUG_PRINT("\n");
+				return ;
+			}			
+		}
+	}
+
+	DEBUG_PRINT("%s:entry not existed!!\n\n", __FUNCTION__);	
+}
+
+
+
+
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+int rtl865x_checkMacAddrLocation(unsigned char *addr, unsigned int *isElanMac, unsigned int *isWlanMac)
+{
+	struct net_device *brDev;
+	struct net_bridge *br;
+	struct net_bridge_fdb_entry *fdb;
+
+	if((addr==NULL) || (isElanMac==NULL) || (isWlanMac==NULL))
+	{
+		return -1;
+	}
+
+	*isElanMac=0;
+	*isWlanMac=0;
+
+	brDev = __dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
+      	if ( brDev== NULL)
+	{
+		return -1;
+	}
+
+	if (!(brDev->priv_flags & IFF_EBRIDGE))
+	{
+		
+		return -1;
+	}
+	else 
+	{
+		br = (struct net_bridge *)netdev_priv(brDev);
+	}
+	
+	
+	fdb=__br_fdb_get(br, addr);
+
+	if(fdb==NULL)
+	{
+		return -1;
+	}
+	
+	if(strncmp(fdb->dst->dev->name, RTL_PS_ETH_NAME,3)==0)
+	{
+		*isElanMac=1;
+		
+	}
+	else if(strncmp(fdb->dst->dev->name, RTL_PS_WLAN_NAME,4)==0)
+	{
+		*isWlanMac=1;
+	}	
+	else
+	{
+		return -1;
+	}
+
+	return 0;
+	
+}
+#endif
+
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_forward.c linux-2.6.30.9-rsdk/net/bridge/br_forward.c
--- linux-2.6.30.9/net/bridge/br_forward.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_forward.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,6 +17,31 @@
 #include <linux/if_vlan.h>
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <linux/ip.h>
+#include <linux/in.h>
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+#endif
+#include <linux/igmp.h>
+#include <net/checksum.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+extern int igmpsnoopenabled;
+extern unsigned int brIgmpModuleIndex;
+extern unsigned int br0SwFwdPortMask;
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+extern int mldSnoopEnabled;
+#endif
+#endif
+
+#if	defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 
 /* Don't forward packets to originating port or forwarding diasabled */
 static inline int should_deliver(const struct net_bridge_port *p,
@@ -41,7 +66,9 @@
 			kfree_skb(skb);
 		else {
 			skb_push(skb, ETH_HLEN);
-
+			#if	defined(CONFIG_RTL_819X)
+			rtl_br_dev_queue_push_xmit_before_xmit_hooks(skb);
+			#endif
 			dev_queue_xmit(skb);
 		}
 	}
@@ -102,6 +129,27 @@
 	kfree_skb(skb);
 }
 
+#ifdef CONFIG_RTK_INBAND_HOST_HACK	
+#define ETH_P_RTK_NOTIFY 0x9000 //mark_issue
+#define ETH_P_RTK_NOTIFY1 0x9001
+#define ETH_P_RTK		0x8899	// Realtek Remote Control Protocol (RRCP)
+#define LOCAL_INBAND_IF1 "eth1"
+#define LOCAL_INBAND_IF0 "eth0"
+
+static inline int inband_deliver_check(struct net_bridge_port *p, struct sk_buff *skb)
+{	
+	struct ethhdr *eth_hdr_p;
+	eth_hdr_p = eth_hdr(skb);
+
+	if(eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY || eth_hdr_p->h_proto == ETH_P_RTK 
+							  || eth_hdr_p->h_proto == ETH_P_RTK_NOTIFY1 )		
+		if(memcmp(p->dev->name,LOCAL_INBAND_IF1,4) && memcmp(p->dev->name,LOCAL_INBAND_IF0,4) ) //not foward if not eth1 or eth0
+			return 0;
+	return 1;
+
+}
+#endif
+
 /* called under bridge lock */
 static void br_flood(struct net_bridge *br, struct sk_buff *skb,
 	void (*__packet_hook)(const struct net_bridge_port *p,
@@ -113,7 +161,11 @@
 	prev = NULL;
 
 	list_for_each_entry_rcu(p, &br->port_list, list) {
+#ifndef CONFIG_RTK_INBAND_HOST_HACK		
 		if (should_deliver(p, skb)) {
+#else
+		if ((should_deliver(p, skb)) && (inband_deliver_check(p, skb))) {
+#endif		
 			if (prev != NULL) {
 				struct sk_buff *skb2;
 
@@ -150,3 +202,385 @@
 {
 	br_flood(br, skb, __br_forward);
 }
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int bitmask_to_id(unsigned char val)
+{
+	int i;
+	for (i=0; i<8; i++) {
+		if (val & (1 <<i))
+			break;
+	}
+
+	if(i>=8)
+	{
+		i=7;
+	}
+	return (i);
+}
+
+static void br_multicast(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone, 
+		  void (*__packet_hook)(const struct net_bridge_port *p, struct sk_buff *skb))
+{
+//	char i;
+	struct net_bridge_port *prev;
+	struct net_bridge_port *p, *n;
+	unsigned short port_bitmask=0;
+        if (clone) {
+                struct sk_buff *skb2;
+                                                                                                                                              
+                if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+                        br->dev->stats.tx_dropped++;
+                        return;
+                }
+                                                                                                                                              
+                skb = skb2;
+        }
+                                                                                                                                              
+	prev = NULL;
+	
+	list_for_each_entry_safe(p, n, &br->port_list, list) {
+		port_bitmask = (1 << p->port_no);
+                if ((port_bitmask & fwdPortMask) && should_deliver(p, skb)) {
+                        if (prev != NULL) {
+                                struct sk_buff *skb2;
+                                                                                                                                 
+                                if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) {
+                                        br->dev->stats.tx_dropped++;
+                                        kfree_skb(skb);
+                                        return;
+                                }
+                                        
+                                __packet_hook(prev, skb2);
+                        }
+                                                                                                                       
+                        prev = p;
+                }
+	}
+
+        if (prev != NULL) {
+                __packet_hook(prev, skb);
+                return;
+        }
+
+	kfree_skb(skb);
+}
+
+void br_multicast_deliver(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone)
+{
+	br_multicast(br, fwdPortMask, skb, clone, __br_deliver);
+}
+void br_multicast_forward(struct net_bridge *br, unsigned int fwdPortMask, struct sk_buff *skb, int clone)
+{
+	br_multicast(br, fwdPortMask, skb, clone, __br_forward);
+}
+
+extern struct net_bridge *bridge0;
+extern int ipMulticastFastFwd;
+extern int needCheckMfc;
+#if defined (CONFIG_IP_MROUTE)
+extern int rtl865x_checkMfcCache(struct net *net,__be32 origin,__be32 mcastgrp);
+#endif
+
+#if defined(CONFIG_RTL_MLD_SNOOPING)
+extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
+#endif
+
+int rtl865x_ipMulticastFastFwd(struct sk_buff *skb)
+{
+	const unsigned char *dest = NULL;
+	unsigned char *ptr;
+	struct iphdr *iph=NULL;
+	unsigned char proto=0;
+	unsigned char reserved=0;
+	int ret=-1;
+	
+	struct net_bridge_port *prev;
+	struct net_bridge_port *p, *n;
+	struct rtl_multicastDataInfo multicastDataInfo;
+	struct rtl_multicastFwdInfo multicastFwdInfo;
+	struct sk_buff *skb2;
+	
+	unsigned short port_bitmask=0;
+	#if defined (CONFIG_RTL_MLD_SNOOPING)
+	struct ipv6hdr * ipv6h=NULL;
+	#endif
+	unsigned int fwdCnt;
+	
+	/*check fast forward enable or not*/
+	if(ipMulticastFastFwd==0)
+	{
+		return -1;
+	}
+	
+	/*check dmac is multicast or not*/
+	dest=eth_hdr(skb)->h_dest;
+	if((dest[0]&0x01)==0)
+	{
+		return -1;
+	}
+	
+	//printk("%s:%d,dest is 0x%x-%x-%x-%x-%x-%x\n",__FUNCTION__,__LINE__,dest[0],dest[1],dest[2],dest[3],dest[4],dest[5]);
+	if(igmpsnoopenabled==0)
+	{
+		return -1;
+	}
+	
+	/*check bridge0 exist or not*/
+	if((bridge0==NULL) ||(bridge0->dev->flags & IFF_PROMISC))
+	{
+		return -1;
+	}
+
+	if((skb->dev==NULL) ||(strncmp(skb->dev->name,RTL_PS_BR0_DEV_NAME,3)==0))
+	{
+		return -1;
+	}
+
+	/*check igmp snooping enable or not, and check dmac is ipv4 multicast mac or not*/
+	if  ((dest[0]==0x01) && (dest[1]==0x00) && (dest[2]==0x5e))
+	{
+		//printk("%s:%d,skb->dev->name is %s\n",__FUNCTION__,__LINE__,skb->dev->name );
+		ptr=(unsigned char *)eth_hdr(skb)+12;
+		/*check vlan tag exist or not*/
+		if(*(int16 *)(ptr)==(int16)htons(0x8100))
+		{
+			ptr=ptr+4;
+		}
+
+		/*check it's ipv4 packet or not*/
+		if(*(int16 *)(ptr)!=(int16)htons(ETH_P_IP))
+		{
+			return -1;
+		}
+		
+		iph=(struct iphdr *)(ptr+2);
+	
+		if(iph->daddr== 0xEFFFFFFA)
+		{
+			/*for microsoft upnp*/
+			reserved=1;
+		}
+		
+		/*only speed up udp and tcp*/
+		proto =  iph->protocol;  
+		//printk("%s:%d,proto is %d\n",__FUNCTION__,__LINE__,proto);
+		 if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP)) && (reserved ==0))
+		{
+			
+			#if defined (CONFIG_IP_MROUTE)
+			/*multicast data comes from wan, need check multicast forwardig cache*/
+			if((strncmp(skb->dev->name,RTL_PS_WAN0_DEV_NAME,4)==0) && needCheckMfc )
+			{
+				if(rtl865x_checkMfcCache(&init_net,iph->saddr,iph->daddr)!=0)
+				{
+					return -1;
+				}
+			}
+			#endif
+			
+			multicastDataInfo.ipVersion=4;
+			multicastDataInfo.sourceIp[0]=  (unsigned int)(iph->saddr);
+			multicastDataInfo.groupAddr[0]=  (unsigned int)(iph->daddr);
+			
+			ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+			
+			//printk("%s:%d,ret is %d\n",__FUNCTION__,__LINE__,ret);
+			 if((ret!=0)||multicastFwdInfo.reservedMCast ||multicastFwdInfo.unknownMCast) 
+			{
+				return -1;
+			}
+
+
+			//printk("%s:%d,br0SwFwdPortMask is 0x%x,multicastFwdInfo.fwdPortMask is 0x%x\n",__FUNCTION__,__LINE__,br0SwFwdPortMask,multicastFwdInfo.fwdPortMask);
+			#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+			if((skb->srcVlanId!=0) && (skb->srcPort!=0xFFFF))
+			{
+				/*multicast data comes from ethernet port*/
+				if( (br0SwFwdPortMask & multicastFwdInfo.fwdPortMask)==0)
+				{
+					/*hardware forwarding ,let slow path handle packets trapped to cpu*/
+					return -1;
+				}
+			}
+			#endif
+			
+			skb_push(skb, ETH_HLEN);
+			
+			prev = NULL;
+			fwdCnt=0;
+			list_for_each_entry_safe(p, n, &bridge0->port_list, list) 
+			{
+				port_bitmask = (1 << p->port_no);
+				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING)) 
+				{
+					if (prev != NULL) 
+					{                                                                                       
+						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+						{
+							bridge0->dev->stats.tx_dropped++;
+							kfree_skb(skb);
+							return 0;
+						}
+						skb2->dev=prev->dev;
+						//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+						#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+						prev->dev->hard_start_xmit(skb2, prev->dev);
+						#else
+						prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+						#endif                  
+						fwdCnt++;
+					}
+						                                                                               
+					prev = p;
+				}
+			}
+
+			if (prev != NULL) 
+			{
+				skb->dev=prev->dev;
+				//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+			       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+				#endif                            
+				fwdCnt++;
+			}
+
+			if(fwdCnt==0)
+			{
+				/*avoid memory leak*/
+				skb_pull(skb, ETH_HLEN);
+				return -1;
+			}
+			
+			return 0;
+
+		}
+
+	}
+
+#if 0 //defined (CONFIG_RTL_MLD_SNOOPING)
+	/*check igmp snooping enable or not, and check dmac is ipv4 multicast mac or not*/
+	if  ((dest[0]==0x33) && (dest[1]==0x33) && (dest[2]!=0xff))
+	{
+		struct net_bridge_port *p;
+		if(mldSnoopEnabled==0)
+		{
+			return -1;
+		}
+		
+		/*due to ipv6 passthrough*/
+		p= rcu_dereference(skb->dev->br_port);
+		if(p==NULL)
+		{
+			return -1;
+		}
+		
+		//printk("%s:%d,skb->dev->name is %s\n",__FUNCTION__,__LINE__,skb->dev->name );
+		ptr=(unsigned char *)eth_hdr(skb)+12;
+		/*check vlan tag exist or not*/
+		if(*(int16 *)(ptr)==(int16)htons(0x8100))
+		{
+			ptr=ptr+4;
+		}
+
+		/*check it's ipv6 packet or not*/
+		if(*(int16 *)(ptr)!=(int16)htons(ETH_P_IPV6))
+		{
+			return -1;
+		}
+		
+		ipv6h=(struct ipv6hdr *)(ptr+2);
+		proto =  re865x_getIpv6TransportProtocol(ipv6h);
+		
+		//printk("%s:%d,proto is %d\n",__FUNCTION__,__LINE__,proto);
+		 if((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
+		{			
+			multicastDataInfo.ipVersion=6;
+			memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
+			memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));
+			/*
+			printk("%s:%d,sourceIp is %x-%x-%x-%x\n",__FUNCTION__,__LINE__,
+				multicastDataInfo.sourceIp[0],multicastDataInfo.sourceIp[1],multicastDataInfo.sourceIp[2],multicastDataInfo.sourceIp[3]);
+			printk("%s:%d,groupAddr is %x-%x-%x-%x\n",__FUNCTION__,__LINE__,
+				multicastDataInfo.groupAddr[0],multicastDataInfo.groupAddr[1],multicastDataInfo.groupAddr[2],multicastDataInfo.groupAddr[3]);
+			*/
+			ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+			//printk("%s:%d,ret is %d\n",__FUNCTION__,__LINE__,ret);
+			if(ret!=0)
+			{
+				if(multicastFwdInfo.unknownMCast)
+				{
+					multicastFwdInfo.fwdPortMask=0xFFFFFFFF;
+				}
+				else
+				{
+					return -1;
+				}
+	
+			}
+			
+			//printk("%s:%d,multicastFwdInfo.fwdPortMask is 0x%x\n",__FUNCTION__,__LINE__,multicastFwdInfo.fwdPortMask);
+			
+			skb_push(skb, ETH_HLEN);
+
+			prev = NULL;
+			fwdCnt=0;
+			list_for_each_entry_safe(p, n, &bridge0->port_list, list) 
+			{
+				port_bitmask = (1 << p->port_no);
+				if ((port_bitmask & multicastFwdInfo.fwdPortMask) && (skb->dev != p->dev && p->state == BR_STATE_FORWARDING)) 
+				{
+					if (prev != NULL) 
+					{                                                                                       
+						if ((skb2 = skb_clone(skb, GFP_ATOMIC)) == NULL) 
+						{
+							kfree_skb(skb);
+							return 0;
+						}
+						skb2->dev=prev->dev;
+						//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+						#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+						prev->dev->hard_start_xmit(skb2, prev->dev);
+						#else
+						prev->dev->netdev_ops->ndo_start_xmit(skb2,prev->dev);
+						#endif                             
+						fwdCnt++;
+					}
+						                                                                               
+					prev = p;
+				}
+			}
+
+			if (prev != NULL) 
+			{
+				skb->dev=prev->dev;
+				//printk("%s:%d,prev->dev->name is %s\n",__FUNCTION__,__LINE__,prev->dev->name);
+			       #if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				prev->dev->hard_start_xmit(skb, prev->dev);
+				#else
+				prev->dev->netdev_ops->ndo_start_xmit(skb,prev->dev);
+				#endif                            
+				fwdCnt++;
+			}
+			
+			if(fwdCnt==0)
+			{
+				//printk("%s:%d\n",__FUNCTION__,__LINE__);
+				/*avoid memory leak*/
+				skb_pull(skb, ETH_HLEN);
+				return -1;	
+			}
+				
+			return 0;	
+		}
+
+	}
+#endif
+
+	return -1;	
+}
+
+#endif
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_if.c linux-2.6.30.9-rsdk/net/bridge/br_if.c
--- linux-2.6.30.9/net/bridge/br_if.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_if.c	2011-12-05 15:50:14.000000000 +0000
@@ -23,6 +23,24 @@
 
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+struct net_bridge *bridge0=NULL;
+unsigned int brIgmpModuleIndex=0xFFFFFFFF;
+unsigned int br0SwFwdPortMask=0xFFFFFFFF;
+extern void br_mCastQueryTimerExpired(unsigned long arg);
+#endif
+
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtk_stp.h>
+#endif
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+int rtl865x_generateBridgeDeviceInfo( struct net_bridge *br, rtl_multicastDeviceInfo_t *devInfo);
+#endif
 /*
  * Determine initial path cost based on speed.
  * using recommendations from 802.1d standard
@@ -58,6 +76,12 @@
 	return 100;	/* assume old 10Mbps */
 }
 
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+int br_initial_port_cost(struct net_device *dev)
+{
+	return port_cost(dev);
+}
+#endif
 
 /*
  * Check for port carrier transistions.
@@ -131,6 +155,13 @@
 	struct net_bridge *br = p->br;
 	struct net_device *dev = p->dev;
 
+#if 0
+#ifdef STP_DISABLE_ETH
+	//Chris: stp+mesh
+	p->disable_by_mesh = 0;
+#endif
+#endif 
+
 	sysfs_remove_link(br->ifobj, dev->name);
 
 	dev_set_promiscuity(dev, -1);
@@ -168,6 +199,32 @@
 	unregister_netdevice(br->dev);
 }
 
+#if defined (CONFIG_RTK_MESH) || defined (CONFIG_RTL_IGMP_SNOOPING)
+struct net_bridge *find_br_by_name(char *name)
+{
+	struct net_bridge *br;
+	struct net_device *dev =NULL;;
+
+	dev = __dev_get_by_name(&init_net, name);
+	if (dev == NULL) 
+	{
+		return NULL;
+
+	}	
+	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
+		
+		return NULL;
+	}
+	else 
+	{
+		br = netdev_priv(dev);
+	}
+	return br;
+}
+
+
+#endif
+
 static struct net_device *new_bridge_dev(struct net *net, const char *name)
 {
 	struct net_bridge *br;
@@ -199,13 +256,29 @@
 	br->root_port = 0;
 	br->bridge_max_age = br->max_age = 20 * HZ;
 	br->bridge_hello_time = br->hello_time = 2 * HZ;
+#if defined(CONFIG_RTL_819X)
+	br->bridge_forward_delay = br->forward_delay = 10 * HZ;
+#else
 	br->bridge_forward_delay = br->forward_delay = 15 * HZ;
+#endif
 	br->topology_change = 0;
 	br->topology_change_detected = 0;
 	br->ageing_time = 300 * HZ;
 
+#if defined (CONFIG_RTK_MESH)
+
+	br->eth0_monitor_interval = MESH_PORTAL_EXPIRE * HZ;
+	br->mesh_pathsel_pid=0;
+#if defined (STP_ADDCOST_ETH)
+	br->is_cost_changed = 0;
+#endif
+#endif
+
 	br_netfilter_rtable_init(br);
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	br->igmpProxy_pid=0;
+#endif
 	INIT_LIST_HEAD(&br->age_list);
 
 	br_stp_timer_init(br);
@@ -241,7 +314,15 @@
 {
 	int index;
 	struct net_bridge_port *p;
-
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
 	index = find_portno(br);
 	if (index < 0)
 		return ERR_PTR(index);
@@ -258,11 +339,163 @@
 	p->port_no = index;
 	br_init_port(p);
 	p->state = BR_STATE_DISABLED;
+
+//Chris: stp+mesh
+#if 0
+ #if defined STP_DISABLE_ETH
+	p->disable_by_mesh = 0;
+ #endif
+#endif
+
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#ifdef CONFIG_RTK_MESH
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port !=WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_DISABLED);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_DISABLED);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net, WLAN_IF_NAME)) == NULL)
+			{	
+				return NULL;
+			}
+			pseudo_dev->br_port->state = BR_STATE_DISABLED;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net, WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return NULL;
+			}
+			pseudo_dev->br_port->state = BR_STATE_DISABLED;
+			retval = SUCCESS;
+		}
+		#endif
+		else if(Port == NO_MAPPING)
+		{
+			p->state = BR_STATE_DISABLED;
+		}
+	}
+	
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , BR_STATE_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, BR_STATE_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 	br_stp_port_timer_init(p);
 
 	return p;
 }
 
+#if defined (CONFIG_RTK_MESH)
+/*notice:this function is different from kernel 2.4 sdk*/
+int br_set_meshpathsel_pid(int pid)
+{
+	struct net_device *dev=NULL;
+	struct net_bridge *br=NULL;
+	
+	int ret=0;
+
+	dev = __dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
+	if (dev == NULL) 
+	{
+		ret =  -ENXIO; 	/* Could not find device */
+
+	}	
+	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
+		
+		ret = -EPERM;
+	}
+	else 
+	{
+		br = netdev_priv(dev);
+	}
+
+	br->mesh_pathsel_pid = pid;
+
+	if( !pid )
+		br->eth0_received = 0;
+
+	//printk("Receive Pathsel daemon pid:%d\n",br->mesh_pathsel_pid);
+	return 1;
+}
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int br_set_igmpProxy_pid(int pid)
+{
+	struct net_device *dev;
+	struct net_bridge *br=NULL;
+	int ret=0;
+
+	dev = __dev_get_by_name(&init_net,RTL_PS_BR0_DEV_NAME);
+	if (dev == NULL) 
+	{
+		ret =  -ENXIO; 	/* Could not find device */
+
+	}	
+	else if (!(dev->priv_flags & IFF_EBRIDGE)) {
+		
+		ret = -EPERM;
+	}
+	else 
+	{
+		br = netdev_priv(dev);
+	}
+	
+	if(br!=NULL)
+	{
+		br->igmpProxy_pid= pid;
+	}
+
+	return 1;
+}
+#endif
+
 int br_add_bridge(struct net *net, const char *name)
 {
 	struct net_device *dev;
@@ -286,6 +519,35 @@
 	ret = br_sysfs_addbr(dev);
 	if (ret)
 		unregister_netdevice(dev);
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if(strcmp(name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t devInfo;
+		memset(&devInfo, 0, sizeof(rtl_multicastDeviceInfo_t ));
+		strcpy(devInfo.devName, RTL_PS_BR0_DEV_NAME);
+		
+		ret=rtl_registerIgmpSnoopingModule(&brIgmpModuleIndex);
+		#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+		if(ret==0)
+		{
+			 rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex,&devInfo);
+		}
+		#endif
+		bridge0=netdev_priv(dev);
+		if(bridge0!=NULL)
+		{
+			init_timer(&bridge0->mCastQuerytimer);
+			bridge0->mCastQuerytimer.data=bridge0;
+			bridge0->mCastQuerytimer.expires=jiffies+MCAST_QUERY_INTERVAL*HZ;
+			bridge0->mCastQuerytimer.function=(void*)br_mCastQueryTimerExpired;
+			add_timer(&bridge0->mCastQuerytimer);
+		}
+		
+		rtl_setIpv4UnknownMCastFloodMap(brIgmpModuleIndex, 0x0);
+		rtl_setIpv6UnknownMCastFloodMap(brIgmpModuleIndex, 0xFFFFFFFF);
+	}
+#endif
  out:
 	rtnl_unlock();
 	return ret;
@@ -318,6 +580,20 @@
 	else
 		del_br(netdev_priv(dev));
 
+	#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if(strcmp(name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_unregisterIgmpSnoopingModule(brIgmpModuleIndex);
+		#if defined (CONFIG_RTL_MLD_SNOOPING)
+		if(bridge0 && timer_pending(&bridge0->mCastQuerytimer))
+		{
+			del_timer(&bridge0->mCastQuerytimer);
+		}
+		#endif
+		bridge0=NULL;
+	}
+	#endif
+
 	rtnl_unlock();
 	return ret;
 }
@@ -420,6 +696,19 @@
 
 	kobject_uevent(&p->kobj, KOBJ_ADD);
 
+	#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t brDevInfo;
+		rtl865x_generateBridgeDeviceInfo(br, &brDevInfo);
+		if(brIgmpModuleIndex!=0xFFFFFFFF)
+		{
+			rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex,&brDevInfo);
+		}
+		br0SwFwdPortMask=brDevInfo.swPortMask;
+	}
+	#endif
+
 	return 0;
 err2:
 	br_fdb_delete_by_port(br, p, 1);
@@ -448,6 +737,19 @@
 	br_features_recompute(br);
 	spin_unlock_bh(&br->lock);
 
+	#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)==0)
+	{
+		rtl_multicastDeviceInfo_t brDevInfo;
+		rtl865x_generateBridgeDeviceInfo(br, &brDevInfo);
+		if(brIgmpModuleIndex!=0xFFFFFFFF)
+		{
+			rtl_setIgmpSnoopingModuleDevInfo(brIgmpModuleIndex,&brDevInfo);
+		}
+		br0SwFwdPortMask=brDevInfo.swPortMask;
+	}
+	#endif
+
 	return 0;
 }
 
@@ -466,3 +768,37 @@
 	rtnl_unlock();
 
 }
+
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+int rtl865x_generateBridgeDeviceInfo( struct net_bridge *br, rtl_multicastDeviceInfo_t *devInfo)
+{
+	struct net_bridge_port *p, *n;
+	
+	if((br==NULL) || (devInfo==NULL))
+	{
+		return -1;
+	}
+	
+	memset(devInfo, 0, sizeof(rtl_multicastDeviceInfo_t));
+
+	if(strcmp(br->dev->name,RTL_PS_BR0_DEV_NAME)!=0)
+	{
+		return -1;
+	}
+
+	strcpy(devInfo->devName,br->dev->name);
+	
+		
+	list_for_each_entry_safe(p, n, &br->port_list, list) 
+	{
+		if(memcmp(p->dev->name, RTL_PS_ETH_NAME,3)!=0)
+		{
+			devInfo->swPortMask|=(1<<p->port_no);
+		}
+		devInfo->portMask|=(1<<p->port_no);
+		
+	}
+	
+	return 0;
+}
+#endif
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_input.c linux-2.6.30.9-rsdk/net/bridge/br_input.c
--- linux-2.6.30.9/net/bridge/br_input.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_input.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,13 +17,330 @@
 #include <linux/netfilter_bridge.h>
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#include <linux/ip.h>
+#include <linux/in.h>
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+#endif
+#include <linux/igmp.h>
+#include <net/checksum.h>
+#include <net/rtl/rtl865x_igmpsnooping_glue.h>
+#include <net/rtl/rtl865x_igmpsnooping.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+#include <linux/netfilter_ipv4/ip_tables.h>
+#endif
+
+extern int igmpsnoopenabled;
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+extern int mldSnoopEnabled;
+#endif
+extern unsigned int brIgmpModuleIndex;
+extern unsigned int br0SwFwdPortMask;
+
+#if defined (MCAST_TO_UNICAST)
+extern int IGMPProxyOpened;
+
+#if defined (IPV6_MCAST_TO_UNICAST)
+#include <linux/ipv6.h>
+#include <linux/in6.h>
+#include <linux/icmpv6.h>
+//#define	DBG_ICMPv6	//enable it to debug icmpv6 check
+static char ICMPv6_check(struct sk_buff *skb , unsigned char *gmac);
+#endif	//end of IPV6_MCAST_TO_UNICAST
+
+#endif	//end of MCAST_TO_UNICAST
+
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+#include <net/udp.h>
+#endif
+
+static char igmp_type_check(struct sk_buff *skb, unsigned char *gmac,unsigned int *gIndex,unsigned int *moreFlag);
+static void br_update_igmp_snoop_fdb(unsigned char op, struct net_bridge *br, struct net_bridge_port *p, unsigned char *gmac
+									,struct sk_buff *skb);
+#endif	//end of CONFIG_RTL_IGMP_SNOOPING
+
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+extern int br_filter_enter(struct sk_buff *skb);
+extern unsigned char dut_br0_mac[];
+extern unsigned char Filter_State;
+extern int enable_filter;
+#endif
+
 /* Bridge group multicast address 802.1d (pg 51). */
 const u8 br_group_address[ETH_ALEN] = { 0x01, 0x80, 0xc2, 0x00, 0x00, 0x00 };
 
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+#include <net/arp.h>
+#include <net/tcp.h>
+extern unsigned char inband_Hostmac[]; //mark_test
+extern unsigned int inband_HostIP;
+extern int br_hackMac_enable;
+
+#define RTK_WPS_LISTEN_PORT 52881
+#define MAX_LISTEN_ENDPOINT 8
+
+struct listen_info {
+	unsigned int src_ip;
+	unsigned short src_port;
+	unsigned char state;
+	unsigned char sync_retry;
+};
+
+enum {
+  IDLE_STATE = 0,
+  SYN_SENT_STATE,
+  CONNECTED_STATE,
+  FIN_WAIT_STATE,  
+  RTK_MAX_STATES /* Leave at the end! */
+};
+
+
+static struct listen_info listen_endpoint[MAX_LISTEN_ENDPOINT];
+
+void init_listen_endpoint()
+{
+	memset(&listen_endpoint[0],0,sizeof(struct listen_info)*MAX_LISTEN_ENDPOINT);
+}
+
+static int is_listening_endpoint(unsigned int ip,unsigned short port,struct tcphdr *tcph_ptr)
+{
+	int i,ret=0;
+
+	for(i=0;i<MAX_LISTEN_ENDPOINT;i++)
+	{
+		if( (listen_endpoint[i].src_port== port ) && (listen_endpoint[i].src_ip == ip) && 
+			(listen_endpoint[i].state != IDLE_STATE))			
+			break;
+	}
+
+	if( i == MAX_LISTEN_ENDPOINT)
+		return 0; //not listen..
+
+	if(listen_endpoint[i].state == SYN_SENT_STATE)	
+	{
+		if( tcph_ptr->syn  &&  tcph_ptr->ack )  //rcv - syn ack
+		{
+			listen_endpoint[i].state = CONNECTED_STATE;
+			ret=1;
+		}
+	} 	
+	else if(listen_endpoint[i].state == CONNECTED_STATE)// can rcv all pkt	
+	{
+		ret=1;
+		if(tcph_ptr->rst)
+			listen_endpoint[i].state = IDLE_STATE;
+	}
+	else if(listen_endpoint[i].state == FIN_WAIT_STATE)	//rcv ack to finish
+	{
+		ret=1;		  
+		if( (tcph_ptr->ack && (!(tcph_ptr->fin)))  || tcph_ptr->rst )  //rcv - pure  ack or rst , fin+ack will not enter idle state
+		{
+			listen_endpoint[i].state = IDLE_STATE;		
+		}	
+	}
+	
+	return ret;	
+}
+
+static void add_listen_info(unsigned int pkt_ip, unsigned short pkt_port)
+{
+	int i;
+	int entry1=-1,entry2=-1,entry2_retry=0;
+	//rule 1 , find idle state entry to replace
+	//rule 2 , find syn_sent state entry to replace
+	for(i=0;i<MAX_LISTEN_ENDPOINT;i++)
+	{
+		if( listen_endpoint[i].state == IDLE_STATE )			
+		{
+			entry1 = i;
+			break;
+		}
+		else if( (listen_endpoint[i].state == SYN_SENT_STATE) && (listen_endpoint[i].sync_retry >= 2))
+		{
+			if(listen_endpoint[i].sync_retry > entry2_retry)
+			{
+				entry2 = i;
+				entry2_retry = listen_endpoint[i].sync_retry;
+			}			
+		}
+	}		
+
+	if(entry1 < 0) //no idle entry
+	{
+		if(entry2 < 0)
+		{
+			printk("no ap_hcm listen_entry can be used!!!\n");
+			return;
+		}				
+		else
+			entry1 = entry2;
+	}	
+
+	listen_endpoint[entry1].src_ip = pkt_ip;
+	listen_endpoint[entry1].src_port= pkt_port;
+	listen_endpoint[entry1].state = SYN_SENT_STATE;
+	listen_endpoint[entry1].sync_retry= 0;
+
+}
+
+void check_listen_info(struct sk_buff *skb)
+{
+	struct iphdr *iph_ptr;
+	struct tcphdr *tcph_ptr;
+	int i,in_listening=0;
+	unsigned int pkt_ip;
+	unsigned short pkt_port;
+
+	//iph_ptr = skb->nh.iph;
+	iph_ptr = ip_hdr(skb); //mark_26
+	tcph_ptr=(void *) iph_ptr + iph_ptr->ihl*4;
+	pkt_ip = iph_ptr->daddr;
+	pkt_port = tcph_ptr->dest;
+
+	if((iph_ptr->protocol != IPPROTO_TCP))
+		return;
+
+	if((tcph_ptr->source == RTK_WPS_LISTEN_PORT)) //ingnore wps
+		return;
+	
+	//find if the pkt is already listening
+	for(i=0;i<MAX_LISTEN_ENDPOINT;i++)
+	{
+		if( (listen_endpoint[i].src_port== pkt_port ) && (listen_endpoint[i].src_ip == pkt_ip) )			
+		{
+			in_listening=1;
+			break;
+		}	
+	}
+
+	if(in_listening == 0) //the entry not find , so pnly sync pkt need to create a new listen entry
+	{
+		if((tcph_ptr->syn) && (!(tcph_ptr->ack)))
+			add_listen_info(pkt_ip,pkt_port);
+	}
+	else //already in listen
+	{
+		if( (tcph_ptr->syn) && (!(tcph_ptr->ack))) //only syn pkt
+		{
+			listen_endpoint[i].state = SYN_SENT_STATE;
+			listen_endpoint[i].sync_retry++;
+		}
+		else if((tcph_ptr->fin))
+		{
+			listen_endpoint[i].state = FIN_WAIT_STATE;
+		}
+		else if((tcph_ptr->rst))
+		{
+			listen_endpoint[i].state = IDLE_STATE;
+		}	
+		
+	}	
+
+}
+
+#endif
+
+#if defined (CONFIG_RTK_MESH)
+
+void br_signal_pathsel(struct net_bridge *br)
+{
+	struct task_struct *task;
+	if(br==NULL)
+	{
+		return;
+	}
+	read_lock(&tasklist_lock);
+	task = find_task_by_vpid(br->mesh_pathsel_pid);
+	read_unlock(&tasklist_lock);
+	if(task)
+	{
+    	    	//printk("Send signal from kernel\n");
+		send_sig(SIGUSR2,task,0);
+	}
+	else {
+	//printk("Path selection daemon pid: %d does not exist\n", br->mesh_pathsel_pid);
+	}
+}
+
+/*
+void br_signal_pathsel()
+{
+	struct task_struct *task;
+
+	struct net_bridge *br;
+
+	br = find_br_by_name("br0");
+	
+	read_lock(&tasklist_lock);
+    task = find_task_by_pid(br->mesh_pathsel_pid);
+    read_unlock(&tasklist_lock);
+    if(task)
+    {
+    	//printk("Send signal from kernel\n");
+        send_sig(SIGUSR2,task,0);
+		//br->stp_enabled = 1; //now pathsel daemon can turn it on
+	}
+    else {
+        //printk("Path selection daemon pid: %d does not exist\n", br->mesh_pathsel_pid);
+    }
+}
+*/
+#endif	//CONFIG_RTK_MESH
+
 static void br_pass_frame_up(struct net_bridge *br, struct sk_buff *skb)
 {
 	struct net_device *indev, *brdev = br->dev;
 
+#if 0//defined (CONFIG_RTL_IGMP_SNOOPING)
+        unsigned char *dest;
+        struct net_bridge_port *p;
+        unsigned char macAddr[6];
+        unsigned char operation;
+        struct iphdr *iph;
+	unsigned char proto=0;  
+                          
+	//iph = skb->nh.iph;
+	iph=(struct iphdr *)skb_network_header(skb);
+	proto =  iph->protocol;    
+	dest =  eth_hdr(skb)->h_dest;
+	p = skb->dev->br_port;
+
+	if (igmpsnoopenabled && MULTICAST_MAC(dest) && (eth_hdr(skb)->h_proto == ETH_P_IP)){
+                if (proto== IPPROTO_IGMP){
+			uint32 fwdPortMask;
+			//rtl_igmpMldProcess(brIgmpModuleIndex, skb->mac.raw, p->port_no, &fwdPortMask);
+			rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);
+			if ((operation=igmp_type_check(skb, macAddr)) > 0) {	
+               	            br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+                          }
+		}
+        }
+
+	#if defined (MCAST_TO_UNICAST)	
+	#if defined (IPV6_MCAST_TO_UNICAST)
+	else if(igmpsnoopenabled 
+		&& IPV6_MULTICAST_MAC(dest) 
+		&& (eth_hdr(skb)->h_proto == ETH_P_IPV6) )
+	{		
+		operation = ICMPv6_check(skb , macAddr);
+		if (operation > 0) {
+				#ifdef	DBG_ICMPv6
+				if( operation == 1)
+					printk("ICMPv6 mac add (from frame_up)\n");
+				else if(operation == 2)
+					printk("ICMPv6 mac del (from frame_up)\n");	
+				#endif
+               	br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+		}
+	}
+	#endif	//end of IPV6_MCAST_TO_UNICAST
+	#endif
+#endif
 	brdev->stats.rx_packets++;
 	brdev->stats.rx_bytes += skb->len;
 
@@ -34,6 +351,29 @@
 		netif_receive_skb);
 }
 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+extern int32 rtl865x_BlkCheck(const unsigned char *addr);
+#endif
+
+#if defined(CONFIG_RTL_MLD_SNOOPING)
+extern int re865x_getIpv6TransportProtocol(struct ipv6hdr* ipv6h);
+#endif
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST) 
+extern int rtl865x_ipMulticastHardwareAccelerate(struct net_bridge *br, unsigned int brFwdPortMask,
+												unsigned int srcPort,unsigned int srcVlanId, 
+												unsigned int srcIpAddr, unsigned int destIpAddr);
+#endif
+
+#ifdef CONFIG_RTL_EAP_RELAY
+extern unsigned char inband_Hostmac[];
+//unsigned char Wlan_mac[6]={0x00,0xE0,0x4C,0x01,0x96,0xC0};
+#endif
+
+#if defined(CONFIG_RTL_WLAN_BLOCK_RELAY)
+#define RTL_WLAN_INT_PREFIX "wlan"
+extern int rtl_wlan_block_relay_enable;
+#endif
+
 /* note: already called with rcu_read_lock (preempt_disabled) */
 int br_handle_frame_finish(struct sk_buff *skb)
 {
@@ -50,9 +390,134 @@
 	br = p->br;
 	br_fdb_update(br, p, eth_hdr(skb)->h_source);
 
+#if defined (CONFIG_RTL865X_LANPORT_RESTRICTION)
+	if (rtl865x_BlkCheck(eth_hdr(skb)->h_source) == TRUE)
+	{
+
+		kfree_skb(skb);
+		goto out;
+	}
+#endif
+	
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)	
+	if(enable_filter){
+		struct iphdr *iph_check;
+		iph_check = (struct iphdr *)skb_network_header(skb);	
+		if(Filter_State==0){
+			if(memcmp(dut_br0_mac, dest, 6)){
+				if(iph_check->protocol==IPPROTO_ICMP){
+					goto drop;
+				}
+			}
+		}
+#if 0		
+		else if(Filter_State==1 && (dest[0] & 1 == 0)){
+			struct udphdr *udph;
+			udph=(void *)iph_check + iph_check->ihl*4;
+			if(iph_check->protocol==IPPROTO_UDP && udph->dest ==68){ //if dhcp server packet if unicast
+				if(br_filter_enter(skb))
+					goto err;
+			}
+		}
+#endif		
+	}
+#endif
+
+#if defined(CONFIG_DOMAIN_NAME_QUERY_SUPPORT)
+	if(enable_filter){			
+		if(br_filter_enter(skb))
+			goto drop;
+	}	
+#endif	
+
+
 	if (p->state == BR_STATE_LEARNING)
 		goto drop;
 
+//mark_issue, all filter above will not work in host ip hack ,FIX ME
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+	//if it is arp response then we need to pass to both local and remote host	
+	//and redirect some protocol wps,802.1x to local not to remote host	
+	if(br_hackMac_enable == 0) //donot nothing 
+		goto ap_hcm_out;
+	else{		
+		if(eth_hdr(skb)->h_proto == ETH_P_ARP)
+		{
+			struct arphdr *arp = arp_hdr(skb);
+			if(arp->ar_op == __constant_htons(ARPOP_REPLY))
+			{
+				struct sk_buff *skb3;
+
+				if(memcmp(dest,inband_Hostmac,6)) //goout if mac is not for host
+					goto ap_hcm_out;
+
+				skb3 = skb_clone(skb, GFP_ATOMIC);			
+				if (skb3 != NULL) {
+					struct arphdr *arp3 = arp_hdr(skb3);
+					unsigned char *arp_ptr= (unsigned char *)(arp3+1);
+					//memcpy(arp_ptr+10,br->dev.dev_addr,6);   // cheat ARP layer that it's a ARP reply for local					
+					memcpy(arp_ptr+10,skb->dev->dev_addr,6);   // mark_issue, 	perm_addr in 2.6	
+					//memcpy(eth_hdr(skb3)->h_dest,br->dev.dev_addr,6);  							
+					memcpy(eth_hdr(skb3)->h_dest,skb->dev->dev_addr,6);  // mark_issue, 	perm_addr in 2.6							
+					//passedup = 1;				
+					//hex_dump(skb3->data,48);
+					skb3->pkt_type=PACKET_HOST; 
+					br_pass_frame_up(br, skb3);
+					memcpy(dest,inband_Hostmac,6); //recovery packet's mac to host
+				}
+			}
+		}
+		else if(eth_hdr(skb)->h_proto == ETH_P_IP)	//check packet's destIP == br0IP == Hostip
+		{
+			struct iphdr *iph_ptr;				
+			//struct udphdr *udph_ptr;
+			iph_ptr = ip_hdr(skb); //mark_26		
+		
+			if(iph_ptr->daddr == inband_HostIP )
+			{
+				if(memcmp(dest,inband_Hostmac,6)) //goout if mac is not for host
+					goto ap_hcm_out;
+
+				if((iph_ptr->protocol==IPPROTO_TCP))
+				{
+					struct tcphdr *tcph_ptr;
+					int trap_to_local =0;
+
+					tcph_ptr=(void *) iph_ptr + iph_ptr->ihl*4;
+
+					if( tcph_ptr->dest <= 1024) //dont listen  public tcp port, just bypass to Host ...
+						goto ap_hcm_out;
+
+					//listen for wps dst port 	
+					if( (tcph_ptr->dest == RTK_WPS_LISTEN_PORT)  || 
+					is_listening_endpoint(iph_ptr->saddr,tcph_ptr->source,tcph_ptr))
+						trap_to_local = 1;
+
+					if(trap_to_local)
+					{
+						//memcpy(dest,br->dev.dev_addr,6);  						
+						memcpy(eth_hdr(skb)->h_dest,skb->dev->dev_addr,6);										
+						//hex_dump(skb->data,48);
+						skb->pkt_type=PACKET_HOST; 
+						br_pass_frame_up(br, skb);
+						goto out;										
+					}	
+
+				}
+				//use icmp packet for test		
+				#if 0
+				else if(iph_ptr->protocol==IPPROTO_ICMP)
+				{
+					memcpy(dest,br->dev.dev_addr,6);  				
+					br_pass_frame_up(br, skb);
+						goto out;
+				}			
+				#endif
+			}			
+		}
+	}		
+ap_hcm_out:	
+#endif
 	/* The packet skb2 goes to the local host (NULL to skip). */
 	skb2 = NULL;
 
@@ -65,10 +530,22 @@
 		br->dev->stats.multicast++;
 		skb2 = skb;
 	} else if ((dst = __br_fdb_get(br, dest)) && dst->is_local) {
+#ifdef CONFIG_RTL_EAP_RELAY
+		if(eth_hdr(skb)->h_proto == 0x888E)
+		{			
+			memcpy(eth_hdr(skb)->h_dest,inband_Hostmac,6);
+			//else if(!memcmp(eth_hdr(skb)->h_source,inband_Hostmac,6)) // if src_mac == host .
+			//	memcpy(eth_hdr(skb)->h_source,Wlan_mac,6);
+			dst = __br_fdb_get(br, dest);					
+		}
+		else
+#endif	
+		{		
 		skb2 = skb;
 		/* Do not forward the packet since it's local. */
 		skb = NULL;
 	}
+	}
 
 	if (skb2 == skb)
 		skb2 = skb_clone(skb, GFP_ATOMIC);
@@ -76,12 +553,194 @@
 	if (skb2)
 		br_pass_frame_up(br, skb2);
 
+
 	if (skb) {
+#if defined(CONFIG_RTL_WLAN_BLOCK_RELAY)
+		if(rtl_wlan_block_relay_enable && dst){
+			if(!memcmp(skb->dev->name,RTL_WLAN_INT_PREFIX,sizeof(RTL_WLAN_INT_PREFIX)-1)){
+				if(!memcmp(dst->dst->dev->name,RTL_WLAN_INT_PREFIX,sizeof(RTL_WLAN_INT_PREFIX)-1))
+					goto drop;
+			}
+		}
+#endif
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if (is_multicast_ether_addr(dest) && igmpsnoopenabled) {
+		struct iphdr *iph=NULL;
+#if defined (CONFIG_RTL_MLD_SNOOPING) 	
+		struct ipv6hdr *ipv6h=NULL;
+#endif
+		uint32 fwdPortMask=0;
+#if defined (CONFIG_RTL_HARDWARE_MULTICAST)
+		unsigned int srcPort=skb->srcPort;
+		unsigned int srcVlanId=skb->srcVlanId;
+#endif
+
+		unsigned char proto=0;
+		unsigned char reserved=0;
+		int ret=FAILED;
+		
+		unsigned char macAddr[6];
+		unsigned char operation;
+		char tmpOp;
+		unsigned int gIndex=0;
+		unsigned int moreFlag=1;
+		
+		struct rtl_multicastDataInfo multicastDataInfo;
+		struct rtl_multicastFwdInfo multicastFwdInfo;
+
+		if ( !(br->dev->flags & IFF_PROMISC) 
+		 &&MULTICAST_MAC(dest) 
+		&& (eth_hdr(skb)->h_proto == ETH_P_IP))
+		{
+
+			iph=(struct iphdr *)skb_network_header(skb);
+			if(iph->daddr== 0xEFFFFFFA)
+			{
+				/*for microsoft upnp*/
+				reserved=1;
+			}
+#if 0
+			if((iph->daddr&0xFFFFFF00)==0xE0000000)
+			reserved=1;
+#endif
+			proto =  iph->protocol;  
+			if (proto == IPPROTO_IGMP) 
+			{	
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+				//filter igmp pkts by upper hook like iptables 
+				if(IgmpRxFilter_Hook != NULL)
+				{
+					if(IgmpRxFilter_Hook(skb, NF_INET_PRE_ROUTING,  skb->dev, NULL,dev_net(skb->dev)->ipv4.iptable_filter) !=NF_ACCEPT)
+					{
+						DEBUG_PRINT(" filter a pkt:%d %s:% \n", k, skb->dev->name, &(dev_net(skb->dev)->ipv4.iptable_filter->name[0]));
+						goto drop;
+					}
+				}else
+					DEBUG_PRINT("IgmpRxFilter_Hook is NULL\n");
+#endif
+				while(moreFlag)
+				{
+					tmpOp=igmp_type_check(skb, macAddr, &gIndex, &moreFlag);
+					if(tmpOp>0)
+					{
+						//printk("%s:%d,macAddr is 0x%x:%x:%x:%x:%x:%x\n",__FUNCTION__,__LINE__,macAddr[0],macAddr[1],macAddr[2],macAddr[3],macAddr[4],macAddr[5]);
+						operation=(unsigned char)tmpOp;
+						br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+					}
+				}
+				
+				rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);
+				br_multicast_forward(br, fwdPortMask, skb, 0);
+			}
+			else if(((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP)) && (reserved ==0))
+			{
+
+				iph=(struct iphdr *)skb_network_header(skb);
+				multicastDataInfo.ipVersion=4;
+				multicastDataInfo.sourceIp[0]=  (uint32)(iph->saddr);
+				multicastDataInfo.groupAddr[0]=  (uint32)(iph->daddr);
+				
+				ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+				br_multicast_forward(br, multicastFwdInfo.fwdPortMask, skb, 0);
+				if((ret==SUCCESS) && (multicastFwdInfo.cpuFlag==0))
+				{
+
+					#if defined  (CONFIG_RTL_HARDWARE_MULTICAST)
+					if((srcVlanId!=0) && (srcPort!=0xFFFF))
+					{
+						#if defined(CONFIG_RTK_VLAN_SUPPORT)
+						if(rtk_vlan_support_enable == 0)
+						{
+							rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+						}
+						#else
+						rtl865x_ipMulticastHardwareAccelerate(br, multicastFwdInfo.fwdPortMask,srcPort,srcVlanId, multicastDataInfo.sourceIp[0], multicastDataInfo.groupAddr[0]);
+						#endif
+					}	
+					#endif
+				}
+				
+
+			}
+			else
+			{
+				br_flood_forward(br, skb);
+			}
+		}
+		else if(!(br->dev->flags & IFF_PROMISC) 
+			&& IPV6_MULTICAST_MAC(dest)
+			&& (eth_hdr(skb)->h_proto == ETH_P_IPV6))
+		{
+
+#if defined (IPV6_MCAST_TO_UNICAST)
+			tmpOp=ICMPv6_check(skb , macAddr);
+			if(tmpOp > 0){
+				operation=(unsigned char)tmpOp;
+#ifdef	DBG_ICMPv6
+			if( operation == 1)
+				printk("icmpv6 add from frame finish\n");
+			else if(operation == 2)
+				printk("icmpv6 del from frame finish\n");	
+#endif
+				br_update_igmp_snoop_fdb(operation, br, p, macAddr,skb);
+			}
+#endif
+
+#if defined (CONFIG_RTL_MLD_SNOOPING)
+			if(mldSnoopEnabled)
+			{
+				ipv6h=(struct ipv6hdr *)skb_network_header(skb);
+				proto =  re865x_getIpv6TransportProtocol(ipv6h);
+				/*icmp protocol*/
+				if (proto == IPPROTO_ICMPV6) 
+				{	
+					rtl_igmpMldProcess(brIgmpModuleIndex, skb_mac_header(skb), p->port_no, &fwdPortMask);	
+					br_multicast_forward(br, fwdPortMask, skb, 0);
+				}
+				else if ((proto ==IPPROTO_UDP) ||(proto ==IPPROTO_TCP))
+				{
+					multicastDataInfo.ipVersion=6;
+					memcpy(&multicastDataInfo.sourceIp, &ipv6h->saddr, sizeof(struct in6_addr));
+					memcpy(&multicastDataInfo.groupAddr, &ipv6h->daddr, sizeof(struct in6_addr));	
+					ret= rtl_getMulticastDataFwdInfo(brIgmpModuleIndex, &multicastDataInfo, &multicastFwdInfo);
+					br_multicast_forward(br, multicastFwdInfo.fwdPortMask, skb, 0);
+				
+				}
+				else
+				{
+					br_flood_forward(br, skb);
+				}	
+			}
+			else
+#endif				
+			{
+				br_flood_forward(br, skb);
+			}
+
+		}
+		else
+		{
+			br_flood_forward(br, skb);
+		}
+
+	
+	}
+	else
+	{
+		/*known/unknown unicast packet*/
 		if (dst)
 			br_forward(dst->dst, skb);
 		else
 			br_flood_forward(br, skb);
 	}
+#else 
+
+		if (dst)
+			br_forward(dst->dst, skb);
+		else
+			br_flood_forward(br, skb);
+#endif	// CONFIG_RTL_IGMP_SNOOPING
+	}
 
 out:
 	return 0;
@@ -144,6 +803,20 @@
 		else
 			return skb;	/* continue processing */
 	}
+#if 0
+#if defined (STP_DISABLE_ETH)
+//chris: auto stp on
+	if (!(p->br->dev->flags & IFF_UP))
+		goto err;
+
+	if (p->state==BR_STATE_DISABLED && p->disable_by_mesh ==0){
+		goto err;
+	}else if (!strncmp(p->dev->name,"eth", 3)){
+			p->br->stp_enabled = 1;
+			mod_timer(&p->br->eth0_autostp_timer, jiffies+p->br->eth0_monitor_interval);
+	}
+#endif	
+#endif 
 
 forward:
 	switch (p->state) {
@@ -159,6 +832,26 @@
 		if (!compare_ether_addr(p->br->dev->dev_addr, dest))
 			skb->pkt_type = PACKET_HOST;
 
+#if defined (CONFIG_RTK_MESH)
+if (p->state == BR_STATE_FORWARDING) {
+		//brian modify for trigger portal-enable event
+		if(!strncmp(p->dev->name,RTL_PS_ETH_NAME, 3)){
+			if(p->br->mesh_pathsel_pid!= 0){
+				if( !(p->br->eth0_received) )
+				{
+					p->br->eth0_received = 1;
+					p->br->stp_enabled = 1;
+					br_signal_pathsel(p->br);
+					printk(KERN_INFO,"eth0 learning, event pathsel daemon \n");
+				}
+				
+				mod_timer(&p->br->eth0_monitor_timer, jiffies+p->br->eth0_monitor_interval);
+				
+			}
+		}
+}
+#endif	//CONFIG_RTK_MESH
+
 		NF_HOOK(PF_BRIDGE, NF_BR_PRE_ROUTING, skb, skb->dev, NULL,
 			br_handle_frame_finish);
 		break;
@@ -168,3 +861,452 @@
 	}
 	return NULL;
 }
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
+#if defined (IPV6_MCAST_TO_UNICAST)
+/*Convert  MultiCatst IPV6_Addr to MAC_Addr*/
+static void CIPV6toMac
+	(unsigned char* icmpv6_McastAddr, unsigned char *gmac )
+{
+	/*ICMPv6 valid addr 2^32 -1*/
+	gmac[0] = 0x33;
+	gmac[1] = 0x33;
+	gmac[2] = icmpv6_McastAddr[12];
+	gmac[3] = icmpv6_McastAddr[13];
+	gmac[4] = icmpv6_McastAddr[14];
+	gmac[5] = icmpv6_McastAddr[15];			
+}
+
+
+
+static char ICMPv6_check(struct sk_buff *skb , unsigned char *gmac)
+{
+	
+	struct ipv6hdr *ipv6h;
+	char* protoType;	
+	
+	/* check IPv6 header information */
+	//ipv6h = skb->nh.ipv6h;
+	ipv6h = (struct ipv6hdr *)skb_network_header(skb);
+	if(ipv6h->version != 6){	
+		//printk("ipv6h->version != 6\n");
+		return -1;
+	}
+
+
+	/*Next header: IPv6 hop-by-hop option (0x00)*/
+	if(ipv6h->nexthdr == 0)	{
+		protoType = (unsigned char*)( (unsigned char*)ipv6h + sizeof(struct ipv6hdr) );	
+	}else{
+		//printk("ipv6h->nexthdr != 0\n");
+		return -1;
+	}
+
+	if(protoType[0] == 0x3a){
+		
+		//printk("recv icmpv6 packet\n");
+		struct icmp6hdr* icmpv6h = (struct icmp6hdr*)(protoType + 8);
+		unsigned char* icmpv6_McastAddr ;
+	
+		if(icmpv6h->icmp6_type == 0x83){
+			
+			icmpv6_McastAddr = (unsigned char*)((unsigned char*)icmpv6h + 8);
+			#ifdef	DBG_ICMPv6					
+			printk("Type: 0x%x (Multicast listener report) \n",icmpv6h->icmp6_type);
+			#endif
+
+		}else if(icmpv6h->icmp6_type == 0x8f){		
+		
+			icmpv6_McastAddr = (unsigned char*)((unsigned char*)icmpv6h + 8 + 4);
+			#ifdef	DBG_ICMPv6					
+			printk("Type: 0x%x (Multicast listener report v2) \n",icmpv6h->icmp6_type);
+			#endif			
+		}else if(icmpv6h->icmp6_type == 0x84){
+		
+			icmpv6_McastAddr = (unsigned char*)((unsigned char*)icmpv6h + 8 );			
+			#ifdef	DBG_ICMPv6					
+			printk("Type: 0x%x (Multicast listener done ) \n",icmpv6h->icmp6_type);
+			#endif			
+		}
+		else{
+			#ifdef	DBG_ICMPv6
+			printk("Type: 0x%x (unknow type)\n",icmpv6h->icmp6_type);
+			#endif			
+			return -1;
+		}				
+
+		#ifdef	DBG_ICMPv6			
+		printk("MCAST_IPV6Addr:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x:%02x%02x \n",
+			icmpv6_McastAddr[0],icmpv6_McastAddr[1],icmpv6_McastAddr[2],icmpv6_McastAddr[3],
+			icmpv6_McastAddr[4],icmpv6_McastAddr[5],icmpv6_McastAddr[6],icmpv6_McastAddr[7],
+			icmpv6_McastAddr[8],icmpv6_McastAddr[9],icmpv6_McastAddr[10],icmpv6_McastAddr[11],
+			icmpv6_McastAddr[12],icmpv6_McastAddr[13],icmpv6_McastAddr[14],icmpv6_McastAddr[15]);
+		#endif
+
+		CIPV6toMac(icmpv6_McastAddr, gmac);
+		
+		#ifdef	DBG_ICMPv6					
+		printk("group_mac [%02x:%02x:%02x:%02x:%02x:%02x] \n",
+			gmac[0],gmac[1],gmac[2],
+			gmac[3],gmac[4],gmac[5]);
+		#endif
+			
+
+
+		if(icmpv6h->icmp6_type == 0x83){
+
+			return 1;//icmpv6 listener report (add)
+		}
+		else if(icmpv6h->icmp6_type == 0x8f){
+			return 1;//icmpv6 listener report v2 (add) 
+		}
+		else if(icmpv6h->icmp6_type == 0x84){
+			return 2;//icmpv6 Multicast listener done (del)
+		}
+	}		
+	else{
+		//printk("protoType[0] != 0x3a\n");		
+		return -1;//not icmpv6 type
+	}
+		
+	return -1;
+}
+
+#endif	//end of IPV6_MCAST_TO_UNICAST
+
+/*2008-01-15,for porting igmp snooping to linux kernel 2.6*/
+static void ConvertMulticatIPtoMacAddr(__u32 group, unsigned char *gmac)
+{
+	__u32 u32tmp, tmp;
+	int i;
+
+	u32tmp = group & 0x007FFFFF;
+	gmac[0]=0x01; gmac[1]=0x00; gmac[2]=0x5e;
+	for (i=5; i>=3; i--) {
+		tmp=u32tmp&0xFF;
+		gmac[i]=tmp;
+		u32tmp >>= 8;
+	}
+}
+static char igmp_type_check(struct sk_buff *skb, unsigned char *gmac,unsigned int *gIndex,unsigned int *moreFlag)
+{
+        struct iphdr *iph;
+	__u8 hdrlen;
+	struct igmphdr *igmph;
+	int i;
+	unsigned int groupAddr=0;// add  for fit igmp v3
+	*moreFlag=0;
+	/* check IP header information */
+	iph=(struct iphdr *)skb_network_header(skb);
+	hdrlen = iph->ihl << 2;
+	if ((iph->version != 4) &&  (hdrlen < 20))
+		return -1;
+	if (ip_fast_csum((u8 *)iph, iph->ihl) != 0)
+		return -1;
+	{ /* check the length */
+		__u32 len = ntohs(iph->tot_len);
+		if (skb->len < len || len < hdrlen)
+			return -1; 
+	}
+	/* parsing the igmp packet */
+	igmph = (struct igmphdr *)((u8*)iph+hdrlen);
+
+	
+	
+	if ((igmph->type==IGMP_HOST_MEMBERSHIP_REPORT) ||
+	    (igmph->type==IGMPV2_HOST_MEMBERSHIP_REPORT)) 
+	{
+		groupAddr = igmph->group;
+		if(!IN_MULTICAST(groupAddr))
+		{			
+				return -1;
+		}
+		
+		ConvertMulticatIPtoMacAddr(groupAddr, gmac);
+		
+		return 1; /* report and add it */
+	}
+	else if (igmph->type==IGMPV3_HOST_MEMBERSHIP_REPORT)	{ 
+		
+	
+		/*for support igmp v3 ; plusWang add 2009-0311*/   	
+		struct igmpv3_report *igmpv3report=(struct igmpv3_report * )igmph;
+		struct igmpv3_grec	*igmpv3grec=NULL; 
+		//printk("%s:%d,*gIndex is %d,igmpv3report->ngrec is %d\n",__FUNCTION__,__LINE__,*gIndex,igmpv3report->ngrec);
+		if(*gIndex>=igmpv3report->ngrec)
+		{
+			*moreFlag=0;
+			return -1;
+		}
+	
+		for(i=0;i<igmpv3report->ngrec;i++)
+		{
+
+			if(i==0)
+			{
+				igmpv3grec = (struct igmpv3_grec *)(&(igmpv3report->grec)); /*first igmp group record*/
+			}
+			else
+			{
+				igmpv3grec=(struct igmpv3_grec *)((unsigned char*)igmpv3grec+8+igmpv3grec->grec_nsrcs*4+(igmpv3grec->grec_auxwords)*4);
+				
+				
+			}
+			
+			if(i!=*gIndex)
+			{	
+				
+				continue;
+			}
+			
+			if(i==(igmpv3report->ngrec-1))
+			{
+				/*last group record*/
+				*moreFlag=0;
+			}
+			else
+			{
+				*moreFlag=1;
+			}
+			
+			/*gIndex move to next group*/
+			*gIndex=*gIndex+1;	
+			
+			groupAddr=igmpv3grec->grec_mca;
+			//printk("%s:%d,groupAddr is %d.%d.%d.%d\n",__FUNCTION__,__LINE__,NIPQUAD(groupAddr));
+			if(!IN_MULTICAST(groupAddr))
+			{			
+				return -1;
+			}
+			
+			ConvertMulticatIPtoMacAddr(groupAddr, gmac);
+			if(((igmpv3grec->grec_type == IGMPV3_CHANGE_TO_INCLUDE) || (igmpv3grec->grec_type == IGMPV3_MODE_IS_INCLUDE))&& (igmpv3grec->grec_nsrcs==0))
+			{	
+				return 2; /* leave and delete it */	
+			}
+			else if((igmpv3grec->grec_type == IGMPV3_CHANGE_TO_EXCLUDE) ||
+				(igmpv3grec->grec_type == IGMPV3_MODE_IS_EXCLUDE) ||
+				(igmpv3grec->grec_type == IGMPV3_ALLOW_NEW_SOURCES))
+			{
+				return 1;
+			}
+			else
+			{
+				/*ignore it*/
+			}
+			
+			return -1;
+		}
+		
+		/*avoid dead loop in case of initial gIndex is too big*/
+		if(i>=(igmpv3report->ngrec-1))
+		{
+			/*last group record*/
+			*moreFlag=0;
+			return -1;
+		}
+		
+	
+	}
+	else if (igmph->type==IGMP_HOST_LEAVE_MESSAGE){
+
+		groupAddr = igmph->group;
+		if(!IN_MULTICAST(groupAddr))
+		{			
+				return -1;
+		}
+		
+		ConvertMulticatIPtoMacAddr(groupAddr, gmac);
+		return 2; /* leave and delete it */
+	}	
+	
+	
+	return -1;
+}
+
+extern int chk_igmp_ext_entry(struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac);
+extern void add_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb , unsigned char *srcMac , unsigned char portComeIn);
+extern void update_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn);
+extern void del_igmp_ext_entry(	struct net_bridge_fdb_entry *fdb ,unsigned char *srcMac , unsigned char portComeIn );
+
+static void br_update_igmp_snoop_fdb(unsigned char op, struct net_bridge *br, struct net_bridge_port *p, unsigned char *dest 
+										,struct sk_buff *skb)
+{
+	struct net_bridge_fdb_entry *dst;
+	unsigned char *src;
+	unsigned short del_group_src=0;
+	unsigned char port_comein;
+	int tt1;
+
+#if defined (MCAST_TO_UNICAST)
+	struct net_device *dev; 
+	if(!dest)	return;
+	if( !MULTICAST_MAC(dest)
+#if defined (IPV6_MCAST_TO_UNICAST)
+		&& !IPV6_MULTICAST_MAC(dest)
+#endif	
+	   )
+	   { 
+	   	return; 
+	   }
+#endif
+
+#if defined( CONFIG_RTL_HARDWARE_MULTICAST) || defined(CONFIG_RTL865X_LANPORT_RESTRICTION)
+
+	if(skb->srcPort!=0xFFFF)
+	{
+		port_comein = 1<<skb->srcPort;
+	}
+	else
+	{
+		port_comein=0x80;
+	}
+	
+#else
+	if(p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_LAN_P0_DEV_NAME, 4))
+	{
+		port_comein = 0x01;
+	}
+	
+	if(p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_WLAN_NAME, 4))
+	{
+		port_comein=0x80;
+	}
+	
+#endif
+//	src=(unsigned char*)(skb->mac.raw+ETH_ALEN);
+	src=(unsigned char*)(skb_mac_header(skb)+ETH_ALEN);
+	/* check whether entry exist */
+	dst = __br_fdb_get(br, dest);
+
+	if (op == 1) /* add */
+	{	
+	
+#if defined (MCAST_TO_UNICAST)
+		/*process wlan client join --- start*/
+		if (dst && p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_WLAN_NAME, 4)) 
+		{ 
+			dst->portlist |= 0x80;
+			port_comein = 0x80;
+			//dev = __dev_get_by_name(&init_net,RTL_PS_WLAN0_DEV_NAME);	
+			dev=p->dev;
+			if (dev) 
+			{		
+				unsigned char StaMacAndGroup[20];
+				memcpy(StaMacAndGroup, dest, 6);
+				memcpy(StaMacAndGroup+6, src, 6);	
+			#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				if (dev->do_ioctl != NULL) 
+				{
+					dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B80);
+					DEBUG_PRINT("... add to wlan mcast table:  DA:%02x:%02x:%02x:%02x:%02x:%02x ; SA:%02x:%02x:%02x:%02x:%02x:%02x\n", 
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);					
+				}
+			#else
+				if (dev->netdev_ops->ndo_do_ioctl != NULL) 
+				{
+					dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B80);
+					DEBUG_PRINT("... add to wlan mcast table:  DA:%02x:%02x:%02x:%02x:%02x:%02x ; SA:%02x:%02x:%02x:%02x:%02x:%02x\n", 
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);	
+				}
+			#endif
+				
+														
+			}
+		}
+	/*process wlan client join --- end*/
+#endif
+
+			if (dst) 
+			{
+		        	dst->group_src = dst->group_src | (1 << p->port_no);
+
+				dst->ageing_timer = jiffies;
+
+				tt1 = chk_igmp_ext_entry(dst , src); 
+				if(tt1 == 0)
+				{
+					add_igmp_ext_entry(dst , src , port_comein);									
+				}
+				else
+				{
+					update_igmp_ext_entry(dst , src , port_comein);
+				}	
+			}
+			else
+			{
+				/* insert one fdb entry */
+				DEBUG_PRINT("insert one fdb entry\n");
+				br_fdb_insert(br, p, dest);
+				dst = __br_fdb_get(br, dest);
+				if(dst !=NULL)
+				{
+					dst->igmpFlag=1;
+					dst->is_local=0;
+					dst->portlist = port_comein; 
+					dst->group_src = dst->group_src | (1 << p->port_no);
+				}
+			}
+		
+	}
+	else if (op == 2 && dst) /* delete */
+	{
+		DEBUG_PRINT("dst->group_src = %x change to ",dst->group_src);		
+			del_group_src = ~(1 << p->port_no);
+			dst->group_src = dst->group_src & del_group_src;
+		DEBUG_PRINT(" %x ; p->port_no=%x \n",dst->group_src ,p->port_no);
+
+		/*process wlan client leave --- start*/
+		if (p && p->dev && p->dev->name && !memcmp(p->dev->name, RTL_PS_WLAN_NAME, 4)) 
+		{ 			
+			#ifdef	MCAST_TO_UNICAST
+			//struct net_device *dev = __dev_get_by_name(&init_net,RTL_PS_WLAN0_DEV_NAME);
+			struct net_device *dev=p->dev;
+			if (dev) 
+			{			
+				unsigned char StaMacAndGroup[12];
+				memcpy(StaMacAndGroup, dest , 6);
+				memcpy(StaMacAndGroup+6, src, 6);
+			#if defined(CONFIG_COMPAT_NET_DEV_OPS)
+				if (dev->do_ioctl != NULL) 
+				{
+					dev->do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);									
+					DEBUG_PRINT("(del) wlan0 ioctl (del) M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+				}
+			#else
+				if (dev->netdev_ops->ndo_do_ioctl != NULL) 
+				{
+					dev->netdev_ops->ndo_do_ioctl(dev, (struct ifreq*)StaMacAndGroup, 0x8B81);				
+					DEBUG_PRINT("(del) wlan0 ioctl (del) M2U entry da:%02x:%02x:%02x-%02x:%02x:%02x; sa:%02x:%02x:%02x-%02x:%02x:%02x\n",
+						StaMacAndGroup[0],StaMacAndGroup[1],StaMacAndGroup[2],StaMacAndGroup[3],StaMacAndGroup[4],StaMacAndGroup[5],
+						StaMacAndGroup[6],StaMacAndGroup[7],StaMacAndGroup[8],StaMacAndGroup[9],StaMacAndGroup[10],StaMacAndGroup[11]);
+				}
+			#endif	
+			
+			}
+			#endif	
+			//dst->portlist &= ~0x80;	// move to del_igmp_ext_entry
+			port_comein	= 0x80;
+		}
+		/*process wlan client leave --- end*/
+
+		/*process entry del , portlist update*/
+		del_igmp_ext_entry(dst , src ,port_comein);
+		
+		if (dst->portlist == 0)  // all joined sta are gone
+		{
+			DEBUG_PRINT("----all joined sta are gone,make it expired----\n");
+			dst->ageing_timer -=  300*HZ; // make it expired		
+		}
+		
+
+	}
+}
+
+#endif // CONFIG_RTL_IGMP_SNOOPING
+
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_ioctl.c linux-2.6.30.9-rsdk/net/bridge/br_ioctl.c
--- linux-2.6.30.9/net/bridge/br_ioctl.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_ioctl.c	2011-12-05 15:50:14.000000000 +0000
@@ -20,6 +20,11 @@
 #include <asm/uaccess.h>
 #include "br_private.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
 /* called with RTNL */
 static int get_bridge_ifindices(struct net *net, int *indices, int num)
 {
@@ -260,6 +265,28 @@
 			return -EPERM;
 
 		br_stp_set_enabled(br, args[1]);
+#if defined (CONFIG_RTL_STP)
+		{
+			int retval=0;
+			retval=rtl865x_setSpanningEnable(args[1]? TRUE:FALSE);
+
+			if(0==retval)
+				printk("RTL STP %s\n", args[1]?"enabled":"disabled");
+			else
+				printk("RTL STP set %s error=%d\n", args[1]?"enabled":"disabled", retval);
+		}		
+		
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+		{
+			int retval=0;
+			retval=rtl865x_setSpanningEnable(args[1]? TRUE:FALSE);
+			if(0==retval)
+				printk("RTL STP %s\n", args[1]?"enabled":"disabled");
+			else
+				printk("RTL STP set %s error=%d", args[1]?"enabled":"disabled", retval);			
+		}
+#endif
 		return 0;
 
 	case BRCTL_SET_BRIDGE_PRIORITY:
@@ -315,6 +342,14 @@
 	return -EOPNOTSUPP;
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+extern int br_set_igmpProxy_pid(int pid);
+#endif
+
+#if defined (CONFIG_RTK_MESH)
+int br_set_meshpathsel_pid(int pid);
+#endif
+
 static int old_deviceless(struct net *net, void __user *uarg)
 {
 	unsigned long args[3];
@@ -364,6 +399,44 @@
 
 		return br_del_bridge(net, buf);
 	}
+
+#if defined (CONFIG_RTK_MESH)
+	//by brian, dynamic portal enable
+	case BRCTL_SET_MESH_PATHSELPID:
+	{
+		return br_set_meshpathsel_pid(args[1]);
+	}
+	case BRCTL_GET_PORTSTAT:
+	{
+		struct net_bridge *br;
+		struct net_device *dev =NULL;
+		int ret=0;
+
+		dev = __dev_get_by_name(net, RTL_PS_BR0_DEV_NAME);
+		if (dev == NULL) 
+		{
+			return -1;
+
+		}	
+		else if (!(dev->priv_flags & IFF_EBRIDGE)) 
+		{
+			return -1;
+		}
+		else 
+		{
+			br = netdev_priv(dev);
+		}
+
+			return br->eth0_received;
+	}
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	case BRCTL_SET_IGMPPROXY_PID:
+	{
+		return br_set_igmpProxy_pid(args[1]);
+	}
+#endif
 	}
 
 	return -EOPNOTSUPP;
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_notify.c linux-2.6.30.9-rsdk/net/bridge/br_notify.c
--- linux-2.6.30.9/net/bridge/br_notify.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_notify.c	2011-12-05 15:50:14.000000000 +0000
@@ -66,6 +66,12 @@
 
 	case NETDEV_DOWN:
 		spin_lock_bh(&br->lock);
+#if 0
+#if defined (STP_DISABLE_ETH)
+			//Chris: stp+mesh
+			p->disable_by_mesh = 0;
+#endif
+#endif 
 		if (br->dev->flags & IFF_UP)
 			br_stp_disable_port(p);
 		spin_unlock_bh(&br->lock);
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_private.h linux-2.6.30.9-rsdk/net/bridge/br_private.h
--- linux-2.6.30.9/net/bridge/br_private.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_private.h	2011-12-05 15:50:14.000000000 +0000
@@ -16,6 +16,47 @@
 #include <linux/netdevice.h>
 #include <linux/if_bridge.h>
 #include <net/route.h>
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+
+#define MULTICAST_MAC(mac) 	   ((mac[0]==0x01)&&(mac[1]==0x00)&&(mac[2]==0x5e))
+#define IPV6_MULTICAST_MAC(mac) ((mac[0]==0x33)&&(mac[1]==0x33) && mac[2]!=0xff)
+//#define CONFIG_BRIDGE_IGMPV3_SNOOPING
+
+//#define DEBUG_PRINT(fmt, args...) printk(fmt, ## args)
+#define DEBUG_PRINT(fmt, args...)
+
+#define MCAST_TO_UNICAST
+
+#define IGMP_EXPIRE_TIME (260*HZ)
+
+#if defined (MCAST_TO_UNICAST)
+#define IPV6_MCAST_TO_UNICAST
+#endif
+
+#define MLCST_FLTR_ENTRY	16
+#define MLCST_MAC_ENTRY		64
+
+extern int rtk_vlan_support_enable;
+// interface to set multicast bandwidth control
+//#define MULTICAST_BWCTRL
+
+// interface to enable MAC clone function
+//#define RTL_BRIDGE_MAC_CLONE
+//#define RTL_BRIDGE_DEBUG
+
+#define MCAST_QUERY_INTERVAL 30
+
+#endif
+
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2
+#define CONFIG_RTL865X_ETH
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtk_vlan.h>
+#include <net/rtl/rtk_stp.h>
+#endif
 
 #define BR_HASH_BITS 8
 #define BR_HASH_SIZE (1 << BR_HASH_BITS)
@@ -30,10 +71,40 @@
 /* Path to usermode spanning tree program */
 #define BR_STP_PROG	"/sbin/bridge-stp"
 
+#if defined (CONFIG_RTK_MESH)
+#define STP_ADDCOST_ETH
+
+#define MESH_PORTAL_EXPIRE 300 //seconds
+#if 0
+#ifdef STP_DISABLE_ETH
+//Chris: stp+mesh
+#define ETH_CHK_INTVL		(30*HZ)
+#endif
+#endif
+#endif
+
 typedef struct bridge_id bridge_id;
 typedef struct mac_addr mac_addr;
 typedef __u16 port_id;
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+#define FDB_IGMP_EXT_NUM 8
+struct fdb_igmp_ext_entry
+{
+	int valid;
+	unsigned long ageing_time;
+	unsigned char SrcMac[6];	
+	unsigned char port;
+
+};
+
+struct fdb_igmp_ext_array
+{
+	struct fdb_igmp_ext_entry igmp_fdb_arr[FDB_IGMP_EXT_NUM];
+};
+
+#endif
+
 struct bridge_id
 {
 	unsigned char	prio[2];
@@ -53,6 +124,15 @@
 	struct rcu_head			rcu;
 	atomic_t			use_count;
 	unsigned long			ageing_timer;
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	unsigned short group_src;
+	unsigned char			igmpFlag;
+	unsigned char			portlist;
+	int 					portUsedNum[8];	// be used with portlist, for record each port has how many client
+	//struct fdb_igmp_ext_array	igmp_ext_array;
+	struct fdb_igmp_ext_entry igmp_fdb_arr[FDB_IGMP_EXT_NUM];
+#endif
+
 	mac_addr			addr;
 	unsigned char			is_local;
 	unsigned char			is_static;
@@ -82,6 +162,16 @@
 	struct timer_list		message_age_timer;
 	struct kobject			kobj;
 	struct rcu_head			rcu;
+
+//Chris:  stp+mesh
+#if 0
+#ifdef STP_DISABLE_ETH
+//Chris:  stp+mesh
+	int	 				disable_by_mesh; 
+		//0: no, 1:eth port disabled because mesh entering blocking state
+	struct timer_list		eth_disable_timer;
+#endif
+#endif //CONFIG_RTK_MESH
 };
 
 struct net_bridge
@@ -128,6 +218,30 @@
 	struct timer_list		topology_change_timer;
 	struct timer_list		gc_timer;
 	struct kobject			*ifobj;
+#if defined (CONFIG_RTK_MESH)
+	//by brian, record pid for dynamic enable portal
+	int mesh_pathsel_pid;
+	int eth0_received;
+
+	int	eth0_monitor_interval;
+	struct timer_list	eth0_monitor_timer;
+
+#if 0
+#if defined (STP_DISABLE_ETH)
+	struct timer_list	eth0_autostp_timer;
+#endif
+#endif
+
+#if defined (STP_ADDCOST_ETH)
+	int is_cost_changed;
+#endif
+
+#endif //CONFIG_RTK_MESH
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	int igmpProxy_pid;
+	struct timer_list	mCastQuerytimer;
+#endif
 };
 
 extern struct notifier_block br_device_notifier;
@@ -176,6 +290,18 @@
 extern void br_flood_deliver(struct net_bridge *br, struct sk_buff *skb);
 extern void br_flood_forward(struct net_bridge *br, struct sk_buff *skb);
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+void br_multicast_deliver(struct net_bridge *br,
+			unsigned int fwdPortMask, 
+			struct sk_buff *skb,
+			int clone);
+
+void br_multicast_forward(struct net_bridge *br,
+                        unsigned int fwdPortMask,
+                        struct sk_buff *skb,
+                        int clone);
+#endif
+
 /* br_if.c */
 extern void br_port_carrier_check(struct net_bridge_port *p);
 extern int br_add_bridge(struct net *net, const char *name);
@@ -188,6 +314,10 @@
 extern int br_min_mtu(const struct net_bridge *br);
 extern void br_features_recompute(struct net_bridge *br);
 
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+extern  int br_initial_port_cost(struct net_device *dev);
+#endif
+
 /* br_input.c */
 extern int br_handle_frame_finish(struct sk_buff *skb);
 extern struct sk_buff *br_handle_frame(struct net_bridge_port *p,
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_private_stp.h linux-2.6.30.9-rsdk/net/bridge/br_private_stp.h
--- linux-2.6.30.9/net/bridge/br_private_stp.h	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_private_stp.h	2011-12-05 15:50:14.000000000 +0000
@@ -49,6 +49,14 @@
 extern void br_transmit_tcn(struct net_bridge *br);
 extern void br_topology_change_detection(struct net_bridge *br);
 
+#if defined (CONFIG_RTK_MESH)
+extern void br_signal_pathsel(struct net_bridge *br);
+#if defined (STP_ADDCOST_ETH)
+extern void br_reset_cost(struct net_bridge_port * p);
+#endif
+#endif
+
+
 /* br_stp_bpdu.c */
 extern void br_send_config_bpdu(struct net_bridge_port *, struct br_config_bpdu *);
 extern void br_send_tcn_bpdu(struct net_bridge_port *);
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_stp.c linux-2.6.30.9-rsdk/net/bridge/br_stp.c
--- linux-2.6.30.9/net/bridge/br_stp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_stp.c	2011-12-05 15:50:14.000000000 +0000
@@ -16,6 +16,11 @@
 #include "br_private.h"
 #include "br_private_stp.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
 /* since time values in bpdu are in jiffies and then scaled (1/256)
  * before sending, make sure that is at least one.
  */
@@ -323,9 +328,16 @@
 	list_for_each_entry(p, &br->port_list, list) {
 		if (p->state != BR_STATE_DISABLED &&
 		    br_is_designated_port(p))
+			{
+#if defined (CONFIG_RTL_STP)
+				// bpdu not tx at eth0, because bpdu tx at virtual device port0~3 mapping to physical port0~3
+				if(memcmp((void *)(p->dev->name), "eth0", 4)==0)
+					continue;
+#endif
 			br_transmit_config(p);
 	}
 }
+}
 
 /* called under bridge lock */
 static inline void br_reply(struct net_bridge_port *p)
@@ -356,15 +368,161 @@
 /* called under bridge lock */
 static void br_make_blocking(struct net_bridge_port *p)
 {
+#if defined (CONFIG_RTK_MESH)
+#if defined (STP_ADDCOST_ETH) || defined (STP_DISABLE_ETH) 
+//Chris:  stp+mesh
+	struct net_bridge_port *tp,*n;
+#endif
+#endif //CONFIG_RTK_MESH
+
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	if (p->state != BR_STATE_DISABLED &&
 	    p->state != BR_STATE_BLOCKING) {
 		if (p->state == BR_STATE_FORWARDING ||
 		    p->state == BR_STATE_LEARNING)
 			br_topology_change_detection(p->br);
 
+#if defined (CONFIG_RTK_MESH)
+#if 0
+#if defined (STP_DISABLE_ETH)
+// Chris: stp+mesh. if the blocking port is mesh, we disable the eth0 to avoid isolated MP
+// 			NOTE: MUST resume the interface after loop disapeared
+		if (!strncmp(p->dev->name, "wlan0-msh0", 10)){
+			
+			list_for_each_entry_safe(tp, n, &p->br->port_list, list) 
+			{
+				if (!strncmp(tp->dev->name, "eth", 3) && (tp->state != BR_STATE_DISABLED))
+				{
+					tp->disable_by_mesh = 1;
+					br_stp_disable_port(tp);
+					printk(KERN_INFO "%s: port %i(%s) entering %s state\n",
+	  				    tp->br->dev->name, tp->port_no, tp->dev->name, "disabled if mesh blocked");
+				}
+	         
+			}
+	
+		}
+		else
+		{
+			p->state = BR_STATE_BLOCKING;
+			br_log_state(p);
+			del_timer(&p->forward_delay_timer);
+		}
+#endif
+#endif
+
+#if defined (STP_ADDCOST_ETH)
+// Chris:  stp+mesh. Add cost on eth to block it. 
+//		 NOTE: should set to default cost when topology changed
+		if (!strncmp(p->dev->name, "wlan0-msh0", 10)){
+			list_for_each_entry_safe(tp, n, &p->br->port_list, list) 
+			{
+				if (tp!=p && (tp->state != BR_STATE_DISABLED)){
+					br_stp_set_path_cost(tp, tp->path_cost+50);
+					printk(KERN_INFO "%s: port %i(%s) set path_cost %d \n",
+	  				    tp->br->dev->name, tp->port_no, tp->dev->name, tp->path_cost);
+					p->br->is_cost_changed = 1;
+				}
+			}
+		}else {
+			p->state = BR_STATE_BLOCKING;
+			br_log_state(p);
+			del_timer(&p->forward_delay_timer);
+		}
+		
+#endif
+#endif
+
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+
+		#ifdef CONFIG_RTK_MESH	
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port !=WLAN_MESH_PSEUDO_IF_INDEX) &&  (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_BLOCKING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_BLOCKING);
+		}
+		else if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH	
+		else if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
+#if defined (CONFIG_RTK_MESH)		
+#else
 		p->state = BR_STATE_BLOCKING;
 		br_log_state(p);
 		del_timer(&p->forward_delay_timer);
+#endif		
 	}
 }
 
@@ -373,6 +531,16 @@
 {
 	struct net_bridge *br = p->br;
 
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	if (p->state != BR_STATE_BLOCKING)
 		return;
 
@@ -382,9 +550,159 @@
 		del_timer(&p->forward_delay_timer);
 	}
 	else if (p->br->stp_enabled == BR_KERNEL_STP)
+	{
 		p->state = BR_STATE_LISTENING;
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#ifdef CONFIG_RTK_MESH
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_LISTENING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_LISTENING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LISTENING;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LISTENING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_LISTENING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_LISTENING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
+	}
 	else
+	{
 		p->state = BR_STATE_LEARNING;
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];	
+		#ifdef CONFIG_RTK_MESH
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_LEARNING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_LEARNING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#ifdef CONFIG_RTK_MESH
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
+	}
 
 	br_log_state(p);
 
@@ -469,8 +787,31 @@
 	if (br_is_designated_port(p)) {
 		pr_info("%s: received tcn bpdu on port %i(%s)\n",
 		       p->br->dev->name, p->port_no, p->dev->name);
-
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+		br_reset_cost(p);
+#endif
 		br_topology_change_detection(p->br);
 		br_topology_change_acknowledge(p);
 	}
 }
+
+
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+
+/* called under bridge lock */
+void br_reset_cost(struct net_bridge_port *p){
+	struct net_bridge_port *tp,*n;
+	
+	if (p->br->is_cost_changed) {
+		list_for_each_entry_safe(tp, n, &p->br->port_list, list) 
+		{
+			if (strncmp(tp->dev->name, "wlan0-msh0", 10)){
+				tp->path_cost = br_initial_port_cost(tp->dev);
+				printk(KERN_INFO "%s: port %i(%s) set default path_cost %d \n",
+					    tp->br->dev->name, tp->port_no, tp->dev->name, tp->path_cost);
+			}
+		}
+		p->br->is_cost_changed = 0;
+	}
+}
+#endif
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_stp_if.c linux-2.6.30.9-rsdk/net/bridge/br_stp_if.c
--- linux-2.6.30.9/net/bridge/br_stp_if.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_stp_if.c	2011-12-05 15:50:14.000000000 +0000
@@ -18,6 +18,10 @@
 #include "br_private.h"
 #include "br_private_stp.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
 
 /* Port id is composed of priority and port number.
  * NB: least significant bits of priority are dropped to
@@ -32,11 +36,111 @@
 /* called under bridge lock */
 void br_init_port(struct net_bridge_port *p)
 {
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;		
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	p->port_id = br_make_port_id(p->priority, p->port_no);
 	br_become_designated_port(p);
 	p->state = BR_STATE_BLOCKING;
+	
+#if defined (CONFIG_RTL_STP)
+	if(strncmp(p->dev->name,"port",4) == 0)
+	{
+
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#if defined (CONFIG_RTK_MESH)
+		if((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) &&(Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_BLOCKING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_BLOCKING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return ;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#if defined (CONFIG_RTK_MESH)
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return ;
+			}
+			pseudo_dev->br_port->state = BR_STATE_BLOCKING;
+			retval = SUCCESS;
+		}
+		#endif
+		else if(Port == NO_MAPPING)
+		{
+			p->state = BR_STATE_DISABLED;
+		}
+	}
+#endif
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_BLOCKING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+	
 	p->topology_change_ack = 0;
 	p->config_pending = 0;
+#if 0
+// Chris: stp+mesh
+#ifdef STP_DISABLE_ETH
+	p->disable_by_mesh = 0;
+	del_timer(&p->eth_disable_timer);
+	init_timer(&p->eth_disable_timer);
+#endif
+#endif
+
 }
 
 /* called under bridge lock */
@@ -66,7 +170,15 @@
 	spin_lock_bh(&br->lock);
 	list_for_each_entry(p, &br->port_list, list) {
 		if (p->state != BR_STATE_DISABLED)
+	{
+	#if 0
+	#if defined (STP_DISABLE_ETH)
+	//Chris:  stp+mesh
+			p->disable_by_mesh = 0;
+	#endif
+	#endif 
 			br_stp_disable_port(p);
+}
 
 	}
 
@@ -92,8 +204,50 @@
 {
 	struct net_bridge *br;
 	int wasroot;
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
 
 	br = p->br;
+
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_DISABLED);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 	printk(KERN_INFO "%s: port %i(%s) entering %s state\n",
 	       br->dev->name, p->port_no, p->dev->name, "disabled");
 
@@ -109,6 +263,18 @@
 
 	br_fdb_delete_by_port(br, p, 0);
 
+#if 0
+#if defined (STP_DISABLE_ETH)
+	// Chris: stp+mesh
+	if (p->disable_by_mesh == 0)
+		del_timer(&p->eth_disable_timer);
+	else {
+		//printk("set disable timer\n");
+		mod_timer(&p->eth_disable_timer, jiffies+ETH_CHK_INTVL);
+	}
+#endif
+#endif
+
 	br_configuration_update(br);
 
 	br_port_state_selection(br);
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/br_stp_timer.c linux-2.6.30.9-rsdk/net/bridge/br_stp_timer.c
--- linux-2.6.30.9/net/bridge/br_stp_timer.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/br_stp_timer.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,6 +17,17 @@
 #include "br_private.h"
 #include "br_private_stp.h"
 
+#if defined (CONFIG_RTL_STP)
+#include <net/rtl/rtl_nic.h>
+#include <net/rtl/rtk_stp.h>
+#endif
+
+#if defined (CONFIG_RTK_MESH)
+//static void br_eth_disable_timer_expired(unsigned long arg);
+static void br_eth0_monitor_timer_expired(unsigned long arg);
+//static void br_eth0_autostp_timer_expired(unsigned long arg);
+#endif	//CONFIG_RTK_MESH
+
 /* called under bridge lock */
 static int br_is_designated_for_some_port(const struct net_bridge *br)
 {
@@ -63,6 +74,10 @@
 		id->addr[3], id->addr[4], id->addr[5],
 		p->port_no, p->dev->name);
 
+#if defined(CONFIG_RTK_MESH) && defined(STP_ADDCOST_ETH)
+	br_reset_cost(p);
+#endif
+	
 	/*
 	 * According to the spec, the message age timer cannot be
 	 * running when we are the root bridge. So..  this was_root
@@ -87,15 +102,173 @@
 	struct net_bridge_port *p = (struct net_bridge_port *) arg;
 	struct net_bridge *br = p->br;
 
+#if defined (CONFIG_RTL_STP)
+	int retval=0, Port;
+	char name[IFNAMSIZ];
+	struct net_device *pseudo_dev;		
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	int retval, i;
+	uint32 vid, portMask;
+#endif
+
 	pr_debug("%s: %d(%s) forward delay timer\n",
 		 br->dev->name, p->port_no, p->dev->name);
 	spin_lock(&br->lock);
 	if (p->state == BR_STATE_LISTENING) {
 		p->state = BR_STATE_LEARNING;
+
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+		#if defined (CONFIG_RTK_MESH)
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif	
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_LEARNING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_LEARNING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#if defined (CONFIG_RTK_MESH)
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_LEARNING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_LEARNING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 		mod_timer(&p->forward_delay_timer,
 			  jiffies + br->forward_delay);
 	} else if (p->state == BR_STATE_LEARNING) {
 		p->state = BR_STATE_FORWARDING;
+#if defined (CONFIG_RTL_STP)
+	{
+		strcpy(name, p->dev->name);
+		Port=STP_PortDev_Mapping[name[strlen(name)-1]-'0'];
+
+		#if defined (CONFIG_RTK_MESH)
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port != WLAN_MESH_PSEUDO_IF_INDEX) &&(Port!=NO_MAPPING))
+		#else
+		if ((Port != WLAN_PSEUDO_IF_INDEX) && (Port!=NO_MAPPING))
+		#endif
+		{
+			retval = rtl865x_setMulticastSpanningTreePortState(Port , RTL8651_PORTSTA_FORWARDING);
+
+			retval = rtl865x_setSpanningTreePortState(Port, RTL8651_PORTSTA_FORWARDING);
+		}
+		else  if (Port == WLAN_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_FORWARDING;
+			retval = SUCCESS;
+		}
+		#if defined (CONFIG_RTK_MESH)
+		else  if (Port == WLAN_MESH_PSEUDO_IF_INDEX)
+		{
+			if ((pseudo_dev = __dev_get_by_name(&init_net,WLAN_MESH_IF_NAME)) == NULL)
+			{	
+				return;
+			}
+			pseudo_dev->br_port->state = BR_STATE_FORWARDING;
+			retval = SUCCESS;
+		}
+		#endif
+	}
+#endif
+#if defined(CONFIG_RTL_HW_STP)
+	vid=0;
+	portMask=0;
+
+	#if define(CONFIG_RTL_NETIF_MAPPING)
+	{
+		ps_drv_netif_mapping_t *entry;
+		entry = rtl_get_ps_drv_netif_mapping_by_psdev(p->dev);
+
+		retval = rtl865x_getNetifVid(entry?entry->drvName:p->dev->name,&vid);
+	}
+	#else
+	if(strcmp(p->dev->name,"eth0")==0)
+		retval=rtl865x_getNetifVid("br0", &vid);
+	else
+		retval=rtl865x_getNetifVid(p->dev->name, &vid);
+	#endif
+	
+	if(retval==FAILED){
+//		printk("%s(%d): rtl865x_getNetifVid failed.\n",__FUNCTION__,__LINE__);
+	}
+	else{
+		portMask=rtl865x_getVlanPortMask(vid);
+		for ( i = 0 ; i < MAX_RTL_STP_PORT_WH; i ++ ){
+			if((1<<i)&portMask){
+				retval = rtl865x_setMulticastSpanningTreePortState(i , RTL8651_PORTSTA_FORWARDING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setMulticastSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+				
+				retval = rtl865x_setSpanningTreePortState(i, RTL8651_PORTSTA_FORWARDING);
+				if(retval==FAILED)
+					printk("%s(%d): rtl865x_setSpanningTreePortState port(%d) failed.\n",__FUNCTION__,__LINE__,i);
+			}
+		}
+	}
+#endif
+
 		if (br_is_designated_for_some_port(br))
 			br_topology_change_detection(br);
 	}
@@ -154,7 +327,65 @@
 		      (unsigned long) br);
 
 	setup_timer(&br->gc_timer, br_fdb_cleanup, (unsigned long) br);
+
+	#if defined (CONFIG_RTK_MESH)
+	setup_timer(&br->eth0_monitor_timer,
+		      br_eth0_monitor_timer_expired,
+		      (unsigned long) br);
+	/*
+	#if defined (STP_DISABLE_ETH)
+	setup_timer(&br->eth0_autostp_timer,
+		      br_eth0_autostp_timer_expired,
+		      (unsigned long) br);
+	#endif
+	*/
+	#endif
+}
+
+#if defined (CONFIG_RTK_MESH)
+static void br_eth0_monitor_timer_expired(unsigned long arg)
+{
+	struct net_bridge *br = (struct net_bridge *) arg;
+	br->eth0_received = 0;
+	br->stp_enabled = 0;
+	br_signal_pathsel(br);
+	printk("%d seconds never receive packet from eth0 \n",MESH_PORTAL_EXPIRE);
+	return;
+	
+}
+
+#if 0
+
+#if defined (STP_DISABLE_ETH)
+static void br_eth_disable_timer_expired(unsigned long arg)
+{
+
+//Chris: stp+mesh
+	struct net_bridge_port *p = (struct net_bridge_port *) arg;
+	printk(KERN_INFO "%s: enabled for MESH-STP configuration\n", p->br->dev->name);
+	if(p->disable_by_mesh == 1)
+	{
+		br_stp_enable_port(p);
+	}
+	p->disable_by_mesh=0;
+	return;
+	
 }
+#endif
+
+static void br_eth0_autostp_timer_expired(unsigned long arg)
+{
+
+//Chris: stp+mesh
+	struct net_bridge *br = (struct net_bridge *) arg;
+	mod_timer(&br->eth0_autostp_timer, jiffies+ br->eth0_monitor_interval);
+	br->stp_enabled = 0;
+
+	return;
+}
+#endif
+
+#endif	//CONFIG_RTK_MESH
 
 void br_stp_port_timer_init(struct net_bridge_port *p)
 {
@@ -166,6 +397,13 @@
 
 	setup_timer(&p->hold_timer, br_hold_timer_expired,
 		      (unsigned long) p);
+
+	#if defined (CONFIG_RTK_MESH)
+	#if defined (STP_DISABLE_ETH)
+	setup_timer(&p->eth_disable_timer, br_eth_disable_timer_expired,
+		      (unsigned long) p);
+	#endif
+	#endif
 }
 
 /* Report ticks left (in USER_HZ) used for API */
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/Kconfig linux-2.6.30.9-rsdk/net/bridge/Kconfig
--- linux-2.6.30.9/net/bridge/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -31,3 +31,18 @@
 	  will be called bridge.
 
 	  If unsure, say N.
+config RTL_STP
+        bool "Enable RealTek STP"
+        default n
+        depends on BRIDGE
+
+config RTL_WLAN_BLOCK_RELAY
+	bool
+	default y
+	depends on BRIDGE
+
+config RTL_HW_STP
+        bool "Enable RealTek Hardware STP"
+        default n
+        depends on BRIDGE
+
diff -uNr --ignore-all-space linux-2.6.30.9/net/bridge/Makefile linux-2.6.30.9-rsdk/net/bridge/Makefile
--- linux-2.6.30.9/net/bridge/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/bridge/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -2,6 +2,10 @@
 # Makefile for the IEEE 802.1d ethernet bridging layer.
 #
 
+ifeq ($(CONFIG_MESH_ENABLE),y)
+        EXTRA_CFLAGS += -DCONFIG_RTK_MESH
+endif
+
 obj-$(CONFIG_BRIDGE) += bridge.o
 
 bridge-y	:= br.o br_device.o br_fdb.o br_forward.o br_if.o br_input.o \
@@ -10,6 +14,13 @@
 
 bridge-$(CONFIG_SYSFS) += br_sysfs_if.o br_sysfs_br.o
 
+bridge-$(CONFIG_RTL865X_LANPORT_RESTRICTION) += lan_restrict.o
+
 bridge-$(CONFIG_BRIDGE_NETFILTER) += br_netfilter.o
 
+obj-$(CONFIG_DOMAIN_NAME_QUERY_SUPPORT) += pocket_filter.o
+
 obj-$(CONFIG_BRIDGE_NF_EBTABLES) += netfilter/
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
+#EXTRA_CFLAGS += -I$(DIR_LINUX)/drivers/net/rtl819x/
diff -uNr --ignore-all-space linux-2.6.30.9/net/core/dev.c linux-2.6.30.9-rsdk/net/core/dev.c
--- linux-2.6.30.9/net/core/dev.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/core/dev.c	2011-12-05 15:50:14.000000000 +0000
@@ -127,8 +127,15 @@
 #include <linux/jhash.h>
 #include <linux/random.h>
 
+#include <net/rtl/rtl_types.h>
+#include <linux/inetdevice.h>
+
 #include "net-sysfs.h"
 
+#if	defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 /* Instead of increasing this, you should create a hash table. */
 #define MAX_GRO_SKBS 8
 
@@ -1399,6 +1406,25 @@
 }
 EXPORT_SYMBOL(__netif_schedule);
 
+#if defined(CONFIG_RTL_ETH_PRIV_SKB_DEBUG)
+extern int is_rtl865x_eth_priv_buf(unsigned char *head);
+int get_cpu_completion_queue_num(void)
+{
+	int skbCnt = 0;	
+	struct softnet_data *sd = &__get_cpu_var(softnet_data);
+	struct sk_buff *clist = sd->completion_queue;
+
+	while (clist) 
+	{
+		if(is_rtl865x_eth_priv_buf(clist->head))
+			skbCnt++;
+		clist = clist->next;			
+	}	
+
+	return skbCnt;
+}
+#endif
+
 void dev_kfree_skb_irq(struct sk_buff *skb)
 {
 	if (atomic_dec_and_test(&skb->users)) {
@@ -1677,6 +1703,10 @@
 	const struct net_device_ops *ops = dev->netdev_ops;
 	int rc;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_dev_hard_start_xmit_hooks(skb, dev, txq);
+	#endif
+
 	if (likely(!skb->next)) {
 		if (!list_empty(&ptype_all))
 			dev_queue_xmit_nit(skb, dev);
@@ -1725,7 +1755,12 @@
 	skb->destructor = DEV_GSO_CB(skb)->destructor;
 
 out_kfree_skb:
+#if CONFIG_RTL_819X
+	dev_kfree_skb_any(skb);
+#else
 	kfree_skb(skb);
+#endif
+
 	return 0;
 }
 
@@ -1805,6 +1840,10 @@
 	    __skb_linearize(skb))
 		goto out_kfree_skb;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_dev_queue_xmit_hooks(skb, dev);
+	#endif
+
 	/* Fragmented skb is linearized if device does not support SG,
 	 * or if at least one of fragments is in highmem and device
 	 * does not support DMA from it.
@@ -1846,7 +1885,14 @@
 			rc = NET_XMIT_DROP;
 		} else {
 			rc = qdisc_enqueue_root(skb, q);
+#ifdef CONFIG_NET_SCHED
+			if(gQosEnabled)
+				__netif_schedule(q);
+			else
 			qdisc_run(q);
+#else
+			qdisc_run(q);
+#endif
 		}
 		spin_unlock(root_lock);
 
@@ -1908,13 +1954,12 @@
 			Receiver routines
   =======================================================================*/
 
-int netdev_max_backlog __read_mostly = 1000;
-int netdev_budget __read_mostly = 300;
-int weight_p __read_mostly = 64;            /* old backlog weight */
+int netdev_max_backlog __read_mostly = 512;	//1000;
+int netdev_budget __read_mostly = 128;	//300;
+int weight_p __read_mostly = 128;		//64;            /* old backlog weight */
 
 DEFINE_PER_CPU(struct netif_rx_stats, netdev_rx_stat) = { 0, };
 
-
 /**
  *	netif_rx	-	post buffer to the network code
  *	@skb: buffer to post
@@ -1942,6 +1987,7 @@
 	if (!skb->tstamp.tv64)
 		net_timestamp(skb);
 
+	
 	/*
 	 * The code is rearranged so that the path is the most
 	 * short when CPU is congested, but is still operating.
@@ -2199,6 +2245,9 @@
 	rcu_read_unlock();
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int rtl865x_ipMulticastFastFwd(struct sk_buff * skb);
+#endif
 /**
  *	netif_receive_skb - process receive buffer from network
  *	@skb: buffer to process
@@ -2222,6 +2271,25 @@
 	int ret = NET_RX_DROP;
 	__be16 type;
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(rtl865x_localPublicRx(skb)==NET_RX_DROP)
+	{
+		return NET_RX_DROP;
+	}
+#endif
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+	if(rtl865x_ipMulticastFastFwd(skb)==0)
+	{
+		return NET_RX_SUCCESS;
+	}
+#endif
+
+	#if	defined(CONFIG_RTL_819X)
+	if (rtl_netif_receive_skb_hooks(&skb)==RTL_PS_HOOKS_RETURN)
+		return NET_RX_SUCCESS;
+	#endif
+
 	if (skb->vlan_tci && vlan_hwaccel_do_receive(skb))
 		return NET_RX_SUCCESS;
 
@@ -4786,6 +4854,9 @@
 
 	dev->gso_max_size = GSO_MAX_SIZE;
 
+	if (sizeof_priv)
+		dev->priv = netdev_priv(dev);
+
 	netdev_init_queues(dev);
 
 	INIT_LIST_HEAD(&dev->napi_list);
@@ -5219,6 +5290,10 @@
 {
 	int i, rc = -ENOMEM;
 
+	netdev_max_backlog = 512;	//1000;
+	netdev_budget = 128;	//300;
+	weight_p = 128;		//64;            /* old backlog weight */
+	
 	BUG_ON(!dev_boot_phase);
 
 	if (dev_proc_init())
diff -uNr --ignore-all-space linux-2.6.30.9/net/core/dst.c linux-2.6.30.9-rsdk/net/core/dst.c
--- linux-2.6.30.9/net/core/dst.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/core/dst.c	2011-12-05 15:50:14.000000000 +0000
@@ -20,6 +20,8 @@
 
 #include <net/dst.h>
 
+#include <net/rtl/features/rtl_ps_hooks.h>
+
 /*
  * Theory of operations:
  * 1) We use a list, protected by a spinlock, to add
@@ -40,16 +42,18 @@
  * to dirty as few cache lines as possible in __dst_free().
  * As this is not a very strong hint, we dont force an alignment on SMP.
  */
-static struct {
+/*struct dst_gc{
 	spinlock_t		lock;
 	struct dst_entry 	*list;
 	unsigned long		timer_inc;
 	unsigned long		timer_expires;
-} dst_garbage = {
+};
+*/
+struct dst_gc dst_garbage = {
 	.lock = __SPIN_LOCK_UNLOCKED(dst_garbage.lock),
 	.timer_inc = DST_GC_MAX,
 };
-static void dst_gc_task(struct work_struct *work);
+void dst_gc_task(struct work_struct *work);
 static void ___dst_free(struct dst_entry * dst);
 
 static DECLARE_DELAYED_WORK(dst_gc_work, dst_gc_task);
@@ -60,7 +64,7 @@
  */
 static struct dst_entry         *dst_busy_list;
 
-static void dst_gc_task(struct work_struct *work)
+void dst_gc_task(struct work_struct *work)
 {
 	int    delayed = 0;
 	int    work_performed = 0;
@@ -152,7 +156,34 @@
 		elapsed.tv_sec * USEC_PER_SEC + elapsed.tv_nsec / NSEC_PER_USEC);
 #endif
 }
+#if 0
+int hyking_print_busy_list(void)
+{
+	struct dst_entry *dst, *next;
+	struct rtable *rth;
+	int busy_cnt = 0;
+	
+	mutex_lock(&dst_gc_mutex);
+	next = dst_busy_list;
+
+	printk("busy_list entry info:\n");
+	while ((dst = next) != NULL) 
+	{
+		next = dst->next;
+		prefetch(&next->next);
+
+		busy_cnt++;		
+		rth = (struct rtable*)dst;
+		printk("sip(%u.%u.%u.%u),dip(%u.%u.%u.%u),rt_genid(%d),dst->ops(0x%x),dst->hy1(0x%x),dst->refcnt(%d)\n",NIPQUAD(rth->rt_src),NIPQUAD(rth->rt_dst),rth->rt_genid,
+				rth->u.dst.ops,rth->u.dst.hyking_test1,atomic_read(&rth->u.dst.__refcnt));		
+	}
+	mutex_unlock(&dst_gc_mutex);
+	
+	printk("=====%s(%d), busy_cnt(%d)\n",__FUNCTION__,__LINE__,busy_cnt);
 
+	return 0;
+}
+#endif
 int dst_discard(struct sk_buff *skb)
 {
 	kfree_skb(skb);
@@ -160,17 +191,32 @@
 }
 EXPORT_SYMBOL(dst_discard);
 
+extern int ip_rt_max_size;
 void * dst_alloc(struct dst_ops * ops)
 {
 	struct dst_entry * dst;
 
 	if (ops->gc && atomic_read(&ops->entries) > ops->gc_thresh) {
-		if (ops->gc(ops))
+
+		if(rtl_dst_alloc_gc_pre_check_hooks(ops) == RTL_PS_HOOKS_RETURN)
+			return NULL;
+		
+		if (ops->gc(ops)){
+			rtl_dst_alloc_gc_post_check1_hooks(ops);
+			
 			return NULL;
 	}
+	}
+
+//hyking:so .....	
+	if(atomic_read(&ops->entries) > ip_rt_max_size){
+		return NULL;
+	}
+	
 	dst = kmem_cache_zalloc(ops->kmem_cachep, GFP_ATOMIC);
-	if (!dst)
+	if (!dst){
 		return NULL;
+	}
 	atomic_set(&dst->__refcnt, 0);
 	dst->ops = ops;
 	dst->lastuse = jiffies;
@@ -180,6 +226,8 @@
 	atomic_inc(&dst_total);
 #endif
 	atomic_inc(&ops->entries);
+
+	rtl_dst_alloc_gc_post_check2_hooks(ops, dst);
 	return dst;
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/net/core/Makefile linux-2.6.30.9-rsdk/net/core/Makefile
--- linux-2.6.30.9/net/core/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/core/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -20,3 +20,7 @@
 obj-$(CONFIG_TRACEPOINTS) += net-traces.o
 obj-$(CONFIG_NET_DROP_MONITOR) += drop_monitor.o
 
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x/
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/wireless/rtl8190/
+
diff -uNr --ignore-all-space linux-2.6.30.9/net/core/neighbour.c linux-2.6.30.9-rsdk/net/core/neighbour.c
--- linux-2.6.30.9/net/core/neighbour.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/core/neighbour.c	2011-12-05 15:50:14.000000000 +0000
@@ -36,6 +36,21 @@
 #include <linux/string.h>
 #include <linux/log2.h>
 
+#include <net/rtl/rtl_types.h>
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+#include <net/rtl/rtl865x_ppp.h>
+#include <net/rtl/rtl865x_route_api.h>
+#include <net/rtl/rtl865x_arp_api.h>
+#endif
+
+#if defined(CONFIG_RTL_MULTIPLE_WAN)
+#include <net/arp.h>
+#endif
+
+#if defined (CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 #define NEIGH_DEBUG 1
 
 #define NEIGH_PRINTK(x...) printk(x)
@@ -126,6 +141,8 @@
 EXPORT_SYMBOL(neigh_rand_reach_time);
 
 
+
+
 static int neigh_forced_gc(struct neigh_table *tbl)
 {
 	int shrunk = 0;
@@ -149,6 +166,11 @@
 				*np	= n->next;
 				n->dead = 1;
 				shrunk	= 1;
+				#if defined(CONFIG_RTL_819X)
+				/*delete asic arp entry*/
+				rtl_neigh_forced_gc_hooks(tbl, n);
+				#endif
+				
 				write_unlock(&n->lock);
 				neigh_cleanup_and_release(n);
 				continue;
@@ -222,10 +244,16 @@
 				   we must kill timers etc. and move
 				   it to safe state.
 				 */
+				#if defined(CONFIG_RTL_819X)
+				/*delete asic arp entry*/
+				rtl_neigh_flush_dev_hooks(tbl, dev, n);
+				#endif
 				skb_queue_purge(&n->arp_queue);
 				n->output = neigh_blackhole;
 				if (n->nud_state & NUD_VALID)
+				{
 					n->nud_state = NUD_NOARP;
+				}	
 				else
 					n->nud_state = NUD_NONE;
 				NEIGH_PRINTK2("neigh %p is stray.\n", n);
@@ -623,6 +651,11 @@
 {
 	struct hh_cache *hh;
 
+	#if defined(CONFIG_RTL_819X)
+	/*delete asic arp entry*/
+	rtl_neigh_destroy_hooks(neigh);
+	#endif
+
 	NEIGH_CACHE_STAT_INC(neigh->tbl, destroys);
 
 	if (!neigh->dead) {
@@ -685,6 +718,9 @@
 	struct hh_cache *hh;
 
 	NEIGH_PRINTK2("neigh %p is connected.\n", neigh);
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_connect_hooks(neigh);
+	#endif
 
 	neigh->output = neigh->ops->connected_output;
 
@@ -736,6 +772,19 @@
 		     time_after(now, n->used + n->parms->gc_staletime))) {
 			*np = n->next;
 			n->dead = 1;
+			#if defined(CONFIG_RTL_819X)
+			if (RTL_PS_HOOKS_BREAK==rtl_neigh_periodic_timer_hooks(n, 0)) {
+				write_unlock(&n->lock);
+				continue;
+			}
+
+			#if 0
+			printk("%s:%d: ip:%u.%u.%u.%u, mac:%x:%x:%x:%x:%x:%x,n->nud_state is 0x%x,tval is %d\n", 
+			__FUNCTION__,__LINE__,NIPQUAD(htonl(*((u32 *)n->primary_key))), n->ha[0], n->ha[1], 
+			n->ha[2], n->ha[3], n->ha[4], n->ha[5],n->nud_state,tval);
+			#endif
+			#endif
+
 			write_unlock(&n->lock);
 			neigh_cleanup_and_release(n);
 			continue;
@@ -793,6 +842,11 @@
 		goto out;
 	}
 
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_timer_handler_pre_update_hooks(neigh, state);
+	#endif
+
 	if (state & NUD_REACHABLE) {
 		if (time_before_eq(now,
 				   neigh->confirmed + neigh->parms->reachable_time)) {
@@ -833,10 +887,13 @@
 		next = now + neigh->parms->retrans_time;
 	}
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_timer_handler_during_update_hooks(neigh, state);
+	#endif
+	
 	if ((neigh->nud_state & (NUD_INCOMPLETE | NUD_PROBE)) &&
 	    atomic_read(&neigh->probes) >= neigh_max_probes(neigh)) {
 		struct sk_buff *skb;
-
 		neigh->nud_state = NUD_FAILED;
 		neigh->updated = jiffies;
 		notify = 1;
@@ -880,6 +937,10 @@
 	if (notify)
 		neigh_update_notify(neigh);
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_timer_handler_post_update_hooks(neigh, state);
+	#endif
+
 	neigh_release(neigh);
 }
 
@@ -896,6 +957,10 @@
 
 	now = jiffies;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl___neigh_event_send_pre_hooks(neigh, skb);
+	#endif
+
 	if (!(neigh->nud_state & (NUD_STALE | NUD_INCOMPLETE))) {
 		if (neigh->parms->mcast_probes + neigh->parms->app_probes) {
 			atomic_set(&neigh->probes, neigh->parms->ucast_probes);
@@ -918,6 +983,10 @@
 				jiffies + neigh->parms->delay_probe_time);
 	}
 
+	#if defined(CONFIG_RTL_819X)
+	rtl___neigh_event_send_post_hooks(neigh, skb);
+	#endif
+
 	if (neigh->nud_state == NUD_INCOMPLETE) {
 		if (skb) {
 			if (skb_queue_len(&neigh->arp_queue) >=
@@ -1067,10 +1136,17 @@
 	if (lladdr != neigh->ha) {
 		memcpy(&neigh->ha, lladdr, dev->addr_len);
 		neigh_update_hhs(neigh);
+
 		if (!(new & NUD_CONNECTED))
 			neigh->confirmed = jiffies -
 				      (neigh->parms->base_reachable_time << 1);
 		notify = 1;
+
+		#if defined(CONFIG_RTL_819X)
+		/*careful:should put these code after "memcpy(&neigh->ha, lladdr, dev->addr_len);"*/
+		/*different mac address, and add new arp mapping entry*/
+		rtl_neigh_update_hooks(neigh, lladdr, old);
+		#endif
 	}
 	if (new == old)
 		goto out;
@@ -1101,6 +1177,13 @@
 			(neigh->flags | NTF_ROUTER) :
 			(neigh->flags & ~NTF_ROUTER);
 	}
+
+	#if defined(CONFIG_RTL_819X)
+	/*careful:should put these code after "memcpy(&neigh->ha, lladdr, dev->addr_len);"*/
+	/*different mac address, and add new arp mapping entry*/
+	rtl_neigh_update_post_hooks(neigh, lladdr, old);
+	#endif
+	
 	write_unlock_bh(&neigh->lock);
 
 	if (notify)
@@ -2820,6 +2903,10 @@
 	rtnl_register(PF_UNSPEC, RTM_GETNEIGHTBL, NULL, neightbl_dump_info);
 	rtnl_register(PF_UNSPEC, RTM_SETNEIGHTBL, neightbl_set, NULL);
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_neigh_init_hooks();
+	#endif
+	
 	return 0;
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/net/core/skbuff.c linux-2.6.30.9-rsdk/net/core/skbuff.c
--- linux-2.6.30.9/net/core/skbuff.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/core/skbuff.c	2011-12-05 15:50:14.000000000 +0000
@@ -68,6 +68,14 @@
 #include <trace/skb.h>
 
 #include "kmap_skb.h"
+#if defined(CONFIG_RTL_ETH_PRIV_SKB)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl_nic.h>
+#endif
+#ifdef CONFIG_RTL8190_PRIV_SKB
+extern int is_rtl8190_priv_buf(unsigned char *head);
+extern void free_rtl8190_priv_buf(unsigned char *head);
+#endif
 
 static struct kmem_cache *skbuff_head_cache __read_mostly;
 static struct kmem_cache *skbuff_fclone_cache __read_mostly;
@@ -183,7 +191,12 @@
 	if (!skb)
 		goto out;
 
+#if defined(CONFIG_RTL_819X) || defined(CONFIG_RTL8192CD) || defined(CONFIG_RTL8190) || defined(CONFIG_RTL8192SE)
+	size = SKB_DATA_ALIGN(size+RTL_PRIV_DATA_SIZE);
+#else
 	size = SKB_DATA_ALIGN(size);
+#endif
+
 	data = kmalloc_node_track_caller(size + sizeof(struct skb_shared_info),
 			gfp_mask, node);
 	if (!data)
@@ -201,6 +214,33 @@
 	skb->data = data;
 	skb_reset_tail_pointer(skb);
 	skb->end = skb->tail + size;
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	skb->srcPort=0xFFFF;
+	skb->srcVlanId=0;
+#endif
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	skb->srcVlanPriority=0;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+	skb->srcPhyPort=0xFF;
+	skb->dstPhyPort=0xFF;
+#endif
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	skb->tag.v = 0;
+#endif	
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	skb->srcLocalPublicIp=0;
+	skb->fromLocalPublic=0;
+	skb->toLocalPublic=0;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	skb->inDev=NULL;
+#endif
+
 	/* make sure we initialize shinfo sequentially */
 	shinfo = skb_shinfo(skb);
 	atomic_set(&shinfo->dataref, 1);
@@ -231,6 +271,87 @@
 }
 EXPORT_SYMBOL(__alloc_skb);
 
+#if defined(CONFIG_RTL8190_PRIV_SKB) || defined(CONFIG_RTL_ETH_PRIV_SKB)
+struct sk_buff *dev_alloc_8190_skb(unsigned char *data, int size)
+{
+        struct sk_buff *skb;
+	struct skb_shared_info *shinfo;
+
+ 	struct kmem_cache *cache;
+ 	cache = skbuff_head_cache;
+	/* Get the HEAD */
+        skb = kmem_cache_alloc(cache, GFP_ATOMIC & ~__GFP_DMA);
+        if (!skb)
+                goto out;
+
+        memset(skb, 0, offsetof(struct sk_buff, truesize));
+        atomic_set(&skb->users, 1);
+        skb->head = data;
+        skb->data = data;
+        skb->tail = data;
+
+	size = SKB_DATA_ALIGN(size+RTL_PRIV_DATA_SIZE+NET_SKB_PAD);
+
+        skb->end  = data + size;
+        skb->truesize = size + sizeof(struct sk_buff);
+
+        /* make sure we initialize shinfo sequentially */
+        shinfo = skb_shinfo(skb);
+        atomic_set(&shinfo->dataref, 1);
+        shinfo->nr_frags  = 0;
+        shinfo->gso_size = 0;
+        shinfo->gso_segs = 0;
+        shinfo->gso_type = 0;
+        shinfo->ip6_frag_id = 0;
+        shinfo->frag_list = NULL;
+ 
+#ifdef CONFIG_RTK_VOIP_VLAN_ID
+        skb->rx_vlan = 0;
+        skb->rx_wlan = 0;
+        skb->priority = 0;
+#endif
+
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	skb->srcPort=0xFFFF;
+	skb->srcVlanId=0;
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	skb->srcVlanPriority=0;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+	skb->srcPhyPort=0xFF;
+	skb->dstPhyPort=0xFF;
+#endif
+
+#if defined(CONFIG_RTK_VLAN_SUPPORT)
+	skb->tag.v = 0;
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	skb->srcLocalPublicIp=0;
+	skb->fromLocalPublic=0;
+	skb->toLocalPublic=0;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	skb->inDev=NULL;
+#endif
+
+#ifdef CONFIG_RTK_VOIP_VLAN_ID
+	skb_reserve(skb, RTL_PRIV_DATA_SIZE+4); // for VLAN TAG insertion
+#else
+	skb_reserve(skb, RTL_PRIV_DATA_SIZE);
+#endif
+
+        return skb;
+ 
+out:
+        return NULL;
+}
+#endif // CONFIG_RTL8190_PRIV_SKB
+
 /**
  *	__netdev_alloc_skb - allocate an skbuff for rx on a specific device
  *	@dev: network device to receive on
@@ -341,9 +462,24 @@
 		if (skb_shinfo(skb)->frag_list)
 			skb_drop_fraglist(skb);
 
+#if defined(CONFIG_RTL_ETH_PRIV_SKB)
+		if (is_rtl865x_eth_priv_buf(skb->head)) {
+			free_rtl865x_eth_priv_buf(skb->head);
+		}            
+		else
+#endif
+#ifdef CONFIG_RTL8190_PRIV_SKB
+		if (is_rtl8190_priv_buf(skb->head))
+		{
+			free_rtl8190_priv_buf(skb->head);
+		}
+		else
+#endif
+		{
 		kfree(skb->head);
 	}
 }
+}
 
 /*
  *	Free an skbuff by memory without cleaning the state.
@@ -543,6 +679,25 @@
     defined(CONFIG_NETFILTER_XT_TARGET_TRACE_MODULE)
 	new->nf_trace		= old->nf_trace;
 #endif
+
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	new->srcPort=old->srcPort;
+	new->srcVlanId=old->srcPort;
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	new->srcVlanPriority=old->srcVlanPriority;
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+	new->srcPhyPort=old->srcPhyPort;
+	new->dstPhyPort=old->dstPhyPort;
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	new->inDev=old->inDev;
+#endif
+
 #ifdef CONFIG_NET_SCHED
 	new->tc_index		= old->tc_index;
 #ifdef CONFIG_NET_CLS_ACT
@@ -575,6 +730,25 @@
 	C(head);
 	C(data);
 	C(truesize);
+
+#ifdef CONFIG_RTL_HARDWARE_MULTICAST
+	C(srcPort);
+	C(srcVlanId);
+#endif
+
+#if	defined(CONFIG_RTL_QOS_8021P_SUPPORT)
+	C(srcVlanPriority);
+#endif
+
+#if defined(CONFIG_NETFILTER_XT_MATCH_PHYPORT) || defined(CONFIG_RTL_FAST_FILTER) || defined(CONFIG_RTL_QOS_PATCH)
+	C(srcPhyPort);
+	C(dstPhyPort);
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	C(inDev);
+#endif
+
 #if defined(CONFIG_MAC80211) || defined(CONFIG_MAC80211_MODULE)
 	C(do_not_encrypt);
 	C(requeue);
@@ -636,11 +810,25 @@
 		n->fclone = SKB_FCLONE_UNAVAILABLE;
 	}
 
+//#define C(x) n->x = skb->x
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	//C(tag.v);
+	n->tag.v = skb->tag.v;
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	n->srcLocalPublicIp = skb->srcLocalPublicIp;
+	n->fromLocalPublic = skb->fromLocalPublic;
+	n->toLocalPublic = skb->toLocalPublic;
+#endif
 	return __skb_clone(n, skb);
 }
 EXPORT_SYMBOL(skb_clone);
 
+#if defined(CONFIG_RTL_ETH_PRIV_SKB) || defined(CONFIG_NET_WIRELESS_AGN) || defined(CONFIG_NET_WIRELESS_AG) || defined(CONFIG_WIRELESS)
+void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
+#else
 static void copy_skb_header(struct sk_buff *new, const struct sk_buff *old)
+#endif
 {
 #ifndef NET_SKBUFF_DATA_USES_OFFSET
 	/*
@@ -657,6 +845,14 @@
 	new->network_header   += offset;
 	new->mac_header	      += offset;
 #endif
+#ifdef CONFIG_RTK_VLAN_SUPPORT	
+	new->tag.v = old->tag.v;
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	new->srcLocalPublicIp=old->srcLocalPublicIp;
+	new->fromLocalPublic=old->fromLocalPublic;
+	new->toLocalPublic=old->toLocalPublic;
+#endif
 	skb_shinfo(new)->gso_size = skb_shinfo(old)->gso_size;
 	skb_shinfo(new)->gso_segs = skb_shinfo(old)->gso_segs;
 	skb_shinfo(new)->gso_type = skb_shinfo(old)->gso_type;
diff -uNr --ignore-all-space linux-2.6.30.9/net/ethernet/eth.c linux-2.6.30.9-rsdk/net/ethernet/eth.c
--- linux-2.6.30.9/net/ethernet/eth.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ethernet/eth.c	2011-12-05 15:50:14.000000000 +0000
@@ -346,7 +346,11 @@
 	dev->hard_header_len 	= ETH_HLEN;
 	dev->mtu		= ETH_DATA_LEN;
 	dev->addr_len		= ETH_ALEN;
+#if defined(CONFIG_RTL_819X)
+	dev->tx_queue_len	= 0;	/* reduce queue size for max free sdram	*/
+#else
 	dev->tx_queue_len	= 1000;	/* Ethernet wants good queues */
+#endif
 	dev->flags		= IFF_BROADCAST|IFF_MULTICAST;
 
 	memset(dev->broadcast, 0xFF, ETH_ALEN);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/arp.c linux-2.6.30.9-rsdk/net/ipv4/arp.c
--- linux-2.6.30.9/net/ipv4/arp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/arp.c	2011-12-05 15:50:14.000000000 +0000
@@ -121,6 +121,51 @@
 
 #include <linux/netfilter_arp.h>
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_localPublic.h>
+#endif
+
+#if defined(CONFIG_RTL8186_KB)
+#define	CACHE_GRATUITOUS_PERIOD		4
+#define	CACHE_MAC_LEN					6
+static unsigned long cache_gratuitous_jiffies = 0;
+static int	cache_gratuitous_cnt = 0;
+static __be32	cache_gratuitous_ip = 0;
+static u8 cache_gratuitous_mac[CACHE_MAC_LEN] = {0};
+static u8 cache_gratuitous_mac_peer[CACHE_MAC_LEN] = {0};
+static struct timer_list 	gratuitous_timer;
+
+static void rtl865x_recover_wired_led(unsigned long arg)
+{
+	rtl865x_wireCompSolidBlue();
+	cache_gratuitous_ip = 0;
+	cache_gratuitous_cnt = 0;
+	cache_gratuitous_jiffies = 0;
+	del_timer_sync(&gratuitous_timer);
+}
+
+static void rtl865x_check_ip_collision(unsigned long arg)
+{
+	if (time_after(jiffies, cache_gratuitous_jiffies+CACHE_GRATUITOUS_PERIOD*HZ))
+	{
+		if (cache_gratuitous_cnt<3)
+		{
+			rtl865x_wireCompBlinkAmber();
+			del_timer_sync(&gratuitous_timer);
+			init_timer(&gratuitous_timer);
+			gratuitous_timer.function = rtl865x_recover_wired_led;
+			gratuitous_timer.expires = jiffies + (HZ<<7);
+			add_timer(&gratuitous_timer);
+		}
+	}
+	else
+	{
+		mod_timer(&gratuitous_timer, jiffies + (HZ));
+	}
+}
+#endif
 /*
  *	Interface to generic neighbour cache.
  */
@@ -130,6 +175,11 @@
 static void arp_error_report(struct neighbour *neigh, struct sk_buff *skb);
 static void parp_redo(struct sk_buff *skb);
 
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	#include <net/rtl/rtk_vlan.h>
+	static struct vlan_tag arp_tag;
+#endif
+
 static struct neigh_ops arp_generic_ops = {
 	.family =		AF_INET,
 	.solicit =		arp_solicit,
@@ -374,8 +424,17 @@
 		return;
 	}
 
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	if (skb)
+		arp_tag = skb->tag;
+#endif
 	arp_send(ARPOP_REQUEST, ETH_P_ARP, target, dev, saddr,
 		 dst_ha, dev->dev_addr, NULL);
+
+#ifdef CONFIG_RTK_VLAN_SUPPORT 
+	arp_tag.v = 0;
+#endif		 
+
 	if (dst_ha)
 		read_unlock_bh(&neigh->lock);
 }
@@ -578,6 +637,10 @@
 	arp = (struct arphdr *) skb_put(skb, arp_hdr_len(dev));
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_ARP);
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	skb->tag = arp_tag;
+#endif	
+
 	if (src_hw == NULL)
 		src_hw = dev->dev_addr;
 	if (dest_hw == NULL)
@@ -691,11 +754,98 @@
 
 	arp_xmit(skb);
 }
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+struct timer_list lpArpProxyTimer;
+#define LOACL_PUBLIC_PROBE_PERIOD (30*HZ)
+
+static void rtl865x_lpArpProxyHandler(unsigned long arg)
+{
+	int i,j;
+	int lpCnt=0;
+	int dupGw=0;
+	struct rtl865x_localPublic lpArray[MAX_LOCAL_PUBLIC_NUM];
+	struct net_device * lanDev=NULL;
+	struct net_device * wanDev=NULL;
+	unsigned int lanIpAddr, lanNetMask;
+	unsigned char zeroMac[6]={0,0,0,0,0,0};
+
+	if(rtl865x_localPublicEnabled()==0)
+	{
+		goto end_of_handler;
+	}
+	
+	lanDev=rtl865x_getLanDev();
+	wanDev=rtl865x_getWanDev();
+	lpCnt=rtl865x_getAllLocalPublic(lpArray, MAX_LOCAL_PUBLIC_NUM);
+	if(lanDev!=NULL)
+	{
+		rtl865x_getDevIpAndNetmask(lanDev, &lanIpAddr, &lanNetMask);
+	
+		for(i=0; i<lpCnt; i++)
+		{
+			if(memcmp(lpArray[i].mac, zeroMac, 6)==0)
+			{
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, lpArray[i].ipAddr, lanDev, lanIpAddr, NULL, lanDev->dev_addr, NULL);
+			}
+		}
+	}
+
+	if(wanDev!=NULL)
+	{
+		for(i=0; i<lpCnt; i++)
+		{
+			if(lpArray[i].hw==0)
+			{
+				continue;
+			}
+			
+			dupGw=0;
+			for(j=0; j<i; j++)
+			{
+				/*hardware local public need to get default gateway mac  for route redirection*/
+				if((lpArray[j].hw == lpArray[i].hw) && (lpArray[j].defGateway==lpArray[i].defGateway))
+				{
+					dupGw=1;
+					break;
+				}
+				
+			}
+
+			if(dupGw==0)
+			{
+				arp_send(ARPOP_REQUEST, ETH_P_ARP, lpArray[i].defGateway, wanDev, 0, NULL, wanDev->dev_addr, NULL);
+			}
+		}
+	}
+
+	if(lanDev)
+		dev_put(lanDev);
+
+	if(wanDev)
+		dev_put(wanDev);
+	
+end_of_handler:	
+	mod_timer(&lpArpProxyTimer, jiffies +LOACL_PUBLIC_PROBE_PERIOD);
+}
+
+void rtl865x_lpArpProxyInit(void)
+{
+	init_timer(&lpArpProxyTimer);
+	lpArpProxyTimer.function = rtl865x_lpArpProxyHandler;
+	lpArpProxyTimer.data	  = (unsigned long)(&lpArpProxyTimer);
+	lpArpProxyTimer.expires = jiffies +LOACL_PUBLIC_PROBE_PERIOD;
+	add_timer(&lpArpProxyTimer);
+	return;
+}
+
+#endif
 
 /*
  *	Process an arp request.
  */
-
+#if defined(CONFIG_RTL_LOCAL_PUBLIC)
+extern int rtl865x_checkMacAddrLocation(unsigned char *addr, unsigned int *isElanMac, unsigned int *isWlanMac);
+#endif
 static int arp_process(struct sk_buff *skb)
 {
 	struct net_device *dev = skb->dev;
@@ -708,8 +858,34 @@
 	u16 dev_type = dev->type;
 	int addr_type;
 	struct neighbour *n;
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	struct neighbour *dst_n;
+#endif
 	struct net *net = dev_net(dev);
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	unsigned int rxFromLan=0;
+	unsigned int rxFromWan=0;
+	unsigned char fromLocalPublic;
+	unsigned char toLocalPublic;
+	unsigned char localPublicMac[6];
+	
+	struct rtl865x_localPublic srcLocalPubicInfo;
+	struct rtl865x_localPublic dstLocalPublicInfo;
+	struct net_device * wanDev=NULL;
+	struct net_device * lanDev=NULL;
+	unsigned int lanIpAddr, lanNetMask;
+	unsigned int wanIpAddr, wanNetMask;
+	unsigned char zeroMac[6]={0,0,0,0,0,0};
+	unsigned int srcIsElanMac=0;
+	unsigned int srcIsWlanMac=0;
+	int ret;
+	//unsigned int curPolicy ;
+	//char defInAclStart;
+	//char defInAclEnd;
+	//char defOutAclStart;
+	//char defOutAclEnd;
+#endif
 	/* arp_rcv below verifies the ARP header and verifies the device
 	 * is ARP'able.
 	 */
@@ -756,7 +932,15 @@
 	}
 
 	/* Understand only these message types */
-
+#ifdef CONFIG_RTK_INBAND_HOST_HACK
+//reject arp request for AP
+extern int br_hackMac_enable;
+	if(br_hackMac_enable)	
+	{
+        if(arp->ar_op == htons(ARPOP_REQUEST))
+                goto out;
+	}
+#endif
 	if (arp->ar_op != htons(ARPOP_REPLY) &&
 	    arp->ar_op != htons(ARPOP_REQUEST))
 		goto out;
@@ -800,6 +984,10 @@
  *  and in the case of requests for us we add the requester to the arp
  *  cache.
  */
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	if (skb)
+		arp_tag = skb->tag;
+#endif		    
 
 	/* Special case: IPv4 duplicate address detection packet (RFC2131) */
 	if (sip == 0) {
@@ -811,6 +999,351 @@
 		goto out;
 	}
 
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(rtl865x_localPublicEnabled()==0)
+	{
+		goto	common_arp_process;
+	}
+	
+	if(arp->ar_op == htons(ARPOP_REQUEST))
+	{
+		if(sip==tip)
+		{
+			/*gratuitous arp*/
+			goto common_arp_process;
+		}
+		
+		fromLocalPublic=rtl865x_isLocalPublicIp(sip);
+		toLocalPublic=rtl865x_isLocalPublicIp(tip);
+		rtl865x_attainDevType(dev->name, &rxFromLan, &rxFromWan);
+		
+ 		//rtl865x_getNetDecisionPolicy(&curPolicy);
+		//rtl865x_getDefACLForNetDecisionMiss(&defInAclStart, &defInAclEnd,&defOutAclStart,&defOutAclEnd);
+		ret=rtl865x_checkMacAddrLocation(sha, &srcIsElanMac, &srcIsWlanMac);
+		//printk("%s:%d,dev->name is %s,rxFromLan is %d, rxFromWan is %d\n",__FUNCTION__,__LINE__,dev->name,rxFromLan,rxFromWan);
+		//printk("%s:%d,fromLocalPublic is %d,toLocalPublic is %d\n",__FUNCTION__,__LINE__,fromLocalPublic, toLocalPublic);
+
+		if(rxFromLan)
+		{
+			lanDev=rtl865x_getLanDev();
+			rtl865x_getDevIpAndNetmask(lanDev, &lanIpAddr, &lanNetMask);
+			wanDev=rtl865x_getWanDev();
+			rtl865x_getDevIpAndNetmask(wanDev,&wanIpAddr,&wanNetMask);
+			
+			if(fromLocalPublic && (!toLocalPublic))
+			{
+				//printk("%s:%d,sip is 0x%x,tip is 0x%x\n",__FUNCTION__,__LINE__,sip,tip);
+				ret=rtl865x_getLocalPublicInfo(sip, &srcLocalPubicInfo);
+				if(ret!=0)
+				{
+					goto common_arp_process;
+				}
+			
+				/*send out this arp request to wan*/
+				if((sip & srcLocalPubicInfo.netMask) == (tip & srcLocalPubicInfo.netMask))
+				{							
+					if(wanDev)
+					{
+						//printk("%s:%d,lanIpAddr is %d.%d.%d.%d, lanNetMask is %d.%d.%d.%d\n",__FUNCTION__,__LINE__,NIPQUAD(lanIpAddr),NIPQUAD(lanNetMask));
+						if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
+						{
+							/*target is not at lan*/
+							//arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, sip, NULL, sha, NULL);
+							if((tip & wanNetMask) == (wanIpAddr & wanNetMask))
+							{
+								dst_n = __neigh_lookup(&arp_tbl,&tip,wanDev,1);
+								arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, wanIpAddr, NULL, wanDev->dev_addr, NULL);
+								if(dst_n)
+									neigh_release(dst_n);
+							}
+							else
+							{
+								dst_n = __neigh_lookup(&arp_tbl,&srcLocalPubicInfo.defGateway,wanDev,1);
+								arp_send(ARPOP_REQUEST, ETH_P_ARP, srcLocalPubicInfo.defGateway, wanDev, wanIpAddr, NULL, wanDev->dev_addr, NULL);
+								if(dst_n)
+									neigh_release(dst_n);
+							}
+						}
+						#if 0
+						else if((tip & srcLocalPubicInfo.netMask) == (sip & srcLocalPubicInfo.netMask))
+						{
+							/*target in the same subnet as local public, but not local public*/
+							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, sip, NULL, sha, NULL);
+						}
+						else if ((tip & srcLocalPubicInfo.netMask) != (sip & srcLocalPubicInfo.netMask))
+						{
+							/*impossible: local public should not send this arp request, instead, it should ask its default gateway arp*/
+							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, wanDev, sip, NULL, sha, NULL);
+						}
+						else
+						{
+							/*ignore it*/
+						}
+						#endif
+						else
+						{
+							//target in lan
+							arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, lanDev, lanIpAddr, NULL, lanDev->dev_addr, NULL);
+						}
+						
+					}
+				}
+				
+				
+				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
+				#if 0
+				if(tip==srcLocalPubicInfo.defGateway)
+				{
+					/*target is local public's default gateway*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
+				{
+					/*target is not at lan*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}				
+				else if((tip & srcLocalPubicInfo.netMask) == (sip & srcLocalPubicInfo.netMask))
+				{
+					/*target in the same subnet as local public, include  default gw, but not local public*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else if ((tip & srcLocalPubicInfo.netMask) != (sip & srcLocalPubicInfo.netMask))
+				{
+					/*impossible: local public should not send this arp request, it should ask its default gateway arp*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				#endif
+				#if 1
+				//software local public
+				if(srcLocalPubicInfo.hw == 0)
+				{					
+					if((tip & lanNetMask) != (lanIpAddr & lanNetMask))
+					{
+						if(tip==wanIpAddr)
+						{
+							/*patch sw local public ping gateway wan ip fail when sw local public and gateway wan at the same subnet*/
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+						}
+						else
+						{
+							if((tip & wanNetMask) == (wanIpAddr & wanNetMask))
+							{
+								if((wanDev!=NULL)&&(dst_n=neigh_lookup(&arp_tbl,&tip,wanDev))!=NULL)
+								{
+									if(memcmp(dst_n->ha,zeroMac,6) != 0)
+									{
+										arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+									}
+									neigh_release(dst_n);
+								}
+					}
+					else
+					{
+								if((wanDev!=NULL)&&(dst_n=neigh_lookup(&arp_tbl,&srcLocalPubicInfo.defGateway,wanDev))!=NULL)
+							{
+								if(memcmp(dst_n->ha,zeroMac,6) != 0)
+								{
+									arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+								}
+								neigh_release(dst_n);
+							}
+						}
+					}
+					}
+					else
+					{
+						//target in lan
+						if((lanDev!=NULL)&&(dst_n=neigh_lookup(&arp_tbl,&tip,lanDev))!=NULL)
+						{
+							if(memcmp(dst_n->ha,zeroMac,6) != 0)
+							{
+								arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+							}
+							neigh_release(dst_n);
+						}						
+					}
+					
+				}
+				else
+				{
+					//hardware local public
+#if defined(CONFIG_RTL_PUBLIC_SSID)
+					//when hw local public access public ssid entry
+					if( rtl865x_is_public_ssid_entry(tip))
+					{
+						if((wanDev!=NULL)&&((dst_n=neigh_lookup(&arp_tbl,&tip,wanDev))!=NULL))
+						{
+							if(memcmp(dst_n->ha,zeroMac,6) != 0)
+							{
+								arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+							}
+							neigh_release(dst_n);
+						}						
+					}
+					else
+#endif
+					{
+						//when hw local public access wan public ip
+						arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+					}
+				}
+				#else
+				{
+					struct neighbour *dst_n;
+					dst_n = neigh_lookup(&arp_tbl,&tip,wanDev);
+					printk("=======%s(%d)\n",__FUNCTION__,__LINE__);
+					if(dst_n)
+					{
+						printk("=======%s(%d)\n",__FUNCTION__,__LINE__);
+						/*send arp reply*/
+						arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dst_n->ha,sha);
+						neigh_release(dst_n);
+					}
+					//hyking:don't reply,until dst_n is found....
+				}
+				#endif
+				
+				
+				if (n) 
+				{
+					neigh_release(n);
+				}
+				goto out;
+				
+			}
+			else if((!fromLocalPublic) && toLocalPublic)
+			{
+				goto common_arp_process;
+		
+			}
+			else if(fromLocalPublic && toLocalPublic)
+			{
+				/*both local public belong to the same network*/
+				ret=rtl865x_getLocalPublicInfo(sip, &srcLocalPubicInfo);
+				if(ret!=0)
+				{
+					goto common_arp_process;
+				}
+				
+				ret=rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);
+				if(ret!=0)
+				{
+					goto common_arp_process;
+				}
+					
+				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
+			
+				#if 0
+				if((srcLocalPubicInfo.ipAddr & srcLocalPubicInfo.netMask) != (tip & srcLocalPubicInfo.netMask))
+				{
+					/*impossible, it shouldn't send out this arp request*/
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dev->dev_addr,sha);
+				}
+				else
+				{
+					/*locate in the same subnet*/
+					if((srcLocalPubicInfo.hw==1) && (dstLocalPublicInfo.hw==1))
+					{
+						/*hw local public to hw local public, tell them each other's mac address directly*/
+						/*Be careful, this is necessary*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+					}
+					else if((srcLocalPubicInfo.hw==1) && (dstLocalPublicInfo.hw==0))
+					{
+						/*dip==localPublicIp and  dmac==local public mac will be trapped to cpu*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+					}
+					else if((srcLocalPubicInfo.hw==0) && (dstLocalPublicInfo.hw==1))
+					{
+						/*due to arp reply(dip==sw localPublicIp and  dmac==sw local public mac) will be trapped to cpu*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+						
+					}
+					else if ((srcLocalPubicInfo.hw==0) && (dstLocalPublicInfo.hw==0))
+					{
+						/*default acl permit, do l2 forwarding*/
+						if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+						{
+							arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+						}
+					}
+						
+				}
+				#endif
+				if(memcmp(dstLocalPublicInfo.mac, zeroMac,6)!=0)
+				{
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,dstLocalPublicInfo.mac,sha);
+				}
+				
+				if (n) 
+				{
+					neigh_release(n);
+				}
+				goto out;
+			}
+			else if ((!fromLocalPublic) && (!toLocalPublic))
+			{
+				goto common_arp_process;
+			}
+		
+		}
+		else if (rxFromWan)
+		{
+			 if((!fromLocalPublic) && toLocalPublic)
+			{	
+				n = neigh_event_ns(&arp_tbl, sha, &sip, dev);
+
+				#if 0
+				rtl865x_getLocalPublicInfo(tip, &dstLocalPublicInfo);	
+				if((sip & dstLocalPublicInfo.netMask) == (tip & dstLocalPublicInfo.netMask))
+				{
+					lanDev=rtl865x_getLanDev();
+					if(lanDev)
+					{
+						arp_send(ARPOP_REQUEST, ETH_P_ARP, tip, lanDev, sip, NULL, lanDev->dev_addr, NULL);
+					}	
+				}
+				#endif
+				
+				if(rtl865x_getLocalPublicMac(tip, localPublicMac)==0)
+				{
+					arp_send(ARPOP_REPLY,ETH_P_ARP,sip,dev,tip,sha,localPublicMac,sha);
+				}
+				
+				if (n) 
+				{	
+					neigh_release(n);
+				}
+				goto out;
+			}
+			 else if((!fromLocalPublic) && (!toLocalPublic))
+			 {
+				/*do common arp process*/
+			 }
+			 else if((fromLocalPublic) && (toLocalPublic))
+			 {
+				/*impossible, should be dropped at dev rx*/
+			 }
+			 else if((fromLocalPublic) && (!toLocalPublic))
+			 {
+				/*impossible, should be dropped at dev rx*/
+			 }
+			
+		}
+		
+	}
+
+common_arp_process:
+#endif
 	if (arp->ar_op == htons(ARPOP_REQUEST) &&
 	    ip_route_input(skb, tip, sip, 0, dev) == 0) {
 
@@ -890,9 +1423,19 @@
 	}
 
 out:
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(lanDev)
+		dev_put(lanDev);
+	if(wanDev)
+		dev_put(wanDev);
+#endif
 	if (in_dev)
 		in_dev_put(in_dev);
 	consume_skb(skb);
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	arp_tag.v = 0;
+#endif
+
 	return 0;
 }
 
@@ -1243,6 +1786,14 @@
 			      NET_IPV4_NEIGH, "ipv4", NULL, NULL);
 #endif
 	register_netdevice_notifier(&arp_netdev_notifier);
+#ifdef CONFIG_RTK_VLAN_SUPPORT
+	arp_tag.v = 0;
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	rtl865x_lpArpProxyInit();
+#endif
+
 }
 
 #ifdef CONFIG_PROC_FS
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/fib_hash.c linux-2.6.30.9-rsdk/net/ipv4/fib_hash.c
--- linux-2.6.30.9/net/ipv4/fib_hash.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/fib_hash.c	2011-12-05 15:50:14.000000000 +0000
@@ -43,6 +43,11 @@
 
 #include "fib_lookup.h"
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+
 static struct kmem_cache *fn_hash_kmem __read_mostly;
 static struct kmem_cache *fn_alias_kmem __read_mostly;
 
@@ -460,6 +465,11 @@
 					err = 0;
 				goto out;
 			}
+
+			#if defined(CONFIG_RTL_819X)
+			rtl_fn_hash_replace_hooks(tb, cfg, fi);
+			#endif
+
 			write_lock_bh(&fib_hash_lock);
 			fi_drop = fa->fa_info;
 			fa->fa_info = fi;
@@ -521,7 +531,6 @@
 	/*
 	 * Insert new entry to the list.
 	 */
-
 	write_lock_bh(&fib_hash_lock);
 	if (new_f)
 		fib_insert_node(fz, new_f);
@@ -536,6 +545,12 @@
 
 	rtmsg_fib(RTM_NEWROUTE, key, new_fa, cfg->fc_dst_len, tb->tb_id,
 		  &cfg->fc_nlinfo, 0);
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_fn_hash_insert_hooks(tb, cfg, fi);
+	#endif
+
+	
 	return 0;
 
 out:
@@ -599,6 +614,10 @@
 	if (fa_to_delete) {
 		int kill_fn;
 
+		#if defined(CONFIG_RTL_819X)
+		rtl_fn_hash_delete_hooks(tb, cfg);
+		#endif
+
 		fa = fa_to_delete;
 		rtmsg_fib(RTM_DELROUTE, key, fa, cfg->fc_dst_len,
 			  tb->tb_id, &cfg->fc_nlinfo, 0);
@@ -626,7 +645,12 @@
 	return -ESRCH;
 }
 
+#if defined(CONFIG_RTL_819X)
+/*2007-12-19*/
+static int fn_flush_list(struct fn_zone *fz, int idx, u32 tb_id)
+#else
 static int fn_flush_list(struct fn_zone *fz, int idx)
+#endif
 {
 	struct hlist_head *head = &fz->fz_hash[idx];
 	struct hlist_node *node, *n;
@@ -642,6 +666,11 @@
 			struct fib_info *fi = fa->fa_info;
 
 			if (fi && (fi->fib_flags&RTNH_F_DEAD)) {
+
+				#if defined(CONFIG_RTL_819X)
+				rtl_fn_flush_list_hooks(fz->fz_order, idx, tb_id , f->fn_key);
+				#endif
+
 				write_lock_bh(&fib_hash_lock);
 				list_del(&fa->fa_list);
 				if (list_empty(&f->fn_alias)) {
@@ -673,7 +702,11 @@
 		int i;
 
 		for (i = fz->fz_divisor - 1; i >= 0; i--)
+#if defined(CONFIG_RTL_819X)		
+			found += fn_flush_list(fz, i, tb->tb_id);		
+#else
 			found += fn_flush_list(fz, i);
+#endif
 	}
 	return found;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/igmp.c linux-2.6.30.9-rsdk/net/ipv4/igmp.c
--- linux-2.6.30.9/net/ipv4/igmp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/igmp.c	2011-12-05 15:50:14.000000000 +0000
@@ -105,6 +105,7 @@
 #include <linux/seq_file.h>
 #endif
 
+
 #define IP_MAX_MEMBERSHIPS	20
 #define IP_MAX_MSF		10
 
@@ -622,6 +623,7 @@
 	(void) igmpv3_sendpack(skb);
 }
 
+
 static int igmp_send_report(struct in_device *in_dev, struct ip_mc_list *pmc,
 	int type)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/ip_forward.c linux-2.6.30.9-rsdk/net/ipv4/ip_forward.c
--- linux-2.6.30.9/net/ipv4/ip_forward.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/ip_forward.c	2011-12-05 15:50:14.000000000 +0000
@@ -95,6 +95,15 @@
 	}
 
 	/* We are about to mangle packet. Copy it! */
+#if 0
+	if( (LL_RESERVED_SPACE(rt->u.dst.dev)+rt->u.dst.header_len) > skb_headroom(skb))
+	{
+		printk("=========%s(%d),dst.dev(%s),reserved(%d),header_len(%d),hard_header_len(%d),needed_headroom(%d)\n",__FUNCTION__,__LINE__,rt->u.dst.dev->name,LL_RESERVED_SPACE(rt->u.dst.dev),
+rt->u.dst.header_len,rt->u.dst.dev->hard_header_len,rt->u.dst.dev->needed_headroom);
+		printk("======%s(%d),skb->headroom(%d)\n",__FUNCTION__,__LINE__,skb_headroom(skb));
+	}
+#endif
+
 	if (skb_cow(skb, LL_RESERVED_SPACE(rt->u.dst.dev)+rt->u.dst.header_len))
 		goto drop;
 	iph = ip_hdr(skb);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/ip_input.c linux-2.6.30.9-rsdk/net/ipv4/ip_input.c
--- linux-2.6.30.9/net/ipv4/ip_input.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/ip_input.c	2011-12-05 15:50:14.000000000 +0000
@@ -144,6 +144,79 @@
 #include <linux/mroute.h>
 #include <linux/netlink.h>
 
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction);
+unsigned int _lan_ip=0xC0A801FE;
+unsigned int _lan_mask=0xFFFFFF00;
+#define USBIP_PORT_NUM 445
+#define USBIP_PORT_NUM_1 139
+#define HTTP_PORT_NUM 80
+unsigned int isUSBexported=1;
+enum netfilter_hooks {
+	_PRE_ROUTING,
+	_LOCAL_IN,
+	_FORWARD,
+	_LOCAL_OUT,
+	_POST_ROUTING,
+	_NUMHOOKS
+};
+int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction)
+{
+	struct iphdr *iph;
+	struct tcphdr *th;
+	int ret=0;	
+	struct net_device       *Indev;
+	struct net_device       *Outdev;
+
+	Indev = skb->dev;
+	iph = ip_hdr(skb);
+	if (iph->frag_off & 0x3fff) /* Ignore fragment */
+		 return 0;	
+	if(iph->protocol ==IPPROTO_TCP){
+		th=(void *) iph + iph->ihl*4;
+		if(hooknum==	_POST_ROUTING){
+			Outdev = skb->dst->dev;
+			if(strcmp(Indev->name , Outdev->name)){
+				return 0;
+			}
+		}
+		if(hooknum==	_PRE_ROUTING){
+			if(iph->daddr != _lan_ip){
+				return 0;	
+			}
+		}
+#if !defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)			
+		if(direction==0){ //rx we check dest port
+			if(_lan_ip != 0 && th->dest==USBIP_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && th->dest==USBIP_PORT_NUM_1 && skb->pkt_type== PACKET_HOST)
+				ret=1;
+
+		}
+		if(direction==1){ //tx we check src port
+			if(_lan_ip != 0 && th->source==USBIP_PORT_NUM && skb->pkt_type== PACKET_HOST)
+				ret=1;
+			if(_lan_ip != 0 && th->source==USBIP_PORT_NUM_1 && skb->pkt_type== PACKET_HOST)
+				ret=1;
+
+		}
+#else
+		if(direction==0){ //rx we check dest port
+			if(_lan_ip != 0 && (th->dest==USBIP_PORT_NUM || th->dest==HTTP_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;
+		}
+		if(direction==1){ //tx we check src port
+			if(_lan_ip != 0 && (th->source==USBIP_PORT_NUM || th->source==HTTP_PORT_NUM) && skb->pkt_type== PACKET_HOST)
+				ret=1;
+		}
+#endif
+	}
+	
+	return ret;
+}
+#endif
+
+
 /*
  *	Process Router Attention IP option
  */
@@ -264,9 +337,17 @@
 		if (ip_defrag(skb, IP_DEFRAG_LOCAL_DELIVER))
 			return 0;
 	}
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	if(isUsbIp_Reserved(skb,NF_INET_LOCAL_IN, 0)==0){
+		return NF_HOOK(PF_INET, NF_INET_LOCAL_IN, skb, skb->dev, NULL, ip_local_deliver_finish);
+	}else{
+		return ip_local_deliver_finish(skb);
+	}
 
+#else
 	return NF_HOOK(PF_INET, NF_INET_LOCAL_IN, skb, skb->dev, NULL,
 		       ip_local_deliver_finish);
+#endif
 }
 
 static inline int ip_rcv_options(struct sk_buff *skb)
@@ -439,9 +520,16 @@
 
 	/* Must drop socket now because of tproxy. */
 	skb_orphan(skb);
-
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	if(isUsbIp_Reserved(skb,NF_INET_PRE_ROUTING, 0)==0){
+		return NF_HOOK(PF_INET, NF_INET_PRE_ROUTING, skb, dev, NULL,ip_rcv_finish);
+	}else{
+		return ip_rcv_finish(skb);
+	}
+#else
 	return NF_HOOK(PF_INET, NF_INET_PRE_ROUTING, skb, dev, NULL,
 		       ip_rcv_finish);
+#endif
 
 inhdr_error:
 	IP_INC_STATS_BH(dev_net(dev), IPSTATS_MIB_INHDRERRORS);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/ipmr.c linux-2.6.30.9-rsdk/net/ipv4/ipmr.c
--- linux-2.6.30.9/net/ipv4/ipmr.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/ipmr.c	2011-12-05 15:50:14.000000000 +0000
@@ -404,6 +404,11 @@
 	spin_unlock(&mfc_unres_lock);
 }
 
+
+static struct mfc_cache *ipmr_cache_find(struct net *net,
+					 __be32 origin,
+					 __be32 mcastgrp);
+
 /* Fill oifs list. It is called under write locked mrt_lock. */
 
 static void ipmr_update_thresholds(struct mfc_cache *cache, unsigned char *ttls)
@@ -531,9 +536,47 @@
 		if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp)
 			break;
 	}
+
+	#if defined (CONFIG_RTL_IGMP_PROXY)
+	// Casey, for IGMP v2
+	if(c == NULL) {
+		origin = 0;
+		line=MFC_HASH(mcastgrp,origin);
+		for (c= net->ipv4.mfc_cache_array[line]; c; c = c->next) {
+			if (c->mfc_origin==origin && c->mfc_mcastgrp==mcastgrp) {
+				break;
+			}
+		}
+	}
+	#endif
 	return c;
 }
 
+#if defined (CONFIG_RTL_IGMP_SNOOPING)
+int rtl865x_checkMfcCache(struct net *net,__be32 origin,__be32 mcastgrp)
+{
+	struct mfc_cache *mfc;
+	mfc=ipmr_cache_find(net,origin,mcastgrp);
+	if(mfc!=NULL)
+	{
+		return 0;
+	}
+	else
+	{
+		mfc = mfc_unres_queue;
+		while (mfc)
+		{
+			if(mfc->mfc_mcastgrp==mcastgrp)
+			{
+				return 0;
+			}
+			mfc = mfc->next;
+		}
+	}
+	return -1;
+}
+#endif
+
 /*
  *	Allocate a multicast cache entry
  */
@@ -651,6 +694,7 @@
 	ip_hdr(skb)->protocol = 0;			/* Flag to the kernel this is a route add */
 	msg = (struct igmpmsg *)skb_network_header(skb);
 	msg->im_vif = vifi;
+	dst_release(skb->dst);
 	skb->dst = dst_clone(pkt->dst);
 
 	/*
@@ -701,7 +745,19 @@
 		    c->mfc_origin == iph->saddr)
 			break;
 	}
-
+#if defined (CONFIG_RTL_IGMP_PROXY)
+//Casey, for IGMP V2 proxy
+#if 0
+/*2008-01-14,for porting igmp proxy to linux kernel 2.6*/
+	if (c == NULL) {
+		for (c=mfc_unres_queue; c; c=c->next) {
+			if (c->mfc_mcastgrp == skb->nh.iph->daddr &&
+		    	c->mfc_origin == 0)
+				break;
+		}
+	}
+#endif
+#endif
 	if (c == NULL) {
 		/*
 		 *	Create a new entry if allowable
@@ -789,7 +845,11 @@
 {
 	int line;
 	struct mfc_cache *uc, *c, **cp;
-
+	#if defined (CONFIG_RTL_IGMP_PROXY)
+	/*
+	mfc->mfcc_origin.s_addr = 0;
+	*/
+	#endif
 	line = MFC_HASH(mfc->mfcc_mcastgrp.s_addr, mfc->mfcc_origin.s_addr);
 
 	for (cp = &net->ipv4.mfc_cache_array[line];
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/ip_output.c linux-2.6.30.9-rsdk/net/ipv4/ip_output.c
--- linux-2.6.30.9/net/ipv4/ip_output.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/ip_output.c	2011-12-05 15:50:14.000000000 +0000
@@ -80,6 +80,12 @@
 #include <linux/netlink.h>
 #include <linux/tcp.h>
 
+
+#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+extern int isUsbIp_Reserved(struct sk_buff *skb, unsigned int hooknum, int direction);
+#endif
+
+
 int sysctl_ip_default_ttl __read_mostly = IPDEFTTL;
 
 /* Generate a checksum for an outgoing IP datagram. */
@@ -95,8 +101,17 @@
 
 	iph->tot_len = htons(skb->len);
 	ip_send_check(iph);
+	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
+	if(isUsbIp_Reserved(skb, NF_INET_LOCAL_OUT, 1)==0){
+		return nf_hook(PF_INET, NF_INET_LOCAL_OUT, skb, NULL, skb->dst->dev,dst_output);
+	}else{
+		return dst_output(skb);
+	}
+	
+	#else
 	return nf_hook(PF_INET, NF_INET_LOCAL_OUT, skb, NULL, skb->dst->dev,
 		       dst_output);
+	#endif	       
 }
 
 int ip_local_out(struct sk_buff *skb)
@@ -302,10 +317,21 @@
 
 	skb->dev = dev;
 	skb->protocol = htons(ETH_P_IP);
+	#if defined(CONFIG_RTL_USB_IP_HOST_SPEEDUP) || defined(CONFIG_HTTP_FILE_SERVER_SUPPORT)
 
+	if(isUsbIp_Reserved(skb, NF_INET_POST_ROUTING, 1)==0){
 	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
 			    ip_finish_output,
 			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+	}else{
+		return ip_finish_output(skb);
+	}
+	
+	#else
+	return NF_HOOK_COND(PF_INET, NF_INET_POST_ROUTING, skb, NULL, dev,
+			    ip_finish_output,
+			    !(IPCB(skb)->flags & IPSKB_REROUTED));
+	#endif
 }
 
 int ip_queue_xmit(struct sk_buff *skb, int ipfragok)
@@ -324,7 +350,9 @@
 		goto packet_routed;
 
 	/* Make sure we can route this packet. */
-	rt = (struct rtable *)__sk_dst_check(sk, 0);
+	//hyking:since bt testing maybe crash, don't use sock's dst cache now...
+	//why did the cache dst entry wrong? DO debug after release 2.6.30 
+	//rt = (struct rtable *)__sk_dst_check(sk, 0);	
 	if (rt == NULL) {
 		__be32 daddr;
 
@@ -409,6 +437,10 @@
 	/* Copy the flags to each fragment. */
 	IPCB(to)->flags = IPCB(from)->flags;
 
+#if defined(CONFIG_RTL_QOS_PATCH) && defined(CONFIG_RTL_819X)
+        to->srcPhyPort = from->srcPhyPort;
+#endif
+
 #ifdef CONFIG_NET_SCHED
 	to->tc_index = from->tc_index;
 #endif
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/Kconfig linux-2.6.30.9-rsdk/net/ipv4/Kconfig
--- linux-2.6.30.9/net/ipv4/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -91,6 +91,15 @@
 config IP_FIB_HASH
 	def_bool ASK_IP_FIB_HASH || !IP_ADVANCED_ROUTER
 
+config RTL_IPTABLES_FAST_PATH
+        tristate "Realtek IPTables Fast Path"
+        default y
+
+config FAST_PATH_SPI_ENABLED
+	bool "Realtek Fastpath SPI(stateful packet inspection) support"
+	depends on RTL_IPTABLES_FAST_PATH
+	default n
+
 config IP_FIB_TRIE_STATS
 	bool "FIB TRIE statistics"
 	depends on IP_FIB_TRIE
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/Makefile linux-2.6.30.9-rsdk/net/ipv4/Makefile
--- linux-2.6.30.9/net/ipv4/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -52,3 +52,6 @@
 
 obj-$(CONFIG_XFRM) += xfrm4_policy.o xfrm4_state.o xfrm4_input.o \
 		      xfrm4_output.o
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/iptable_mangle.c linux-2.6.30.9-rsdk/net/ipv4/netfilter/iptable_mangle.c
--- linux-2.6.30.9/net/ipv4/netfilter/iptable_mangle.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/iptable_mangle.c	2011-12-05 15:50:14.000000000 +0000
@@ -64,7 +64,10 @@
 	.term = IPT_ERROR_INIT,			/* ERROR */
 };
 
-static struct xt_table packet_mangler = {
+#if !defined(CONFIG_NET_SCHED)
+static 
+#endif
+struct xt_table packet_mangler = {
 	.name		= "mangle",
 	.valid_hooks	= MANGLE_VALID_HOOKS,
 	.me		= THIS_MODULE,
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/ip_tables.c linux-2.6.30.9-rsdk/net/ipv4/netfilter/ip_tables.c
--- linux-2.6.30.9/net/ipv4/netfilter/ip_tables.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/ip_tables.c	2011-12-05 15:50:14.000000000 +0000
@@ -28,10 +28,46 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <net/netfilter/nf_log.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#define	RTL865X_QOS_TABLE_NAME		"mangle"
+#define	RTL865X_QOS_TABLE_LEN			6
+#endif
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("IPv4 packet filter");
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+typedef struct xt_rule_to_acl_s
+{
+	struct list_head list;
+	char iniface[IFNAMSIZ], outiface[IFNAMSIZ];
+	rtl865x_AclRule_t *aclRule;	
+} xt_rule_to_acl_t;
+
+LIST_HEAD(rtl865x_iptRule2Acl_tbl_list);
+LIST_HEAD(rtl865x_iptRule2Acl_def_rule_list);
+
+static unsigned int in_def_action = RTL865X_ACL_PERMIT;
+static unsigned int out_def_action = RTL865X_ACL_PERMIT;
+int establish_rule_permit = 0;
+
+extern int get_hookNum(struct ipt_entry *e, unsigned char *base, const unsigned int valid_hooks,const unsigned int *hook_entries);
+
+#endif
+
 /*#define DEBUG_IP_FIREWALL*/
 /*#define DEBUG_ALLOW_ALL*/ /* Useful for remote debugging */
 /*#define DEBUG_IP_FIREWALL_USER*/
@@ -59,11 +95,7 @@
 #define IP_NF_ASSERT(x)
 #endif
 
-#if 0
-/* All the better to debug you with... */
-#define static
-#define inline
-#endif
+
 
 /*
    We keep a set of rules for each CPU, so we can avoid write-locking
@@ -347,9 +379,22 @@
 	/* For return from builtin chain */
 	back = get_entry(table_base, private->underflow[hook]);
 
+	if(ip == NULL)
+	{	
+		//printk("==========%s %s(%d), ip header is NULL!!!\n",__FILE__,__FUNCTION__,__LINE__);
+		return NF_DROP;
+	}
+
 	do {
 		IP_NF_ASSERT(e);
 		IP_NF_ASSERT(back);
+		
+		if(e == NULL)
+		{
+			//printk("==========%s %s(%d), ip header is NULL!!!\n",__FILE__,__FUNCTION__,__LINE__);
+			return NF_DROP;
+		}
+		
 		if (ip_packet_match(ip, indev, outdev,
 		    &e->ip, mtpar.fragoff)) {
 			struct ipt_entry_target *t;
@@ -454,6 +499,12 @@
 {
 	unsigned int hook;
 
+#if 0 //def CONFIG_RTL_HARDWARE_NAT  
+	/*2007-12-19*/
+	unsigned int masqif_set = 0;
+#endif
+
+
 	/* No recursion; use packet counter to save back ptrs (reset
 	   to 0 as we leave), and comefrom to save source hook bitmask */
 	for (hook = 0; hook < NF_INET_NUMHOOKS; hook++) {
@@ -546,6 +597,72 @@
 					/* ... this is a fallthru */
 					newpos = pos + e->next_offset;
 				}
+
+				
+#if 0 // defined(CONFIG_RTL_HARDWARE_NAT)
+				/*2007-12-19*/
+#ifdef CONFIG_HARDWARE_NAT_DEBUG
+				{
+					printk("**************************************\n");
+					printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
+					printk("%s:%d:hook is %d\n",__FUNCTION__,__LINE__,hook);
+					printk("%s:%d:t->target.u.user.name is %s\n",__FUNCTION__,__LINE__,t->target.u.user.name);
+					//printk("%s:%d:t->target.u.kernel.target->name is %s\n",__FUNCTION__,__LINE__,t->target.u.kernel.target->name);
+					printk("%s:%d:e->src(%u.%u.%u.%u),e->dst(%u.%u.%u.%u)\n",__FUNCTION__,
+						__LINE__,NIPQUAD(e->ip.src.s_addr),NIPQUAD(e->ip.dst.s_addr));
+					
+				}
+#endif
+				if ((masq_if[0] == '\0') && (hook == NF_INET_POST_ROUTING) &&
+					((strcmp(t->target.u.user.name, "MASQUERADE") == 0)	)) 
+				{
+					struct net_device *dev;
+					struct in_ifaddr *ina;
+					int rc;
+					masqif_set = 1;
+					memcpy(masq_if, e->ip.outiface, IFNAMSIZ);
+					dev = __dev_get_by_name(&init_net, masq_if);
+					
+					#ifdef CONFIG_HARDWARE_NAT_DEBUG
+					/*2007-12-19*/
+					printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
+					#endif
+
+					if ((dev)&&(dev->ip_ptr)) {			
+						
+						ina=(struct in_ifaddr *)(((struct in_device *)(dev->ip_ptr))->ifa_list);						
+						if (ina!=NULL) 
+						{
+							if (hw_napt_ip) {
+								rc = 0;
+			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+								rc = rtl865x_delIp(hw_napt_ip);
+			#endif
+								#ifdef CONFIG_HARDWARE_NAT_DEBUG
+								printk("LR(%s): 0x%x, errno=%d\n", "del_natip2", hw_napt_ip, rc);
+								#endif
+								if (rc == SUCCESS)
+									hw_napt_ip = 0;
+							}
+							rc = 0;
+			#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+							//printk("%s:%d:masq_if is %s\n",__FUNCTION__,__LINE__,masq_if);
+							//printk("---------------ip(%u.%u.%u.%u)\n",NIPQUAD((u32)(ina->ifa_local)));
+							rc = rtl865x_addIp(0,(u32)(ina->ifa_local),IP_TYPE_NAPT);
+			#endif							
+
+							if (rc == SUCCESS)
+								hw_napt_ip = ina->ifa_local;
+							#ifdef CONFIG_HARDWARE_NAT_DEBUG
+							/*2007-12-19*/
+							printk("%s:%d:(%s): %u.%u.%u.%u, errno=%d\n", __FUNCTION__,__LINE__,"add_natip",NIPQUAD((u32)(ina->ifa_local)), rc);
+							#endif
+						}
+					}
+				}
+
+#endif							
+
 				e = (struct ipt_entry *)
 					(entry0 + newpos);
 				e->counters.pcnt = pos;
@@ -554,6 +671,13 @@
 		}
 		next:
 		duprintf("Finished chain %u\n", hook);
+#if 0 //def CONFIG_RTL_HARDWARE_NAT
+		/*2007-12-19*/
+		if (masqif_set == 0 && masq_if[0] != '\0' && hook==NF_INET_POST_ROUTING) {
+			masq_if[0] = '\0';
+		}
+#endif	
+
 	}
 	return 1;
 }
@@ -575,209 +699,1235 @@
 	return 0;
 }
 
-static int
-check_entry(struct ipt_entry *e, const char *name)
+static int
+check_entry(struct ipt_entry *e, const char *name)
+{
+	struct ipt_entry_target *t;
+
+	if (!ip_checkentry(&e->ip)) {
+		duprintf("ip_tables: ip check failed %p %s.\n", e, name);
+		return -EINVAL;
+	}
+
+	if (e->target_offset + sizeof(struct ipt_entry_target) >
+	    e->next_offset)
+		return -EINVAL;
+
+	t = ipt_get_target(e);
+	if (e->target_offset + t->u.target_size > e->next_offset)
+		return -EINVAL;
+
+	return 0;
+}
+
+static int
+check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
+	    unsigned int *i)
+{
+	const struct ipt_ip *ip = par->entryinfo;
+	int ret;
+
+	par->match     = m->u.kernel.match;
+	par->matchinfo = m->data;
+
+	ret = xt_check_match(par, m->u.match_size - sizeof(*m),
+	      ip->proto, ip->invflags & IPT_INV_PROTO);
+	if (ret < 0) {
+		duprintf("ip_tables: check failed for `%s'.\n",
+			 par.match->name);
+		return ret;
+	}
+	++*i;
+	return 0;
+}
+
+static int
+find_check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
+		 unsigned int *i)
+{
+	struct xt_match *match;
+	int ret;
+
+	match = try_then_request_module(xt_find_match(AF_INET, m->u.user.name,
+						      m->u.user.revision),
+					"ipt_%s", m->u.user.name);
+	if (IS_ERR(match) || !match) {
+		duprintf("find_check_match: `%s' not found\n", m->u.user.name);
+		return match ? PTR_ERR(match) : -ENOENT;
+	}
+	m->u.kernel.match = match;
+
+	ret = check_match(m, par, i);
+	if (ret)
+		goto err;
+
+	return 0;
+err:
+	module_put(m->u.kernel.match->me);
+	return ret;
+}
+
+static int check_target(struct ipt_entry *e, const char *name)
+{
+	struct ipt_entry_target *t = ipt_get_target(e);
+	struct xt_tgchk_param par = {
+		.table     = name,
+		.entryinfo = e,
+		.target    = t->u.kernel.target,
+		.targinfo  = t->data,
+		.hook_mask = e->comefrom,
+		.family    = NFPROTO_IPV4,
+	};
+	int ret;
+
+	ret = xt_check_target(&par, t->u.target_size - sizeof(*t),
+	      e->ip.proto, e->ip.invflags & IPT_INV_PROTO);
+	if (ret < 0) {
+		duprintf("ip_tables: check failed for `%s'.\n",
+			 t->u.kernel.target->name);
+		return ret;
+	}
+	return 0;
+}
+
+static int
+find_check_entry(struct ipt_entry *e, const char *name, unsigned int size,
+		 unsigned int *i)
+{
+	struct ipt_entry_target *t;
+	struct xt_target *target;
+	int ret;
+	unsigned int j;
+	struct xt_mtchk_param mtpar;
+
+	ret = check_entry(e, name);
+	if (ret)
+		return ret;
+
+	j = 0;
+	mtpar.table     = name;
+	mtpar.entryinfo = &e->ip;
+	mtpar.hook_mask = e->comefrom;
+	mtpar.family    = NFPROTO_IPV4;
+	ret = IPT_MATCH_ITERATE(e, find_check_match, &mtpar, &j);
+	if (ret != 0)
+		goto cleanup_matches;
+
+	t = ipt_get_target(e);
+	target = try_then_request_module(xt_find_target(AF_INET,
+							t->u.user.name,
+							t->u.user.revision),
+					 "ipt_%s", t->u.user.name);
+	if (IS_ERR(target) || !target) {
+		duprintf("find_check_entry: `%s' not found\n", t->u.user.name);
+		ret = target ? PTR_ERR(target) : -ENOENT;
+		goto cleanup_matches;
+	}
+	t->u.kernel.target = target;
+
+	ret = check_target(e, name);
+	if (ret)
+		goto err;
+
+	(*i)++;
+	return 0;
+ err:
+	module_put(t->u.kernel.target->me);
+ cleanup_matches:
+	IPT_MATCH_ITERATE(e, cleanup_match, &j);
+	return ret;
+}
+
+static int
+check_entry_size_and_hooks(struct ipt_entry *e,
+			   struct xt_table_info *newinfo,
+			   unsigned char *base,
+			   unsigned char *limit,
+			   const unsigned int *hook_entries,
+			   const unsigned int *underflows,
+			   unsigned int *i)
+{
+	unsigned int h;
+
+	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0
+	    || (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
+		duprintf("Bad offset %p\n", e);
+		return -EINVAL;
+	}
+
+	if (e->next_offset
+	    < sizeof(struct ipt_entry) + sizeof(struct ipt_entry_target)) {
+		duprintf("checking: element %p size %u\n",
+			 e, e->next_offset);
+		return -EINVAL;
+	}
+
+	/* Check hooks & underflows */
+	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
+		if ((unsigned char *)e - base == hook_entries[h])
+			newinfo->hook_entry[h] = hook_entries[h];
+		if ((unsigned char *)e - base == underflows[h])
+			newinfo->underflow[h] = underflows[h];
+	}
+
+	/* FIXME: underflows must be unconditional, standard verdicts
+	   < 0 (not IPT_RETURN). --RR */
+
+	/* Clear counters and comefrom */
+	e->counters = ((struct xt_counters) { 0, 0 });
+	e->comefrom = 0;
+	
+	(*i)++;
+	return 0;
+}
+
+static int
+cleanup_entry(struct ipt_entry *e, unsigned int *i)
+{
+	struct xt_tgdtor_param par;
+	struct ipt_entry_target *t;
+
+	if (i && (*i)-- == 0)
+		return 1;
+
+	/* Cleanup all matches */
+	IPT_MATCH_ITERATE(e, cleanup_match, NULL);
+	t = ipt_get_target(e);
+
+	par.target   = t->u.kernel.target;
+	par.targinfo = t->data;
+	par.family   = NFPROTO_IPV4;
+	if (par.target->destroy != NULL)
+		par.target->destroy(&par);
+	module_put(par.target->me);
+	return 0;
+}
+
+
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static struct xt_target ipt_standard_target;
+static struct xt_target ipt_error_target; 
+
+static void rtl865x_print_iptRule2Acl_tbl(void)
+{
+	rtl865x_iptRule2Acl_tbl *listNode;
+	xt_rule_to_acl_t *match2acl;
+	int i ;
+	printk("=======================================\n");
+	list_for_each_entry(listNode,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		printk("list->tblName(%s),list->priority(%d)\n",listNode->tblName,listNode->priority);
+		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+		{
+			printk("%d\n",i);
+			list_for_each_entry(match2acl,&listNode->chainList[i],list)
+			{
+				printk("  inIf(%s) outIn(%s) aclType(0x%x) aclAction(0x%x),direction(%d)\n",match2acl->iniface,match2acl->outiface,match2acl->aclRule->ruleType_,match2acl->aclRule->actionType_,match2acl->aclRule->direction_);
+			}			
+		}
+		
+	}
+	printk("=======================================\n");
+}
+
+static rtl865x_iptRule2Acl_tbl* rtl865x_get_ipt2Acl_tbl(const char *name)
+{
+	rtl865x_iptRule2Acl_tbl *listNode,*retEntry;	
+	retEntry = NULL;
+	
+	list_for_each_entry(listNode,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		if(memcmp(listNode->tblName,name,strlen(name)) == 0)
+		{
+			retEntry = listNode;
+			break;
+		}
+	}
+
+	return retEntry;
+}
+
+/*translate iptables ip rule to acl*/
+static int ipt_ip2Acl(struct ipt_entry *e, rtl865x_AclRule_t *acl, int *all_match)
+{
+
+	if(e == NULL || acl == NULL)
+		return -1;
+
+
+	acl->ruleType_ = RTL865X_ACL_IP;
+		
+	/*proto 0=ANY */
+	if(e->ip.proto == 0)		
+		acl->ipProtoMask_ = 0x0;
+	else
+		acl->ipProtoMask_ = 0xff;
+
+	acl->srcIpAddr_ 		= e->ip.src.s_addr;
+	acl->srcIpAddrMask_	= e->ip.smsk.s_addr;
+	acl->dstIpAddr_		= e->ip.dst.s_addr;
+	acl->dstIpAddrMask_	= e->ip.dmsk.s_addr;
+	acl->ipProto_			= e->ip.proto;
+
+	if((e->ip.flags & IPT_F_FRAG) && ((e->ip.invflags & IPT_INV_FRAG) == 0) )
+	{
+		acl->ipFOP_ = 1;
+		acl->ipFOM_ = 1;
+	}
+
+	if(e->ip.smsk.s_addr == 0 && e->ip.dmsk.s_addr == 0 && e->ip.proto == 0)
+	{
+		/*all packet match this rule... so, this rule should be add to tail...*/
+		if(all_match)
+			*all_match = 1;
+		/*
+		*hyking:
+		*when all packet match this rule, we change acl->ruleType to ether type
+		*2008-12-16
+		*/
+		acl->ruleType_ = RTL865X_ACL_MAC;
+	}
+
+	return 0;
+}
+
+static int standard_target2Acl(struct ipt_entry_target *t,rtl865x_AclRule_t *rule)
+{
+	switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+	{
+		case NF_DROP:
+			rule->actionType_ = RTL865X_ACL_DROP;
+			break;
+		case NF_ACCEPT:
+			rule->actionType_  = RTL865X_ACL_PERMIT;
+			break;
+		case NF_QUEUE:
+		case NF_REPEAT:
+		case NF_STOP:
+		case NF_STOLEN:
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+			break;
+		default:
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+			break;
+					
+	}
+	return 0;
+}
+
+/*translate iptables rule to ACL*/
+static int translate_rule2Acl(struct ipt_entry *e,  
+unsigned char *base,const char *name,unsigned int size,
+const unsigned int valid_hooks,const unsigned int *hook_entries)
+{
+	
+	int match_cnt = 0;
+	int hook_num = -1;
+	int nxt_hookNum = -1;
+	struct ipt_entry_match *__match;
+	struct ipt_entry_target *t,*nxt_target;
+	struct ipt_target *target;
+	rtl865x_AclRule_t *rule = NULL;
+	xt_rule_to_acl_t *list_node = NULL;
+	struct ipt_entry *nxt_entry;
+	rtl865x_iptRule2Acl_tbl *ipt2AclTbl;
+	int retval;
+	unsigned int last_entry = 0;
+	unsigned int invflags = 0;
+	int allMatch = 0;
+	void	*data = NULL;
+	unsigned int default_action = RTL865X_ACL_PERMIT;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	char	qosIfName[IFNAMSIZ];
+#endif
+
+	t = ipt_get_target(e);
+	if(t == NULL || (t->u.kernel.target  == &ipt_error_target) )
+		goto next;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	memset(qosIfName, 0, IFNAMSIZ);
+#endif
+
+	hook_num = get_hookNum(e,base,valid_hooks,hook_entries);
+
+	/*last entry of this hooknum??*/
+	last_entry = 0;	
+	if(((void *) e - (void *)base + e->next_offset) >= size)
+		last_entry = 1;
+	
+	if(last_entry == 0)
+	{
+		nxt_entry = (struct ipt_entry *)((void *)e + e->next_offset);
+		nxt_hookNum = get_hookNum(nxt_entry,base,valid_hooks,hook_entries);
+		if(nxt_hookNum != hook_num)
+			last_entry = 1;
+
+		/*there are error rule at the end of the table...*/
+		nxt_target = ipt_get_target(nxt_entry);
+		if(nxt_target->u.kernel.target  == &ipt_error_target)
+		{
+			last_entry = 1;
+		}
+	}
+
+	if(hook_num < 0 || hook_num >= NF_INET_NUMHOOKS)
+	{
+		printk("!!!!BUG!!!!%s(%d)\n",__FUNCTION__,__LINE__);
+		goto next;
+	}
+
+	/*if this entry is the last entry of filter table INPUT chain or output chain*/
+	if(last_entry)
+	{
+		if(t->u.kernel.target == &ipt_standard_target)
+		{			
+			switch((-((struct ipt_standard_target *)t)->verdict) -1)
+			{
+				case NF_DROP:
+					 default_action = RTL865X_ACL_DROP;
+					break;
+				case NF_ACCEPT:
+					 default_action = RTL865X_ACL_PERMIT;
+					break;
+				case NF_QUEUE:
+				case NF_REPEAT:
+				case NF_STOP:
+				case NF_STOLEN:
+					 default_action = RTL865X_ACL_TOCPU;
+					break;
+				default:
+					 default_action = RTL865X_ACL_TOCPU;
+					break;
+							
+			}
+			
+			if(hook_num == NF_INET_LOCAL_IN)
+				in_def_action = default_action;
+			else if(hook_num == NF_INET_LOCAL_OUT)
+				out_def_action = default_action;
+			
+		}
+	}
+
+	///*only translate input&forward chain rule*/
+	//translate all chains for filter table now...
+	#if 0
+	if(	(hook_num >= NF_INET_LOCAL_OUT 
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		&& memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN)
+#endif
+		) || (last_entry)	)
+		goto next;
+	#else
+	if(last_entry)
+		goto next;
+	
+	#endif
+	
+	list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+	if(!list_node)
+	{
+		printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+		goto next;
+	}
+		
+	rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+	if(!rule)
+	{			
+		printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+		goto next;
+	}
+
+	
+	memset(rule, 0,sizeof(rtl865x_AclRule_t));
+	//default: all packet to cpu
+	rule->actionType_ = RTL865X_ACL_TOCPU;
+	rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+
+	/*invert interface flag*/
+	if(e->ip.invflags & IPT_INV_VIA_IN)
+		rule->inv_flag = RTL865X_INVERT_IN_NETIF;
+	
+	else if(e->ip.invflags & IPT_INV_VIA_OUT)
+		rule->inv_flag = RTL865X_INVERT_OUT_NETIF;
+	
+	target = t->u.kernel.target;		
+	match_cnt = IPT_MATCH_NUMBER(e);
+	retval = -1;
+	if(match_cnt == 0)
+	{
+		/*only ipt_ip & target information in iptables rule, no match rule*/
+		/*ip rule...*/
+		retval = ipt_ip2Acl(e,rule,&allMatch);
+
+		if(retval != 0)
+			printk("%s(%d) BUG!!!!\n",__FUNCTION__,__LINE__);
+		
+		/*acl action....*/
+		if(t->u.kernel.target == &ipt_standard_target)
+		{
+			/*standard target*/
+			standard_target2Acl(t,rule);
+		}
+		else if (t->u.kernel.target->target2acl)
+		{
+			retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+			if(retval != 0)
+			{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+				/* Add the following conditions for pathing qos rules */
+				if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
+					e->ip.outiface[0]=='\0' && 
+					retval == RTL_QOSFINDSPECIALNETIF)
+				{
+					memcpy(qosIfName, data, strlen(data));
+					qosIfName[strlen(data)] = '\0';
+					kfree(data);
+				}
+				else if (retval == RTL865X_SKIP_THIS_RULE)
+				{
+					goto next;
+				}
+				else
+#endif
+					rule->actionType_ = RTL865X_ACL_TOCPU;
+			}
+		}
+		else
+		{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+			goto next;
+#endif
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+		}
+
+		/*deal with invert flags...*/
+		if(e->ip.invflags & (IPT_INV_SRCIP|IPT_INV_DSTIP | IPT_INV_PROTO))
+		{
+			if(rule->actionType_ == RTL865X_ACL_PERMIT)
+				rule->actionType_ = RTL865X_ACL_DROP;
+			else if (rule->actionType_ == RTL865X_ACL_DROP)
+				rule->actionType_ = RTL865X_ACL_PERMIT;
+		}			
+	}
+	else if(match_cnt == 1)
+	{
+		__match = (void *)(e) + sizeof(struct ipt_entry);
+			
+		/*translate match to ACL rule...*/
+		if(__match->u.kernel.match && __match->u.kernel.match->match2acl)
+		{	
+			retval = __match->u.kernel.match->match2acl(name, &e->ip, __match->u.kernel.match, __match->data,rule,&invflags);
+			if(retval == 0)
+			{
+				/*translate target to ACL action*/
+				if(t->u.kernel.target == &ipt_standard_target)
+				{
+					/*standard target*/
+					standard_target2Acl(t,rule);
+					#if 0
+					switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+					{
+						case NF_DROP:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+							else
+								rule->actionType_ = RTL865X_ACL_DROP;
+							break;
+						case NF_ACCEPT:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else
+								rule->actionType_  = RTL865X_ACL_PERMIT;
+							break;
+						case NF_QUEUE:
+						case NF_REPEAT:
+						case NF_STOP:
+						case NF_STOLEN:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+						default:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+						
+					}
+					#endif					
+				}
+				else if (t->u.kernel.target->target2acl)
+				{
+					retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+					if(retval != 0)
+					{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+						/* Add the following conditions for pathing qos rules */
+						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
+							e->ip.outiface[0]=='\0' && 
+							retval == RTL_QOSFINDSPECIALNETIF)
+						{
+							memcpy(qosIfName, data, strlen(data));
+							qosIfName[strlen(data)] = '\0';
+							kfree(data);
+						}
+						else if (retval == RTL865X_SKIP_THIS_RULE)
+						{
+							goto next;
+						}
+						else
+#endif
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+					}
+					#if 0
+					else
+					{
+						if(invflags)
+						{
+							if(rule->actionType_ == RTL865X_ACL_PERMIT)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else if(rule->actionType_ == RTL865X_ACL_DROP)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+						}
+					}
+					#endif
+				}
+				else
+				{
+					rule->actionType_ = RTL865X_ACL_TOCPU;
+				}
+
+				/*invert interface flag*/
+				if(invflags)
+				{
+					if(rule->actionType_ == RTL865X_ACL_PERMIT)
+						rule->actionType_ = RTL865X_ACL_DROP;
+					else if(rule->actionType_ == RTL865X_ACL_DROP)
+						rule->actionType_ = RTL865X_ACL_PERMIT;
+				}
+			}
+			else if (retval == RTL865X_ESTABLISH_RULE)
+			{
+				/*translate target to ACL action*/
+				if(t->u.kernel.target == &ipt_standard_target)
+				{
+					/*standard target*/
+					standard_target2Acl(t,rule);
+					#if 0
+					switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+					{
+						case NF_DROP:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+							else
+								rule->actionType_ = RTL865X_ACL_DROP;
+							break;
+						case NF_ACCEPT:
+							if(invflags)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else
+								rule->actionType_  = RTL865X_ACL_PERMIT;
+							break;
+						case NF_QUEUE:
+						case NF_REPEAT:
+						case NF_STOP:
+						case NF_STOLEN:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+						default:
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+							break;
+						
+					}
+					#endif
+				}
+				else if (t->u.kernel.target->target2acl)
+				{
+					retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+					if(retval != 0)
+					{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+						/* Add the following conditions for pathing qos rules */
+						if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
+							e->ip.outiface[0]=='\0' && 
+							retval == RTL_QOSFINDSPECIALNETIF)
+						{
+							memcpy(qosIfName, data, strlen(data));
+							qosIfName[strlen(data)] = '\0';
+							kfree(data);
+						}
+						else if (retval == RTL865X_SKIP_THIS_RULE)
+						{
+							goto next;
+						}
+						else
+#endif
+							rule->actionType_ = RTL865X_ACL_TOCPU;
+					}
+					#if 0
+					else
+					{
+						if(invflags)
+						{
+							if(rule->actionType_ == RTL865X_ACL_PERMIT)
+								rule->actionType_ = RTL865X_ACL_DROP;
+							else if(rule->actionType_ == RTL865X_ACL_DROP)
+								rule->actionType_ = RTL865X_ACL_PERMIT;
+						}
+					}
+					#endif
+				}
+				else
+				{
+					rule->actionType_ = RTL865X_ACL_TOCPU;
+				}
+
+				/*invert interface flag*/
+				if(invflags)
+				{
+					if(rule->actionType_ == RTL865X_ACL_PERMIT)
+						rule->actionType_ = RTL865X_ACL_DROP;
+					else if(rule->actionType_ == RTL865X_ACL_DROP)
+						rule->actionType_ = RTL865X_ACL_PERMIT;
+				}
+
+				if(rule->actionType_ == RTL865X_ACL_PERMIT)
+					establish_rule_permit = 1;
+				
+				goto next;
+			}			
+			else if(retval == RTL865X_SKIP_THIS_RULE)
+			{
+				goto next;
+			}
+			else
+			{
+				rule->ruleType_		= RTL865X_ACL_MAC;
+				rule->actionType_	= RTL865X_ACL_TOCPU;
+				rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+			}
+		}
+		else
+		{
+			rule->ruleType_		= RTL865X_ACL_MAC;
+			rule->actionType_	= RTL865X_ACL_TOCPU;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+		}
+	}
+	else if(match_cnt > 1)
+	{
+		int		len;
+		int		hasNoSpt = FALSE;
+		
+		len = 0;
+		while(match_cnt>0)
+		{
+			__match = (void *)(e) + sizeof(struct ipt_entry) + len;
+
+			if(__match->u.kernel.match && __match->u.kernel.match->match2acl)
+			{
+				retval = __match->u.kernel.match->match2acl(name, &e->ip, __match->u.kernel.match, __match->data,rule,&invflags);
+
+				if(retval == 0)
+				{
+					len += __match->u.match_size;
+					match_cnt--;
+				}
+				else
+					break;
+			}
+			else
+			{
+				hasNoSpt = TRUE;
+				match_cnt--;
+//				retval = RTL865X_MATCH_NOT_SUPPORTED;
+//				break;
+			}
+		}
+
+		if (hasNoSpt==TRUE)
+			retval = RTL865X_MATCH_NOT_SUPPORTED;
+		
+		if(retval == 0)
+		{
+		
+			/*translate target to ACL action*/
+			if(t->u.kernel.target == &ipt_standard_target)
+			{
+				/*standard target*/
+				standard_target2Acl(t,rule);
+				#if 0
+				switch(-(((struct ipt_standard_target *)t)->verdict) -1)
+				{
+					case NF_DROP:
+						if(invflags)
+							rule->actionType_ = RTL865X_ACL_PERMIT;
+						else
+							rule->actionType_ = RTL865X_ACL_DROP;
+						break;
+					case NF_ACCEPT:
+						if(invflags)
+							rule->actionType_ = RTL865X_ACL_DROP;
+						else
+							rule->actionType_  = RTL865X_ACL_PERMIT;
+						break;
+					case NF_QUEUE:
+					case NF_REPEAT:
+					case NF_STOP:
+					case NF_STOLEN:
+						rule->actionType_ = RTL865X_ACL_TOCPU;
+						break;
+					default:
+						rule->actionType_ = RTL865X_ACL_TOCPU;
+						break;
+					
+				}
+				#endif
+			}
+			else if (t->u.kernel.target->target2acl)
+			{
+				retval = t->u.kernel.target->target2acl(name, e, target, t->data,rule,e->comefrom, &data);
+				if(retval != 0)
+				{
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+					/* Add the following conditions for pathing qos rules */
+					if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN) && 
+						e->ip.outiface[0]=='\0' && 
+						retval == RTL_QOSFINDSPECIALNETIF)
+					{
+						memcpy(qosIfName, data, strlen(data));
+						qosIfName[strlen(data)] = '\0';
+						kfree(data);
+					}
+					else if (retval == RTL865X_SKIP_THIS_RULE)
+					{
+						goto next;
+					}
+					else
+#endif
+						rule->actionType_ = RTL865X_ACL_TOCPU;
+				}
+				else
+				{
+					if(invflags)
+					{
+						if(rule->actionType_ == RTL865X_ACL_PERMIT)
+							rule->actionType_ = RTL865X_ACL_DROP;
+						else if(rule->actionType_ == RTL865X_ACL_DROP)
+							rule->actionType_ = RTL865X_ACL_PERMIT;
+					}
+				}
+			}
+			else
+			{
+				rule->actionType_ = RTL865X_ACL_TOCPU;
+			}
+			
+			/*invert interface flag*/
+			if(invflags)
+			{
+				if(rule->actionType_ == RTL865X_ACL_PERMIT)
+					rule->actionType_ = RTL865X_ACL_DROP;
+				else if(rule->actionType_ == RTL865X_ACL_DROP)
+					rule->actionType_ = RTL865X_ACL_PERMIT;
+			}	
+			
+		}
+		else if(retval == RTL865X_SKIP_THIS_RULE)
+		{
+			goto next;
+		}
+		else
+		{
+			/*add ACL trap all packet to CPU*/
+#if 0
+			memset(rule, 0,sizeof(rtl865x_AclRule_t));
+			rule->ruleType_		= RTL865X_ACL_MAC;
+			rule->actionType_	= RTL865X_ACL_TOCPU;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+#else
+			/* For some un-support type rules, only trap the special kinds of pkt instead of trap all */
+			rule->actionType_	= RTL865X_ACL_TOCPU;
+			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
+#endif
+		}
+	}
+	else
+		goto next;
+
+	/*add xt_rule_to_acl to list*/
+	/* 
+	  *	Since we do the acl check actually in PREROUTING chain
+	  *	Some toCpu pkt maybe mis-decided by FORWARD chain rules
+	  *	So, we do the following patch.
+	  */
+	if(hook_num == NF_INET_FORWARD)
+	{
+		if(rule->actionType_ != RTL865X_ACL_PERMIT)
+			rule->actionType_ = RTL865X_ACL_TOCPU;
+		
+		rule->pktOpApp_ = RTL865X_ACL_L3_AND_L4;
+	}
+
+	if(hook_num <NF_INET_LOCAL_OUT)
+		rule->direction_ = RTL865X_ACL_INGRESS;
+	else
+		rule->direction_ = RTL865X_ACL_EGRESS;
+	
+	list_node->aclRule = rule;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	if (qosIfName[0]!='\0')
+	{
+		memcpy(&list_node->iniface,qosIfName,strlen(qosIfName));
+		list_node->iniface[strlen(qosIfName)] = '\0';
+	}
+	else
+#endif
+	{
+		memcpy(&list_node->iniface,&e->ip.iniface,strlen(e->ip.iniface)+1);
+		list_node->iniface[strlen(e->ip.iniface)] = '\0';
+	}
+
+	{
+		memcpy(&list_node->outiface,&e->ip.outiface,strlen(e->ip.outiface)+1);
+		list_node->outiface[strlen(e->ip.outiface)] = '\0';
+	}
+
+	/*now, add this rule to releated chain*/
+
+	ipt2AclTbl = rtl865x_get_ipt2Acl_tbl(name);
+	if(ipt2AclTbl == NULL)
+		goto next;
+
+	if((allMatch == 1) && (!memcmp(name,"filter",strlen("filter"))))
+		list_add_tail(&list_node->list,&rtl865x_iptRule2Acl_def_rule_list);
+	else
+		list_add_tail(&list_node->list, &ipt2AclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_0]);
+
+	return 0;
+
+next:
+
+	/*free memory and return*/
+	if(rule)
+		kfree(rule);
+	
+	if(list_node)
+		kfree(list_node);
+		
+	return 0;
+	
+}
+
+static int translate_ipTblRules2Acl(const char *name,
+		unsigned int valid_hooks,
+		struct xt_table_info *newinfo,
+		void *entry0,
+		unsigned int size,
+		unsigned int number,
+		const unsigned int *hook_entries,
+		const unsigned int *underflows)
+{
+	int	ret;
+	rtl865x_AclRule_t *rule;
+	xt_rule_to_acl_t *list_node,*nxt;
+	rtl865x_iptRule2Acl_tbl *ipt2aclTbl;
+
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#else
+	if(memcmp(name,"filter",strlen("filter")) != 0)
+		return 0;
+#endif
+
+	ipt2aclTbl = rtl865x_get_ipt2Acl_tbl(name);
+
+	if(!ipt2aclTbl)
+	{
+		return 0;
+	}
+
+	ret = IPT_ENTRY_ITERATE(entry0, size,translate_rule2Acl, entry0,name,size,valid_hooks,hook_entries);
+
+	/*merge def_rule_list to match_to_acl_rule_list*/
+	if (!memcmp(name,"filter",strlen("filter")))
+	{
+		list_for_each_entry_safe(list_node,nxt,&rtl865x_iptRule2Acl_def_rule_list,list)
+		{
+			list_del(&list_node->list);
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);		
+		}
+
+	/*hyking:
+		iptables rule can't deal with packets whose action is layer2 switch,
+		so, patch this case when def_action is drop...
+	*/
+//	if((def_action == RTL865X_ACL_DROP) && !memcmp(name,"filter",strlen("filter")))
+		if(establish_rule_permit == 1)
+			in_def_action = RTL865X_ACL_PERMIT;
+		
+		if((in_def_action == RTL865X_ACL_DROP))
+		{	
+			/*deal with the permit multicast acl...*/
+			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+			if(!list_node)
+			{
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+				
+			rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+			if(!rule)
+			{
+				if(list_node)
+					kfree(list_node);
+				
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+			
+			/*permit all multicast packet...*/
+			memset(rule, 0,sizeof(rtl865x_AclRule_t));
+			rule->ruleType_ = RTL865X_ACL_MAC;
+			rule->actionType_ = RTL865X_ACL_PERMIT;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+
+			rule->dstMac_.octet[0] = 0x01;
+			rule->dstMacMask_.octet[0] = 0x01;
+			
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_3]);
+
+			/*permit all arp packet*/
+			list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+			if(!list_node)
+			{
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+				
+			rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+			if(!rule)
+			{
+				if(list_node)
+					kfree(list_node);
+				
+				printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+				goto next;
+			}
+			
+			/*permit all arp packet...*/
+			memset(rule, 0,sizeof(rtl865x_AclRule_t));
+			rule->ruleType_ = RTL865X_ACL_MAC;
+			rule->actionType_ = RTL865X_ACL_PERMIT;
+			rule->pktOpApp_ = RTL865X_ACL_ALL_LAYER;
+
+			rule->typeLen_ = 0x0806;
+			rule->typeLenMask_ = 0xffff;
+			
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_3]);
+			
+		}
+
+		//in bound
+		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+		if(!list_node)
+		{
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
+		}
+			
+		rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+		if(!rule)
 {
-	struct ipt_entry_target *t;
+			if(list_node)
+				kfree(list_node);
 
-	if (!ip_checkentry(&e->ip)) {
-		duprintf("ip_tables: ip check failed %p %s.\n", e, name);
-		return -EINVAL;
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
 	}
 
-	if (e->target_offset + sizeof(struct ipt_entry_target) >
-	    e->next_offset)
-		return -EINVAL;
+		memset(rule, 0,sizeof(rtl865x_AclRule_t));
 
-	t = ipt_get_target(e);
-	if (e->target_offset + t->u.target_size > e->next_offset)
-		return -EINVAL;
 
-	return 0;
+		{
+			rule->ruleType_	= RTL865X_ACL_MAC;
+			rule->actionType_	= in_def_action;
+			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
+			rule->direction_ = RTL865X_ACL_INGRESS;
+			
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
 }
 
-static int
-check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
-	    unsigned int *i)
+		//outbound
+		list_node = kmalloc(sizeof(xt_rule_to_acl_t),GFP_KERNEL);	
+		if(!list_node)
 {
-	const struct ipt_ip *ip = par->entryinfo;
-	int ret;
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
+		}
 
-	par->match     = m->u.kernel.match;
-	par->matchinfo = m->data;
+		rule = kmalloc(sizeof(rtl865x_AclRule_t), GFP_KERNEL);
+		if(!rule)
+		{
+			if(list_node)
+				kfree(list_node);
 
-	ret = xt_check_match(par, m->u.match_size - sizeof(*m),
-	      ip->proto, ip->invflags & IPT_INV_PROTO);
-	if (ret < 0) {
-		duprintf("ip_tables: check failed for `%s'.\n",
-			 par.match->name);
-		return ret;
-	}
-	++*i;
-	return 0;
+			printk("\n!!!!!!%s(%d): No memory freed for kmalloc!!!",__FUNCTION__,__LINE__);
+			goto next;
 }
 
-static int
-find_check_match(struct ipt_entry_match *m, struct xt_mtchk_param *par,
-		 unsigned int *i)
+		memset(rule, 0,sizeof(rtl865x_AclRule_t));
+
+
 {
-	struct xt_match *match;
-	int ret;
+			rule->ruleType_	= RTL865X_ACL_MAC;
+			rule->actionType_	= out_def_action;
+			rule->pktOpApp_ 	= RTL865X_ACL_ALL_LAYER;
+			rule->direction_ = RTL865X_ACL_EGRESS;
 
-	match = try_then_request_module(xt_find_match(AF_INET, m->u.user.name,
-						      m->u.user.revision),
-					"ipt_%s", m->u.user.name);
-	if (IS_ERR(match) || !match) {
-		duprintf("find_check_match: `%s' not found\n", m->u.user.name);
-		return match ? PTR_ERR(match) : -ENOENT;
+			/*add xt_rule_to_acl to list*/
+			list_node->aclRule = rule;
+			list_node->iniface[0] = '\0';
+			list_add_tail(&list_node->list,&ipt2aclTbl->chainList[RTL865x_CHAINLIST_PRIORITY_LEVEL_4]);
+		}
 	}
-	m->u.kernel.match = match;
-
-	ret = check_match(m, par, i);
-	if (ret)
-		goto err;
 
 	return 0;
-err:
-	module_put(m->u.kernel.match->me);
+
+next:	
 	return ret;
 }
 
-static int check_target(struct ipt_entry *e, const char *name)
+static int rtl865x_free_chain_inIpt2Acl_tbl(struct list_head *listHead)
 {
-	struct ipt_entry_target *t = ipt_get_target(e);
-	struct xt_tgchk_param par = {
-		.table     = name,
-		.entryinfo = e,
-		.target    = t->u.kernel.target,
-		.targinfo  = t->data,
-		.hook_mask = e->comefrom,
-		.family    = NFPROTO_IPV4,
-	};
-	int ret;
-
-	ret = xt_check_target(&par, t->u.target_size - sizeof(*t),
-	      e->ip.proto, e->ip.invflags & IPT_INV_PROTO);
-	if (ret < 0) {
-		duprintf("ip_tables: check failed for `%s'.\n",
-			 t->u.kernel.target->name);
-		return ret;
+	/*free all xtmatch rule*/
+	xt_rule_to_acl_t *match2acl,*nxt;
+	list_for_each_entry_safe(match2acl,nxt,listHead,list)
+	{
+		list_del(&match2acl->list);
+		kfree(match2acl->aclRule);
+		kfree(match2acl);			
 	}
+
 	return 0;
 }
 
-static int
-find_check_entry(struct ipt_entry *e, const char *name, unsigned int size,
-		 unsigned int *i)
+static int rtl865x_free_allchains_inIpt2Acl_tbl(char *name)
 {
-	struct ipt_entry_target *t;
-	struct xt_target *target;
-	int ret;
-	unsigned int j;
-	struct xt_mtchk_param mtpar;
+	rtl865x_iptRule2Acl_tbl *ipt2aclTbl = NULL;
+	int i;
 
-	ret = check_entry(e, name);
-	if (ret)
-		return ret;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	if (!memcmp(name, RTL865X_QOS_TABLE_NAME, RTL865X_QOS_TABLE_LEN))
+	{
+		rtl865x_qosFlushMarkRule();
+	}
+#endif
 
-	j = 0;
-	mtpar.table     = name;
-	mtpar.entryinfo = &e->ip;
-	mtpar.hook_mask = e->comefrom;
-	mtpar.family    = NFPROTO_IPV4;
-	ret = IPT_MATCH_ITERATE(e, find_check_match, &mtpar, &j);
-	if (ret != 0)
-		goto cleanup_matches;
+	ipt2aclTbl = rtl865x_get_ipt2Acl_tbl(name);
 
-	t = ipt_get_target(e);
-	target = try_then_request_module(xt_find_target(AF_INET,
-							t->u.user.name,
-							t->u.user.revision),
-					 "ipt_%s", t->u.user.name);
-	if (IS_ERR(target) || !target) {
-		duprintf("find_check_entry: `%s' not found\n", t->u.user.name);
-		ret = target ? PTR_ERR(target) : -ENOENT;
-		goto cleanup_matches;
-	}
-	t->u.kernel.target = target;
+	if(!ipt2aclTbl)
+		return -1;
 
-	ret = check_target(e, name);
-	if (ret)
-		goto err;
+	for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+	{
+		rtl865x_free_chain_inIpt2Acl_tbl(&ipt2aclTbl->chainList[i]);
+	}
 
-	(*i)++;
 	return 0;
- err:
-	module_put(t->u.kernel.target->me);
- cleanup_matches:
-	IPT_MATCH_ITERATE(e, cleanup_match, &j);
-	return ret;
 }
 
-static int
-check_entry_size_and_hooks(struct ipt_entry *e,
-			   struct xt_table_info *newinfo,
-			   unsigned char *base,
-			   unsigned char *limit,
-			   const unsigned int *hook_entries,
-			   const unsigned int *underflows,
-			   unsigned int *i)
+void rtl865x_rearrange_ipt2Acl_tbl(char *name)
 {
-	unsigned int h;
+	rtl865x_iptRule2Acl_tbl *ipt2aclTbl;
+	xt_rule_to_acl_t *match2acl;
+	int i,retval;
 
-	if ((unsigned long)e % __alignof__(struct ipt_entry) != 0
-	    || (unsigned char *)e + sizeof(struct ipt_entry) >= limit) {
-		duprintf("Bad offset %p\n", e);
-		return -EINVAL;
-	}
+	//hyking:since default permit before rearrange rules to acl table,don't add permit acl now.
+	//rtl865x_add_def_permit_acl();
 
-	if (e->next_offset
-	    < sizeof(struct ipt_entry) + sizeof(struct ipt_entry_target)) {
-		duprintf("checking: element %p size %u\n",
-			 e, e->next_offset);
-		return -EINVAL;
+	list_for_each_entry(ipt2aclTbl,&rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		/*firstly, remove all acl which is add by user...*/
+		rtl865x_flush_allAcl_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_INGRESS);
+		rtl865x_flush_allAcl_fromChain(NULL,ipt2aclTbl->priority,RTL865X_ACL_EGRESS);
+		
+		for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+		{
+			list_for_each_entry(match2acl,&ipt2aclTbl->chainList[i],list)
+			{			
+				retval = rtl865x_add_acl(match2acl->aclRule, match2acl->iniface, ipt2aclTbl->priority);
+			}
+		}
 	}
 
-	/* Check hooks & underflows */
-	for (h = 0; h < NF_INET_NUMHOOKS; h++) {
-		if ((unsigned char *)e - base == hook_entries[h])
-			newinfo->hook_entry[h] = hook_entries[h];
-		if ((unsigned char *)e - base == underflows[h])
-			newinfo->underflow[h] = underflows[h];
+	//rtl865x_del_def_permit_acl();
 	}
 
-	/* FIXME: underflows must be unconditional, standard verdicts
-	   < 0 (not IPT_RETURN). --RR */
 
-	/* Clear counters and comefrom */
-	e->counters = ((struct xt_counters) { 0, 0 });
-	e->comefrom = 0;
+/*
+	tbl->priority: the minimum has highest priority
+*/
+int rtl865x_register_ipt2Acl_tbl(rtl865x_iptRule2Acl_tbl *tbl)
+{
+	rtl865x_iptRule2Acl_tbl *node,*insPos;
 
-	(*i)++;
-	return 0;
-}
+	insPos = NULL;	
+	node = NULL;
 
-static int
-cleanup_entry(struct ipt_entry *e, unsigned int *i)
+	node = rtl865x_get_ipt2Acl_tbl(tbl->tblName);
+	if(node != NULL)
+		return -1;
+	
+	list_for_each_entry(node,&rtl865x_iptRule2Acl_tbl_list,list)
 {
-	struct xt_tgdtor_param par;
-	struct ipt_entry_target *t;
+		if(node->priority > tbl->priority)
+		{
+			insPos = node;
+			break;
+		}
+	}
 
-	if (i && (*i)-- == 0)
-		return 1;
+	/*now, insert before the insPos*/
+	if(insPos)
+	{
+		list_add(&tbl->list, insPos->list.prev);
+	}
+	else
+	{
+		list_add_tail(&tbl->list, &rtl865x_iptRule2Acl_tbl_list);
+	}
 
-	/* Cleanup all matches */
-	IPT_MATCH_ITERATE(e, cleanup_match, NULL);
-	t = ipt_get_target(e);
+	return 0;
+}
 
-	par.target   = t->u.kernel.target;
-	par.targinfo = t->data;
-	par.family   = NFPROTO_IPV4;
-	if (par.target->destroy != NULL)
-		par.target->destroy(&par);
-	module_put(par.target->me);
+int rtl865x_unregister_ipt2Acl_tbl(char *tblName)
+{
+	rtl865x_iptRule2Acl_tbl *listNode,*nxt;
+	int i;
+	list_for_each_entry_safe(listNode, nxt, &rtl865x_iptRule2Acl_tbl_list,list)
+	{
+		if(memcmp(listNode->tblName,tblName,strlen(tblName)) == 0)
+		{
+			list_del(&listNode->list);
+			for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+				rtl865x_free_chain_inIpt2Acl_tbl(&listNode->chainList[i]);
+			kfree(listNode);
 	return 0;
 }
+	}
+
+	return -1;
+}
+
+#endif
+
 
 /* Checks and translates the user-supplied table segment (held in
    newinfo) */
@@ -793,10 +1943,8 @@
 {
 	unsigned int i;
 	int ret;
-
 	newinfo->size = size;
 	newinfo->number = number;
-
 	/* Init all hooks to impossible value. */
 	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
 		newinfo->hook_entry[i] = 0xFFFFFFFF;
@@ -820,7 +1968,6 @@
 			 i, number);
 		return -EINVAL;
 	}
-
 	/* Check hooks all assigned */
 	for (i = 0; i < NF_INET_NUMHOOKS; i++) {
 		/* Only hooks which are valid */
@@ -837,27 +1984,67 @@
 			return -EINVAL;
 		}
 	}
-
 	if (!mark_source_chains(newinfo, valid_hooks, entry0))
 		return -ELOOP;
-
 	/* Finally, each sanity check must pass */
 	i = 0;
 	ret = IPT_ENTRY_ITERATE(entry0, newinfo->size,
 				find_check_entry, name, size, &i);
-
 	if (ret != 0) {
 		IPT_ENTRY_ITERATE(entry0, newinfo->size,
 				cleanup_entry, &i);
 		return ret;
 	}
+	#if defined(CONFIG_RTL_819X)
+	rtl_translate_table_hooks(name,valid_hooks,newinfo,entry0,size,number,hook_entries,underflows);
+	#endif
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	{
+		rtl865x_iptRule2Acl_tbl *tbl;
+		int i,ret;
+		int32_t priority;
+		
+		if(memcmp(name,"filter",strlen("filter")) == 0)
+			priority = RTL865X_ACL_USER_USED;
+#if  defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		else if(memcmp(name,RTL865X_QOS_TABLE_NAME,RTL865X_QOS_TABLE_LEN) == 0)
+			priority = RTL865X_ACL_QOS_USED2;
+#endif
+		else
+			priority = 1024;
+
+		if(priority < 1024)
+		{
+			tbl = kmalloc(sizeof(rtl865x_iptRule2Acl_tbl), GFP_KERNEL);
+			if(!tbl)
+				return 0;
+			memset(tbl, 0, sizeof(rtl865x_iptRule2Acl_tbl));
+			for(i = 0; i < RTL865X_CHAINLIST_NUMBER_PER_TBL; i++)
+			{
+				INIT_LIST_HEAD(&tbl->chainList[i]);
+			}
+			tbl->priority = priority;
+			memcpy(tbl->tblName,name,strlen(name));
+			tbl->tblName[strlen(name)] = '\0';
+
+			ret = rtl865x_register_ipt2Acl_tbl(tbl);
 
+			if(ret != 0)
+			{
+				kfree(tbl);
+			}			
+		}		
+	}
+#endif
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	translate_ipTblRules2Acl(name,valid_hooks,newinfo,entry0,size,number,hook_entries,underflows);
+#endif
 	/* And one copy for every other CPU */
 	for_each_possible_cpu(i) {
 		if (newinfo->entries[i] && newinfo->entries[i] != entry0)
 			memcpy(newinfo->entries[i], entry0, newinfo->size);
 	}
-
 	return ret;
 }
 
@@ -1286,7 +2473,11 @@
 		ret = -EFAULT;
 		goto free_newinfo;
 	}
-
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	/*firstly, free all iptblAcl which added last time*/
+	establish_rule_permit = 0;
+	rtl865x_free_allchains_inIpt2Acl_tbl(tmp.name);
+#endif
 	ret = translate_table(tmp.name, tmp.valid_hooks,
 			      newinfo, loc_cpu_entry, tmp.size, tmp.num_entries,
 			      tmp.hook_entry, tmp.underflow);
@@ -1299,11 +2490,23 @@
 			   tmp.num_counters, tmp.counters);
 	if (ret)
 		goto free_newinfo_untrans;
+	
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	//rtl865x_rearrange_iptblAcl();
+	//rtl865x_print_iptRule2Acl_tbl();
+	rtl865x_rearrange_ipt2Acl_tbl(tmp.name);
+#endif
+
 	return 0;
 
  free_newinfo_untrans:
 	IPT_ENTRY_ITERATE(loc_cpu_entry, newinfo->size, cleanup_entry, NULL);
  free_newinfo:
+ 	
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	rtl865x_free_allchains_inIpt2Acl_tbl(tmp.name);
+#endif
+
 	xt_free_table_info(newinfo);
 	return ret;
 }
@@ -2154,6 +3357,50 @@
 	return !(icmpinfo->invflags & ~IPT_ICMP_INV);
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int icmp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+	const struct ipt_ip *ip_info = (struct ipt_ip *) ip;
+	const struct ipt_icmp *icmpinfo = matchinfo;
+	unsigned int code_range = 0;
+	int i = 0;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+	
+
+	if(ip == NULL || matchinfo == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_ICMP;
+	rule->srcIpAddr_ 		= ip_info->src.s_addr;
+	rule->srcIpAddrMask_	= ip_info->smsk.s_addr;
+	rule->dstIpAddr_		= ip_info->dst.s_addr;
+	rule->dstIpAddrMask_	= ip_info->dmsk.s_addr;
+
+	rule->icmpType_ 	= icmpinfo->type;
+	rule->icmpTypeMask_ 	= 0xff;
+	//rule->icmpCode_	= icmpinfo->code;
+	code_range = icmpinfo->code[1] - icmpinfo->code[0];
+	for(i = 0; i <8 ; i++)
+	{
+		if(code_range >> i)
+			continue;
+		break;
+	}
+	rule->icmpCode_	= icmpinfo->code[0];
+	rule->icmpCodeMask_ = 0xff << i;
+
+	if(icmpinfo->invflags & IPT_ICMP_INV)
+		if(invflags)
+			*invflags = 1;	
+	
+	return 0;
+}
+#endif
 /* The built-in targets: standard (NULL) and error. */
 static struct xt_target ipt_standard_target __read_mostly = {
 	.name		= IPT_STANDARD_TARGET,
@@ -2197,6 +3444,9 @@
 	.checkentry	= icmp_checkentry,
 	.proto		= IPPROTO_ICMP,
 	.family		= AF_INET,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	.match2acl	= icmp_match2acl,
+#endif
 };
 
 static int __net_init ip_tables_net_init(struct net *net)
@@ -2238,6 +3488,14 @@
 	if (ret < 0)
 		goto err5;
 
+	#if defined(CONFIG_RTL_819X)
+	rtl_ip_tables_init_hooks();
+	#endif
+	
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+		IgmpRxFilter_Hook = ipt_do_table;
+#endif
+
 	printk(KERN_INFO "ip_tables: (C) 2000-2006 Netfilter Core Team\n");
 	return 0;
 
@@ -2262,6 +3520,10 @@
 	xt_unregister_target(&ipt_standard_target);
 
 	unregister_pernet_subsys(&ip_tables_net_ops);
+
+#if defined (CONFIG_RTL_IGMP_SNOOPING) && defined (CONFIG_NETFILTER)
+	IgmpRxFilter_Hook = NULL;
+#endif
 }
 
 EXPORT_SYMBOL(ipt_register_table);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/ipt_MASQUERADE.c linux-2.6.30.9-rsdk/net/ipv4/netfilter/ipt_MASQUERADE.c
--- linux-2.6.30.9/net/ipv4/netfilter/ipt_MASQUERADE.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/ipt_MASQUERADE.c	2011-12-05 15:50:14.000000000 +0000
@@ -23,6 +23,15 @@
 #include <linux/netfilter_ipv4.h>
 #include <linux/netfilter/x_tables.h>
 
+
+#if defined (CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+#include <net/rtl/rtl865x_localPublic.h>
+#endif
+
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
 MODULE_DESCRIPTION("Xtables: automatic-address SNAT");
@@ -73,12 +82,33 @@
 
 	mr = par->targinfo;
 	rt = skb->rtable;
+#if 0
 	newsrc = inet_select_addr(par->out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
 	if (!newsrc) {
 		printk("MASQUERADE: %s ate my IP address\n", par->out->name);
 		return NF_DROP;
 	}
-
+#endif
+#if defined (CONFIG_RTL_LOCAL_PUBLIC)
+	if(skb->srcLocalPublicIp!=0)
+	{
+		newsrc=skb->srcLocalPublicIp;
+	}
+	else
+	{
+		newsrc = inet_select_addr(par->out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
+		if (!newsrc) {
+			printk("MASQUERADE: %s ate my IP address\n", par->out->name);
+			return NF_DROP;
+		}
+	}
+#else
+	newsrc = inet_select_addr(par->out, rt->rt_gateway, RT_SCOPE_UNIVERSE);
+	if (!newsrc) {
+		printk("MASQUERADE: %s ate my IP address\n", par->out->name);
+		return NF_DROP;
+	}
+#endif
 	write_lock_bh(&masq_lock);
 	nat->masq_index = par->out->ifindex;
 	write_unlock_bh(&masq_lock);
@@ -125,6 +155,9 @@
 		nf_ct_iterate_cleanup(net, device_cmp,
 				      (void *)(long)dev->ifindex);
 	}
+	#if defined (CONFIG_RTL_819X)
+	rtl_masq_device_event_hooks(this, dev,event);
+	#endif
 
 	return NOTIFY_DONE;
 }
@@ -134,7 +167,16 @@
 			   void *ptr)
 {
 	struct net_device *dev = ((struct in_ifaddr *)ptr)->ifa_dev->dev;
-	return masq_device_event(this, event, dev);
+	
+	if(event == NETDEV_DOWN)
+		masq_device_event(this, event, dev);
+
+	#if defined (CONFIG_RTL_819X)
+	rtl_masq_inet_event_hooks(this, event,  ptr);
+	#endif
+
+	return NOTIFY_DONE;
+
 }
 
 static struct notifier_block masq_dev_notifier = {
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/Makefile linux-2.6.30.9-rsdk/net/ipv4/netfilter/Makefile
--- linux-2.6.30.9/net/ipv4/netfilter/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -70,4 +70,6 @@
 obj-$(CONFIG_IP_NF_ARPFILTER) += arptable_filter.o
 
 obj-$(CONFIG_IP_NF_QUEUE) += ip_queue.o
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
 
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c
--- linux-2.6.30.9/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_conntrack_l3proto_ipv4.c	2011-12-05 15:50:14.000000000 +0000
@@ -188,7 +188,10 @@
 #if defined(CONFIG_SYSCTL) && defined(CONFIG_NF_CONNTRACK_PROC_COMPAT)
 static int log_invalid_proto_min = 0;
 static int log_invalid_proto_max = 255;
-
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+extern int conntrack_dointvec(ctl_table *table, int write, struct file *filp,
+		     void *buffer, size_t *lenp, loff_t *ppos);
+#endif
 static ctl_table ip_ct_sysctl_table[] = {
 	{
 		.ctl_name	= NET_IPV4_NF_CONNTRACK_MAX,
@@ -196,7 +199,11 @@
 		.data		= &nf_conntrack_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		.proc_handler	= &conntrack_dointvec,
+#else
 		.proc_handler	= proc_dointvec,
+#endif
 	},
 	{
 		.ctl_name	= NET_IPV4_NF_CONNTRACK_COUNT,
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/nf_nat_core.c linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_nat_core.c
--- linux-2.6.30.9/net/ipv4/netfilter/nf_nat_core.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_nat_core.c	2011-12-05 15:50:14.000000000 +0000
@@ -31,6 +31,15 @@
 #include <net/netfilter/nf_conntrack_l3proto.h>
 #include <net/netfilter/nf_conntrack_l4proto.h>
 
+#include <linux/inetdevice.h>
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl_nic.h>
+
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 static DEFINE_SPINLOCK(nf_nat_lock);
 
 static struct nf_conntrack_l3proto *l3proto __read_mostly;
@@ -265,13 +274,51 @@
 		proto->unique_tuple(tuple, range, maniptype, ct);
 		goto out;
 	}
+#if defined (CONFIG_RTL_HARDWARE_NAT)	&& defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)	
+	/* Only bother mapping if it's not already in range and unique */
+	if ((!(range->flags & IP_NAT_RANGE_PROTO_SPECIFIED) ||
+	     proto->in_range(tuple, maniptype, &range->min, &range->max)) &&
+	    !nf_nat_used_tuple(tuple, ct)) {
+		if(	(gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC) &&
+			((orig_tuple->dst.protonum==IPPROTO_TCP) ||(orig_tuple->dst.protonum==IPPROTO_UDP)))
+		{
+			unsigned int asicNaptHashScore=0;
+			rtl865x_napt_entry rtl865xNaptEntry;
+			
+			rtl865xNaptEntry.protocol = (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum==IPPROTO_TCP)? 1: 0;
+		
+			rtl865xNaptEntry.intIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+			rtl865xNaptEntry.remIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+			rtl865xNaptEntry.extIp = tuple->src.u3.ip;
+			rtl865xNaptEntry.intPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
+			rtl865xNaptEntry.remPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.udp.port;
+			rtl865xNaptEntry.extPort = rtl865xNaptEntry.protocol?tuple->src.u.tcp.port:tuple->src.u.udp.port;
+			
+			rtl865x_getAsicNaptHashScore(&rtl865xNaptEntry, &asicNaptHashScore);
+			/*
+			printk("%s:%d:maniptype is %d,%s (%u.%u.%u.%u:%u ->  %u.%u.%u.%u:%u ->%u.%u.%u.%u:%u),asicNaptHashScore is %d\n\n\n",
+				__FUNCTION__,__LINE__,maniptype, proto?"tcp":"udp", 
+				NIPQUAD(sip), sp, NIPQUAD(gip), gp, NIPQUAD(dip), dp,asicNaptHashScore);	
+			*/
+			if(asicNaptHashScore==100)
+			{
+				rtl865x_preReserveConn(&rtl865xNaptEntry);
+				goto out;
+			}
 
+		}
+		else
+		{
+			goto out;
+		}
+	}
+#else
 	/* Only bother mapping if it's not already in range and unique */
 	if ((!(range->flags & IP_NAT_RANGE_PROTO_SPECIFIED) ||
 	     proto->in_range(tuple, maniptype, &range->min, &range->max)) &&
 	    !nf_nat_used_tuple(tuple, ct))
 		goto out;
-
+#endif	
 	/* Last change: get protocol to try to obtain unique tuple. */
 	proto->unique_tuple(tuple, range, maniptype, ct);
 out:
@@ -309,7 +356,6 @@
 	   conntrack->tuplehash[IP_CT_DIR_ORIGINAL].tuple) */
 	nf_ct_invert_tuplepr(&curr_tuple,
 			     &ct->tuplehash[IP_CT_DIR_REPLY].tuple);
-
 	get_unique_tuple(&new_tuple, &curr_tuple, range, ct, maniptype);
 
 	if (!nf_ct_tuple_equal(&new_tuple, &curr_tuple)) {
@@ -394,6 +440,9 @@
 	enum ip_conntrack_dir dir = CTINFO2DIR(ctinfo);
 	unsigned long statusbit;
 	enum nf_nat_manip_type mtype = HOOK2MANIP(hooknum);
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	if (mtype == IP_NAT_MANIP_SRC)
 		statusbit = IPS_SRC_NAT;
@@ -413,6 +462,14 @@
 
 		if (!manip_pkt(target.dst.protonum, skb, 0, &target, mtype))
 			return NF_DROP;
+
+		#if defined(CONFIG_RTL_819X)
+		conn_info.ct = ct;
+		conn_info.skb = skb;
+		conn_info.hooknum = hooknum;
+		conn_info.ctinfo = ctinfo;
+		rtl_nf_nat_packet_hooks(&conn_info);
+		#endif
 	}
 	return NF_ACCEPT;
 }
@@ -750,6 +807,11 @@
 	BUG_ON(nfnetlink_parse_nat_setup_hook != NULL);
 	rcu_assign_pointer(nfnetlink_parse_nat_setup_hook,
 			   nfnetlink_parse_nat_setup);
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_nat_init_hooks();
+	#endif
+
 	return 0;
 
  cleanup_extend:
@@ -759,6 +821,11 @@
 
 static void __exit nf_nat_cleanup(void)
 {
+
+	#if defined(CONFIG_RTL_819X)
+	rtl_nat_cleanup_hooks();
+	#endif
+
 	unregister_pernet_subsys(&nf_nat_net_ops);
 	nf_ct_l3proto_put(l3proto);
 	nf_ct_extend_unregister(&nat_extend);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/netfilter/nf_nat_proto_common.c linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_nat_proto_common.c
--- linux-2.6.30.9/net/ipv4/netfilter/nf_nat_proto_common.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/netfilter/nf_nat_proto_common.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,6 +17,13 @@
 #include <net/netfilter/nf_nat_rule.h>
 #include <net/netfilter/nf_nat_protocol.h>
 
+#if defined (CONFIG_RTL_LAYERED_DRIVER) && defined (CONFIG_RTL_LAYERED_DRIVER_L4) && defined (CONFIG_RTL_HARDWARE_NAT)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_nat.h>
+#endif
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)	
+extern __DRAM_GEN int gHwNatEnabled;
+#endif
 bool nf_nat_proto_in_range(const struct nf_conntrack_tuple *tuple,
 			   enum nf_nat_manip_type maniptype,
 			   const union nf_conntrack_man_proto *min,
@@ -43,6 +50,15 @@
 	unsigned int range_size, min, i;
 	__be16 *portptr;
 	u_int16_t off;
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE)	
+	unsigned int tryCnt=0;
+	rtl865x_napt_entry rtl865xNaptEntry;
+	unsigned int asicNaptHashScore=0;
+	unsigned int highestScore=0;
+	unsigned int lowestScore=0;
+	__be16 bestCandidatePort=0;
+	__be16 newOff=0;
+#endif
 
 	if (maniptype == IP_NAT_MANIP_SRC)
 		portptr = &tuple->src.u.all;
@@ -81,6 +97,98 @@
 	else
 		off = *rover;
 
+#if defined (CONFIG_RTL_HARDWARE_NAT) && defined (CONFIG_RTL_INBOUND_COLLISION_AVOIDANCE) 
+if(ct->master || (ct->status & IPS_EXPECTED)){
+	for (i = 0; i < range_size; i++, off++) {
+		*portptr = htons(min + off % range_size);
+		if (nf_nat_used_tuple(tuple, ct))
+			continue;
+		if (!(range->flags & IP_NAT_RANGE_PROTO_RANDOM))
+			*rover = off;
+		return true;
+	}
+}else
+{	
+	for (i = 0; i < range_size; i++) {
+		if(gHwNatEnabled) 
+		{
+			rtl865x_optimizeExtPort(off++, range_size, &newOff);		
+			*portptr = htons(min + newOff % range_size);
+		}
+		else
+		{
+			*portptr = htons(min + off % range_size);
+			off++;
+		}
+		
+		if (nf_nat_used_tuple(tuple, ct))
+			continue;
+		
+		if((gHwNatEnabled) && (maniptype==IP_NAT_MANIP_SRC))
+		{
+			/* outbound flow */
+			rtl865xNaptEntry.protocol = (ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.protonum==IPPROTO_TCP)? 1: 0;
+			rtl865xNaptEntry.intIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u3.ip;
+			rtl865xNaptEntry.remIp = ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u3.ip;
+			rtl865xNaptEntry.extIp = tuple->src.u3.ip;
+			rtl865xNaptEntry.intPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.src.u.udp.port;
+			rtl865xNaptEntry.remPort = rtl865xNaptEntry.protocol?ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.tcp.port:ct->tuplehash[IP_CT_DIR_ORIGINAL].tuple.dst.u.udp.port;
+			rtl865xNaptEntry.extPort= rtl865xNaptEntry.protocol?tuple->src.u.tcp.port:tuple->src.u.udp.port;
+			
+			rtl865x_getAsicNaptHashScore(&rtl865xNaptEntry,&asicNaptHashScore);
+	
+			if(asicNaptHashScore==100)
+			{
+				highestScore=asicNaptHashScore;
+				lowestScore=asicNaptHashScore;
+				bestCandidatePort=*portptr; 
+			}
+			else
+			{
+				/*otherwise use the best cadidate port*/
+				if(bestCandidatePort==0)
+				{
+					bestCandidatePort=*portptr;
+					highestScore=asicNaptHashScore;
+					lowestScore=asicNaptHashScore;
+				}
+				
+				if(asicNaptHashScore>highestScore)
+				{
+					highestScore=asicNaptHashScore;
+					bestCandidatePort=*portptr; 
+				}
+
+				if(asicNaptHashScore<lowestScore)
+				{
+					lowestScore=asicNaptHashScore;
+				}
+				
+				if(tryCnt++<=MAX_EXTPORT_TRY_CNT)
+				{
+					continue;
+				}	
+				else
+				{
+					*portptr=bestCandidatePort; 
+				}
+			}
+
+			rtl865xNaptEntry.extPort=*portptr;
+			rtl865x_preReserveConn(&rtl865xNaptEntry);
+		}
+/*
+			printk("%s:%d:maniptype is %d, %s (%u.%u.%u.%u:%u -> %u.%u.%u.%u:%u -> %u.%u.%u.%u:%u) ,lowestScore is %d,highestScore is %d\n\n\n",
+			__FUNCTION__,__LINE__,maniptype, rtl865xNaptEntry.protocol?"tcp":"udp", 
+			NIPQUAD(rtl865xNaptEntry.intIp), rtl865xNaptEntry.intPort, NIPQUAD(rtl865xNaptEntry.extIp), rtl865xNaptEntry.extPort, NIPQUAD(rtl865xNaptEntry.remIp), rtl865xNaptEntry.remPort,lowestScore, highestScore);	
+*/
+
+		if (!(range->flags & IP_NAT_RANGE_PROTO_RANDOM))
+			*rover = off;
+		return true;
+	}
+}	
+#else
 	for (i = 0; i < range_size; i++, off++) {
 		*portptr = htons(min + off % range_size);
 		if (nf_nat_used_tuple(tuple, ct))
@@ -89,6 +197,7 @@
 			*rover = off;
 		return true;
 	}
+#endif
 	return false;
 }
 EXPORT_SYMBOL_GPL(nf_nat_proto_unique_tuple);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/route.c linux-2.6.30.9-rsdk/net/ipv4/route.c
--- linux-2.6.30.9/net/ipv4/route.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/route.c	2011-12-05 15:50:14.000000000 +0000
@@ -113,11 +113,15 @@
 
 #define IP_MAX_MTU	0xFFF0
 
-#define RT_GC_TIMEOUT (300*HZ)
+//#define RT_GC_TIMEOUT (300*HZ)
+#define RT_GC_TIMEOUT (60*HZ)
+
+//static int ip_rt_max_size;
+int ip_rt_max_size;
 
-static int ip_rt_max_size;
 static int ip_rt_gc_timeout __read_mostly	= RT_GC_TIMEOUT;
-static int ip_rt_gc_interval __read_mostly	= 60 * HZ;
+//static int ip_rt_gc_interval __read_mostly	= 60 * HZ;
+static int ip_rt_gc_interval __read_mostly	= 12 * HZ;
 static int ip_rt_gc_min_interval __read_mostly	= HZ / 2;
 static int ip_rt_redirect_number __read_mostly	= 9;
 static int ip_rt_redirect_load __read_mostly	= HZ / 50;
@@ -129,7 +133,8 @@
 static int ip_rt_min_pmtu __read_mostly		= 512 + 20 + 20;
 static int ip_rt_min_advmss __read_mostly	= 256;
 static int ip_rt_secret_interval __read_mostly	= 10 * 60 * HZ;
-static int rt_chain_length_max __read_mostly	= 20;
+//static int rt_chain_length_max __read_mostly	= 20;
+static int rt_chain_length_max __read_mostly	= 128;
 
 static void rt_worker_func(struct work_struct *work);
 static DECLARE_DELAYED_WORK(expires_work, rt_worker_func);
@@ -639,7 +644,10 @@
 	int ret = 0;
 
 	if (atomic_read(&rth->u.dst.__refcnt))
+	{
+		//printk("---%s(%d),src(0x%x),dst(0x%x),refcnt(%d)\n",__FUNCTION__,__LINE__,rth->fl.fl4_src,rth->fl.fl4_dst,rth->u.dst.__refcnt);
 		goto out;
+	}
 
 	ret = 1;
 	if (rth->u.dst.expires &&
@@ -929,6 +937,66 @@
 	rt_secret_rebuild_oneshot(net);
 }
 
+//hyking:dst garbage collect for memory size issue
+#if  0 //defined(CONFIG_RTL_819X)
+extern struct dst_gc dst_garbage;
+static inline void rt_cache_clean(int count) 
+{
+      struct dst_entry * dst, **dstp;
+	 struct rtable *rt;
+	int refcnt_gc,colcnt_gc;
+	refcnt_gc = colcnt_gc = 0;
+	spin_lock_bh(&dst_garbage.lock);
+      if(dst_garbage.list != NULL){
+		dstp = &dst_garbage.list;
+		while ((dst = *dstp) != NULL) {
+			*dstp = dst->next;
+			if(atomic_read(&dst->__refcnt))
+			{
+				refcnt_gc++;
+				rt = (struct rtable*)dst;
+				if(net_ratelimit())
+					printk("------%s(%d),dst refcnt(%d),sip(%u.%u.%u.%u),dip(%u.%u.%u.%u)\n",__FUNCTION__,__LINE__,atomic_read(&dst->__refcnt),
+					NIPQUAD(rt->rt_src),NIPQUAD(rt->rt_dst));
+			}
+			else
+			{
+				colcnt_gc++;
+				dst_destroy(dst);
+			}
+		}
+	}
+	spin_unlock_bh(&dst_garbage.lock);
+	if(net_ratelimit())
+		printk("--------%s(%d),refcnt(%d),collcnt(%d),dst cache(%d)\n",__FUNCTION__,__LINE__,refcnt_gc,colcnt_gc,atomic_read(&ipv4_dst_ops.entries));
+}
+static void rtl_cache_count(void)
+{
+	  struct dst_entry * dst, **dstp;
+	int refcnt_gc,colcnt_gc;
+
+	refcnt_gc = colcnt_gc = 0;	
+	spin_lock_bh(&dst_garbage.lock);
+	  if(dst_garbage.list != NULL){
+		dstp = &dst_garbage.list;
+		while ((dst = *dstp) != NULL) 
+		{
+			*dstp = dst->next;			
+			if(atomic_read(&dst->__refcnt))
+			{
+				refcnt_gc++;			
+			}
+			else
+			{
+				colcnt_gc++;
+			}
+		}
+	}
+	spin_unlock_bh(&dst_garbage.lock);
+	printk("--------%s(%d),refcnt(%d),collcnt(%d),dst cache(%d)\n",__FUNCTION__,__LINE__,refcnt_gc,colcnt_gc,atomic_read(&ipv4_dst_ops.entries));
+}
+#endif
+
 /*
    Short description of GC goals.
 
@@ -941,13 +1009,14 @@
    is idle expires is large enough to keep enough of warm entries,
    and when load increases it reduces to limit cache size.
  */
+//extern void dst_gc_task(struct work_struct *work);
 
 static int rt_garbage_collect(struct dst_ops *ops)
 {
 	static unsigned long expire = RT_GC_TIMEOUT;
-	static unsigned long last_gc;
-	static int rover;
-	static int equilibrium;
+	static unsigned long last_gc = 0;
+	static int rover = 0;
+	static int equilibrium = 0;
 	struct rtable *rth, **rthp;
 	unsigned long now = jiffies;
 	int goal;
@@ -966,6 +1035,7 @@
 	}
 
 	/* Calculate number of entries, which we want to expire now. */
+	//hyking:entries - 1 << 10
 	goal = atomic_read(&ipv4_dst_ops.entries) -
 		(ip_rt_gc_elasticity << rt_hash_log);
 	if (goal <= 0) {
@@ -1041,14 +1111,37 @@
 				atomic_read(&ipv4_dst_ops.entries), goal, i);
 #endif
 
+		if (atomic_read(&ipv4_dst_ops.entries) < (ip_rt_max_size))
+			goto out;
+#if 0 //defined(CONFIG_RTL_819X)
+		else
+		{
+			rt_cache_clean(ip_rt_max_size);
 		if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
 			goto out;
+		}
+#endif
 	} while (!in_softirq() && time_before_eq(jiffies, now));
 
 	if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
 		goto out;
+#if 0 //defined(CONFIG_RTL_819X)
+	else
+	{
+		rt_cache_clean(ip_rt_max_size);
+		if (atomic_read(&ipv4_dst_ops.entries) < ip_rt_max_size)
+			goto out;
+	}
+#endif
+
 	if (net_ratelimit())
+	{
+#if 0 //defined(CONFIG_RTL_819X)
+		rt_cache_clean(ip_rt_max_size);
+#endif
 		printk(KERN_WARNING "dst cache overflow\n");
+	}
+	
 	RT_CACHE_STAT_INC(gc_dst_overflow);
 	return 1;
 
@@ -2169,6 +2262,7 @@
 	RT_CACHE_STAT_INC(in_brd);
 
 local_input:
+//printk("=========%s(%d) ip_rt_max_size(%d),gc_thresh(%d),rt_hash_mask(%d)\n",__FUNCTION__,__LINE__,ip_rt_max_size,ipv4_dst_ops.gc_thresh,rt_hash_mask);
 	rth = dst_alloc(&ipv4_dst_ops);
 	if (!rth)
 		goto e_nobufs;
@@ -2244,6 +2338,50 @@
 	goto e_inval;
 }
 
+#if 0 //defined(CONFIG_RTL_819X)
+int ip_route_input_fast(struct sk_buff *skb, __be32 daddr, __be32 saddr,
+		   u8 tos, struct net_device *dev)
+{
+	struct rtable * rth;
+	unsigned	hash;
+	int iif = dev->ifindex;
+	struct net *net;
+
+	net = dev_net(dev);
+
+	if (!rt_caching(net))
+		goto skip_cache;
+
+	tos &= IPTOS_RT_MASK;
+	hash = rt_hash(daddr, saddr, iif, rt_genid(net));
+
+	rcu_read_lock();
+	for (rth = rcu_dereference(rt_hash_table[hash].chain); rth;
+	     rth = rcu_dereference(rth->u.dst.rt_next)) {
+		if (((rth->fl.fl4_dst ^ daddr) |
+		     (rth->fl.fl4_src ^ saddr) |
+		     (rth->fl.iif ^ iif) |
+		     rth->fl.oif |
+		     (rth->fl.fl4_tos ^ tos)) == 0 &&
+		    rth->fl.mark == skb->mark &&
+		    net_eq(dev_net(rth->u.dst.dev), net) &&
+		    !rt_is_expired(rth)) {
+			dst_use(&rth->u.dst, jiffies);
+			RT_CACHE_STAT_INC(in_hit);
+			rcu_read_unlock();
+			skb->rtable = rth;
+			return 0;
+		}
+		RT_CACHE_STAT_INC(in_hlist_search);
+	}
+	rcu_read_unlock();
+
+skip_cache:
+	return -EINVAL;
+	
+}
+#endif
+
 int ip_route_input(struct sk_buff *skb, __be32 daddr, __be32 saddr,
 		   u8 tos, struct net_device *dev)
 {
@@ -2300,6 +2438,12 @@
 		if ((in_dev = __in_dev_get_rcu(dev)) != NULL) {
 			int our = ip_check_mc(in_dev, daddr, saddr,
 				ip_hdr(skb)->protocol);
+#if defined (CONFIG_RTL_IGMP_PROXY) && defined (CONFIG_IP_MROUTE)
+			if(net->ipv4.mroute_sk)
+			{
+				our = 1;
+			}
+#endif
 			if (our
 #ifdef CONFIG_IP_MROUTE
 			    || (!ipv4_is_local_multicast(daddr) &&
@@ -3022,6 +3166,45 @@
 	rt_cache_flush(dev_net(in_dev->dev), 0);
 }
 
+#if 0
+int ipv4_dump_all_dst_cache(void)
+{
+	struct rtable *rth;
+	int hash;
+	int cnt;
+	//unsigned long flags;	
+	
+
+	cnt = 0;
+	//local_irq_save(flags);
+	for (hash = 0; hash <= rt_hash_mask; hash++)
+	{
+		if (!rt_hash_table[hash].chain)
+			continue;
+		
+		//printk("genid(%d),hash chain[%d]:\n",rt_genid(&init_net) ,hash);
+		//rcu_read_lock();
+		for (rth = (rt_hash_table[hash].chain); rth;
+			rth = (rth->u.dst.rt_next)) 
+		{
+			cnt++;
+			#if 0
+			printk("sip(%u.%u.%u.%u),dip(%u.%u.%u.%u),rt_genid(%d),dst->ops(0x%x),dst->hy1(0x%x),dst->refcnt(%d)\n",NIPQUAD(rth->rt_src),NIPQUAD(rth->rt_dst),rth->rt_genid,
+				rth->u.dst.ops,rth->u.dst.hyking_test1,atomic_read(&rth->u.dst.__refcnt));
+			
+			(*((volatile unsigned int *)(0xb800311c))) = 0x00e00000;
+			#endif
+		}
+		//rcu_read_unlock();
+	}
+
+	printk("total cnt = %d,ipv4_dst_ops.entries(%d),genid(%d)\n",cnt,atomic_read(&ipv4_dst_ops.entries),rt_genid(&init_net));
+	//local_irq_restore(flags);
+
+	rtl_cache_count();
+	return 0;
+}
+#endif
 #ifdef CONFIG_SYSCTL
 static int ipv4_sysctl_rtcache_flush(ctl_table *__ctl, int write,
 					struct file *filp, void __user *buffer,
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/tcp_ipv4.c linux-2.6.30.9-rsdk/net/ipv4/tcp_ipv4.c
--- linux-2.6.30.9/net/ipv4/tcp_ipv4.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/tcp_ipv4.c	2011-12-05 15:50:14.000000000 +0000
@@ -488,10 +488,17 @@
 		skb->csum_start = skb_transport_header(skb) - skb->head;
 		skb->csum_offset = offsetof(struct tcphdr, check);
 	} else {
+		//Hyking:fixme
+		//it's seem that the skb->csum is wrong
+		//fix it after....
+		#if 0
 		th->check = tcp_v4_check(len, inet->saddr, inet->daddr,
 					 csum_partial(th,
 						      th->doff << 2,
 						      skb->csum));
+		#endif		
+		__wsum tmp = csum_partial(th,len,0);
+		th->check = tcp_v4_check(len, inet->saddr, inet->daddr,tmp);		
 	}
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv4/udp.c linux-2.6.30.9-rsdk/net/ipv4/udp.c
--- linux-2.6.30.9/net/ipv4/udp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv4/udp.c	2011-12-05 15:50:14.000000000 +0000
@@ -93,6 +93,7 @@
 #include <linux/errno.h>
 #include <linux/timer.h>
 #include <linux/mm.h>
+#include <linux/config.h>
 #include <linux/inet.h>
 #include <linux/netdevice.h>
 #include <net/tcp_states.h>
@@ -103,6 +104,10 @@
 #include <net/icmp.h>
 #include <net/route.h>
 #include <net/checksum.h>
+#ifdef CONFIG_RTK_VOIP_MODULE
+#include <linux/module.h>
+#define CONFIG_RTK_VOIP
+#endif
 #include <net/xfrm.h>
 #include "udp_impl.h"
 
@@ -122,6 +127,21 @@
 
 #define PORTS_PER_CHAIN (65536 / UDP_HTABLE_SIZE)
 
+#ifdef CONFIG_RTK_VOIP
+void **udp_rtk_trap_profile_header = NULL;
+int (*udp_rtk_trap_hook)(struct sk_buff *skb) = NULL;
+#endif
+
+#ifdef CONFIG_RTK_VOIP_MODULE
+extern unsigned long __nat_speedup_start;
+extern unsigned long __imem_start;
+EXPORT_SYMBOL(__nat_speedup_start);
+EXPORT_SYMBOL(__imem_start);
+EXPORT_SYMBOL(udp_rtk_trap_profile_header);
+EXPORT_SYMBOL(udp_rtk_trap_hook);
+#endif
+
+
 static int udp_lib_lport_inuse(struct net *net, __u16 num,
 			       const struct udp_hslot *hslot,
 			       unsigned long *bitmap,
@@ -1265,6 +1285,16 @@
 	saddr = ip_hdr(skb)->saddr;
 	daddr = ip_hdr(skb)->daddr;
 
+#ifdef CONFIG_RTK_VOIP
+	if( udp_rtk_trap_profile_header != NULL 
+	    && *udp_rtk_trap_profile_header != NULL 
+	    && udp_rtk_trap_hook != NULL)
+       	{
+   		if ( udp_rtk_trap_hook(skb) == 0)
+			return 0;
+       	}
+#endif
+
 	if (rt->rt_flags & (RTCF_BROADCAST|RTCF_MULTICAST))
 		return __udp4_lib_mcast_deliver(net, skb, uh,
 				saddr, daddr, udptable);
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv6/addrconf.c linux-2.6.30.9-rsdk/net/ipv6/addrconf.c
--- linux-2.6.30.9/net/ipv6/addrconf.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv6/addrconf.c	2011-12-05 15:50:14.000000000 +0000
@@ -2325,6 +2325,13 @@
 		return;
 	}
 
+#if defined(CONFIG_RTL_IPV6READYLOGO)
+        if(!strcmp(dev->name,"eth0"))
+                return;
+        if(!strncmp(dev->name,"wlan",strlen("wlan")))
+                return;
+#endif
+
 	idev = addrconf_add_dev(dev);
 	if (idev == NULL)
 		return;
@@ -2786,7 +2793,91 @@
 out:
 	read_unlock_bh(&idev->lock);
 }
+#if defined(CONFIG_RTL_IPV6READYLOGO)
+#include <bridge/br_private.h>
+static int delay_flag=0;
+int check_lan_port_state(struct net_device *dev)
+{
+	struct net_device *sdev;
+	if(!(dev->br_port ) ) 
+	{
+		struct net *net = dev_net(dev);		
+		for_each_netdev(net, sdev)
+		{
+			if((sdev->br_port) && (!memcmp(sdev->name,"eth",3)))
+			{
+				if(!sdev->br_port) return 0;
+				return sdev->br_port->state;
+			}
+			continue;
+		}	        	
+	}
+	return 0;
+}
+
+static void addrconf_dad_timer(unsigned long data)
+{
+	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *) data;
+	struct inet6_dev *idev = ifp->idev;
+	struct in6_addr mcaddr;
+
+	read_lock_bh(&idev->lock);
+	if (idev->dead) {
+		read_unlock_bh(&idev->lock);
+		goto out;
+	}
+	spin_lock_bh(&ifp->lock);
+	
+	if(check_lan_port_state(idev->dev) != BR_STATE_FORWARDING)
+	{
+		if(!ifp->probes) ifp->probes=1;
+	}
+	else 
+	{
+		if(!delay_flag) 
+		{
+			if(!ifp->probes) ifp->probes=1;
+			delay_flag=1;
+		}
+	}   	
+	if (ifp->probes == 0) {
+		/*
+		 * DAD was successful
+		 */
+
+		ifp->flags &= ~(IFA_F_TENTATIVE|IFA_F_OPTIMISTIC);
+		spin_unlock_bh(&ifp->lock);
+		read_unlock_bh(&idev->lock);
+
+		addrconf_dad_completed(ifp);
+
+		goto out;
+	}
+	else
+	{
 
+		/* send a neighbour solicitation for our addr */		
+		if(delay_flag)
+		{
+			ifp->probes--;
+			addrconf_mod_timer(ifp, AC_DAD, 50);
+			spin_unlock_bh(&ifp->lock);
+			read_unlock_bh(&idev->lock);
+			addrconf_addr_solict_mult(&ifp->addr, &mcaddr);
+			ndisc_send_ns(ifp->idev->dev, NULL, &ifp->addr, &mcaddr, &in6addr_any);
+		}
+		else
+		{
+			ifp->probes--;
+			addrconf_mod_timer(ifp, AC_DAD, ifp->idev->nd_parms->retrans_time);
+			spin_unlock_bh(&ifp->lock);
+			read_unlock_bh(&idev->lock);
+		}
+	}
+out:
+	in6_ifa_put(ifp);
+}
+#else
 static void addrconf_dad_timer(unsigned long data)
 {
 	struct inet6_ifaddr *ifp = (struct inet6_ifaddr *) data;
@@ -2824,7 +2915,7 @@
 out:
 	in6_ifa_put(ifp);
 }
-
+#endif
 static void addrconf_dad_completed(struct inet6_ifaddr *ifp)
 {
 	struct net_device *	dev = ifp->idev->dev;
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv6/af_inet6.c linux-2.6.30.9-rsdk/net/ipv6/af_inet6.c
--- linux-2.6.30.9/net/ipv6/af_inet6.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv6/af_inet6.c	2011-12-05 15:50:14.000000000 +0000
@@ -294,10 +294,8 @@
 		    v4addr != htonl(INADDR_ANY) &&
 		    chk_addr_ret != RTN_LOCAL &&
 		    chk_addr_ret != RTN_MULTICAST &&
-		    chk_addr_ret != RTN_BROADCAST) {
-			err = -EADDRNOTAVAIL;
+		    chk_addr_ret != RTN_BROADCAST)
 			goto out;
-		}
 	} else {
 		if (addr_type != IPV6_ADDR_ANY) {
 			struct net_device *dev = NULL;
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv6/exthdrs.c linux-2.6.30.9-rsdk/net/ipv6/exthdrs.c
--- linux-2.6.30.9/net/ipv6/exthdrs.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv6/exthdrs.c	2011-12-05 15:50:14.000000000 +0000
@@ -378,6 +378,19 @@
 	}
 
 	switch (hdr->type) {
+#if defined(CONFIG_RTL_IPV6READYLOGO)	
+		case IPV6_SRCRT_TYPE_0:
+		//printk("[%s][%d]-[%p][offset=%x]\n", __FUNCTION__, __LINE__, (&hdr->nexthdr), (&hdr->nexthdr) - skb_network_header(skb));
+		if (hdr->hdrlen & 0x01) {
+			IP6_INC_STATS_BH(net, ip6_dst_idev(skb->dst),
+					 IPSTATS_MIB_INHDRERRORS);
+			//icmpv6_param_prob(skb, ICMPV6_HDR_FIELD, (&hdr->hdrlen) - skb->nh.raw);
+			icmpv6_param_prob(skb, ICMPV6_HDR_FIELD,
+			(&hdr->nexthdr) - skb_network_header(skb)+1);
+			return -1;
+		}
+		break;
+#endif		
 #if defined(CONFIG_IPV6_MIP6) || defined(CONFIG_IPV6_MIP6_MODULE)
 	case IPV6_SRCRT_TYPE_2:
 		if (accept_source_route < 0)
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv6/ip6_input.c linux-2.6.30.9-rsdk/net/ipv6/ip6_input.c
--- linux-2.6.30.9/net/ipv6/ip6_input.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv6/ip6_input.c	2011-12-05 15:50:14.000000000 +0000
@@ -139,9 +139,6 @@
 
 	rcu_read_unlock();
 
-	/* Must drop socket now because of tproxy. */
-	skb_orphan(skb);
-
 	return NF_HOOK(PF_INET6, NF_INET_PRE_ROUTING, skb, dev, NULL,
 		       ip6_rcv_finish);
 err:
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv6/Kconfig linux-2.6.30.9-rsdk/net/ipv6/Kconfig
--- linux-2.6.30.9/net/ipv6/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv6/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -20,7 +20,9 @@
 	  module will be called ipv6.
 
 if IPV6
-
+config RTL_IPV6READYLOGO 
+	bool "IPv6: ready logo patch"
+	default n
 config IPV6_PRIVACY
 	bool "IPv6: Privacy Extensions (RFC 3041) support"
 	---help---
diff -uNr --ignore-all-space linux-2.6.30.9/net/ipv6/Makefile linux-2.6.30.9-rsdk/net/ipv6/Makefile
--- linux-2.6.30.9/net/ipv6/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/ipv6/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -40,3 +40,4 @@
 obj-y += addrconf_core.o exthdrs_core.o
 
 obj-$(subst m,y,$(CONFIG_IPV6)) += inet6_hashtables.o
+EXTRA_CFLAGS += -I $(DIR_LINUX)/net/
diff -uNr --ignore-all-space linux-2.6.30.9/net/mac80211/main.c linux-2.6.30.9-rsdk/net/mac80211/main.c
--- linux-2.6.30.9/net/mac80211/main.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/mac80211/main.c	2011-12-05 15:50:14.000000000 +0000
@@ -633,7 +633,8 @@
 	rthdr = (struct ieee80211_tx_status_rtap_hdr *)
 				skb_push(skb, sizeof(*rthdr));
 
-	memset(rthdr, 0, sizeof(*rthdr));
+        //by brian
+	memset(rthdr, 0, sizeof(*rthdr)-2);
 	rthdr->hdr.it_len = cpu_to_le16(sizeof(*rthdr));
 	rthdr->hdr.it_present =
 		cpu_to_le32((1 << IEEE80211_RADIOTAP_TX_FLAGS) |
diff -uNr --ignore-all-space linux-2.6.30.9/net/mac80211/rx.c linux-2.6.30.9-rsdk/net/mac80211/rx.c
--- linux-2.6.30.9/net/mac80211/rx.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/mac80211/rx.c	2011-12-05 15:50:14.000000000 +0000
@@ -1389,7 +1389,8 @@
 	if (skb) {
 		int align __maybe_unused;
 
-#if defined(CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT) || !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+//#if defined(CONFIG_MAC80211_DEBUG_PACKET_ALIGNMENT) || !defined(CONFIG_HAVE_EFFICIENT_UNALIGNED_ACCESS)
+#if 0
 		/*
 		 * 'align' will only take the values 0 or 2 here
 		 * since all frames are required to be aligned
diff -uNr --ignore-all-space linux-2.6.30.9/net/Makefile linux-2.6.30.9-rsdk/net/Makefile
--- linux-2.6.30.9/net/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -65,3 +65,11 @@
 obj-$(CONFIG_SYSCTL)		+= sysctl_net.o
 endif
 obj-$(CONFIG_WIMAX)		+= wimax/
+
+ifeq ($(CONFIG_RTL_IPTABLES_FAST_PATH),y)
+obj-$(CONFIG_RTL_IPTABLES_FAST_PATH) += rtl/fastpath/
+endif
+ifeq ($(CONFIG_RTL_819X),y)
+obj-$(CONFIG_RTL_819X) += rtl/features/
+endif
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/ipvs/ip_vs_conn.c linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_conn.c
--- linux-2.6.30.9/net/netfilter/ipvs/ip_vs_conn.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_conn.c	2011-12-05 15:50:14.000000000 +0000
@@ -36,6 +36,10 @@
 #include <net/net_namespace.h>
 #include <net/ip_vs.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 
 /*
  *  Connection hash table: for input and output packets lookups of IPVS
@@ -614,8 +618,15 @@
 {
 	struct ip_vs_conn *cp = (struct ip_vs_conn *)data;
 
+
 	cp->timeout = 60*HZ;
 
+	#if defined (CONFIG_RTL_819X)  
+	if(rtl_ip_vs_conn_expire_hooks1(cp)==RTL_PS_HOOKS_RETURN) {
+		return;
+	}
+	#endif
+
 	/*
 	 *	hey, I'm using it
 	 */
@@ -645,6 +656,10 @@
 		if (cp->control)
 			ip_vs_control_del(cp);
 
+		#if defined (CONFIG_RTL_819X)  
+		rtl_ip_vs_conn_expire_hooks2(cp);
+		#endif
+
 		if (unlikely(cp->app != NULL))
 			ip_vs_unbind_app(cp);
 		ip_vs_unbind_dest(cp);
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/ipvs/ip_vs_proto_tcp.c linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_proto_tcp.c
--- linux-2.6.30.9/net/netfilter/ipvs/ip_vs_proto_tcp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_proto_tcp.c	2011-12-05 15:50:14.000000000 +0000
@@ -24,6 +24,9 @@
 
 #include <net/ip_vs.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
 
 static struct ip_vs_conn *
 tcp_conn_in_get(int af, const struct sk_buff *skb, struct ip_vs_protocol *pp,
@@ -576,12 +579,18 @@
 	int ihl = ip_hdrlen(skb);
 #endif
 
+
 	th = skb_header_pointer(skb, ihl, sizeof(_tcph), &_tcph);
 	if (th == NULL)
 		return 0;
 
 	spin_lock(&cp->lock);
 	set_tcp_state(pp, cp, direction, th);
+	
+#if defined (CONFIG_RTL_819X)
+	rtl_tcp_state_transition_hooks(cp, direction, skb, pp);
+#endif
+
 	spin_unlock(&cp->lock);
 
 	return 1;
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/ipvs/ip_vs_proto_udp.c linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_proto_udp.c
--- linux-2.6.30.9/net/netfilter/ipvs/ip_vs_proto_udp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/ip_vs_proto_udp.c	2011-12-05 15:50:14.000000000 +0000
@@ -23,6 +23,10 @@
 #include <net/ip_vs.h>
 #include <net/ip.h>
 #include <net/ip6_checksum.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 
 static struct ip_vs_conn *
 udp_conn_in_get(int af, const struct sk_buff *skb, struct ip_vs_protocol *pp,
@@ -494,7 +498,12 @@
 		     const struct sk_buff *skb,
 		     struct ip_vs_protocol *pp)
 {
+
+
 	cp->timeout = pp->timeout_table[IP_VS_UDP_S_NORMAL];
+#if defined (CONFIG_RTL_819X)	
+	rtl_udp_state_transition_hooks(cp, direction, skb, pp);
+#endif
 	return 1;
 }
 
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/ipvs/Makefile linux-2.6.30.9-rsdk/net/netfilter/ipvs/Makefile
--- linux-2.6.30.9/net/netfilter/ipvs/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/ipvs/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -31,3 +31,4 @@
 
 # IPVS application helpers
 obj-$(CONFIG_IP_VS_FTP) += ip_vs_ftp.o
+EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/Kconfig linux-2.6.30.9-rsdk/net/netfilter/Kconfig
--- linux-2.6.30.9/net/netfilter/Kconfig	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/Kconfig	2011-12-05 15:50:14.000000000 +0000
@@ -4,6 +4,14 @@
 config NETFILTER_NETLINK
 	tristate
 
+config RTL_NF_CONNTRACK_GARBAGE_NEW
+	bool "connection tracking garbage"
+	default n
+	help
+	  connection tracking garbage mechanism will release a
+	  connection tracking when not enough memory for create
+	  a new connection tracking.
+
 config NETFILTER_NETLINK_QUEUE
 	tristate "Netfilter NFQUEUE over NFNETLINK interface"
 	depends on NETFILTER_ADVANCED
@@ -706,6 +714,24 @@
 
 	  To compile it as a module, choose M here.  If unsure, say N.
 
+config NETFILTER_XT_MATCH_VLAN
+        tristate '"VLAN"  match support'
+        depends on NETFILTER_XTABLES
+        help
+          VLAN matching allows you to match packets based on the VLAN priority
+          of the packet.
+ 
+          To compile it as a module, choose M here.  If unsure, say N.
+
+config NETFILTER_XT_MATCH_PHYPORT
+        tristate '"Physical port"  match support'
+        depends on NETFILTER_XTABLES
+        help
+          Physical port matching allows you to match packets based on the phy port number
+          of the packet.
+ 
+          To compile it as a module, choose M here.  If unsure, say N.
+
 config NETFILTER_XT_MATCH_MARK
 	tristate '"mark" match support'
 	default m if NETFILTER_ADVANCED=n
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/Makefile linux-2.6.30.9-rsdk/net/netfilter/Makefile
--- linux-2.6.30.9/net/netfilter/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -93,6 +93,11 @@
 obj-$(CONFIG_NETFILTER_XT_MATCH_TCPMSS) += xt_tcpmss.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_TIME) += xt_time.o
 obj-$(CONFIG_NETFILTER_XT_MATCH_U32) += xt_u32.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_VLAN) += xt_vlanpriority.o
+obj-$(CONFIG_NETFILTER_XT_MATCH_PHYPORT) += xt_phyport.o
 
 # IPVS
 obj-$(CONFIG_IP_VS) += ipvs/
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/net/ipv4/fastpath/
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/nf_conntrack_core.c linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_core.c
--- linux-2.6.30.9/net/netfilter/nf_conntrack_core.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_core.c	2011-12-05 15:50:14.000000000 +0000
@@ -30,6 +30,9 @@
 #include <linux/socket.h>
 #include <linux/mm.h>
 #include <linux/rculist_nulls.h>
+#include <linux/ip.h>
+#include <linux/tcp.h>
+
 
 #include <net/netfilter/nf_conntrack.h>
 #include <net/netfilter/nf_conntrack_l3proto.h>
@@ -42,6 +45,10 @@
 #include <net/netfilter/nf_nat.h>
 #include <net/netfilter/nf_nat_core.h>
 
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 #define NF_CONNTRACK_VERSION	"0.5.0"
 
 int (*nfnetlink_parse_nat_setup_hook)(struct nf_conn *ct,
@@ -160,8 +167,8 @@
 }
 EXPORT_SYMBOL_GPL(nf_ct_invert_tuple);
 
-static void
-clean_from_lists(struct nf_conn *ct)
+#if !defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+static void clean_from_lists(struct nf_conn *ct)
 {
 	pr_debug("clean_from_lists(%p)\n", ct);
 	hlist_nulls_del_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode);
@@ -170,6 +177,7 @@
 	/* Destroy all pending expectations */
 	nf_ct_remove_expectations(ct);
 }
+#endif
 
 static void
 destroy_conntrack(struct nf_conntrack *nfct)
@@ -177,6 +185,9 @@
 	struct nf_conn *ct = (struct nf_conn *)nfct;
 	struct net *net = nf_ct_net(ct);
 	struct nf_conntrack_l4proto *l4proto;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	pr_debug("destroy_conntrack(%p)\n", ct);
 	NF_CT_ASSERT(atomic_read(&nfct->use) == 0);
@@ -189,11 +200,17 @@
 	/* To make sure we don't get any weird locking issues here:
 	 * destroy_conntrack() MUST NOT be called with a write lock
 	 * to nf_conntrack_lock!!! -HW */
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+
+	rtl_nf_conntrack_destroy_hooks(&conn_info);
+	#endif		
+
 	rcu_read_lock();
 	l4proto = __nf_ct_l4proto_find(nf_ct_l3num(ct), nf_ct_protonum(ct));
 	if (l4proto && l4proto->destroy)
 		l4proto->destroy(ct);
-
 	rcu_read_unlock();
 
 	spin_lock_bh(&nf_conntrack_lock);
@@ -223,9 +240,18 @@
 {
 	struct nf_conn *ct = (void *)ul_conntrack;
 	struct net *net = nf_ct_net(ct);
-	struct nf_conn_help *help = nfct_help(ct);
+	struct nf_conn_help *help;
 	struct nf_conntrack_helper *helper;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
 
+	conn_info.net = net;
+	conn_info.ct = ct;
+	if (RTL_PS_HOOKS_RETURN==rtl_nf_conntrack_death_by_timeout_hooks(&conn_info))
+		return;
+	#endif
+
+	help = nfct_help(ct);
 	if (help) {
 		rcu_read_lock();
 		helper = rcu_dereference(help->helper);
@@ -238,7 +264,12 @@
 	/* Inside lock so preempt is disabled on module removal path.
 	 * Otherwise we can get spurious warnings. */
 	NF_CT_STAT_INC(net, delete_list);
+	#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	clean_from_lists(ct, net);
+	#else
 	clean_from_lists(ct);
+	#endif
+
 	spin_unlock_bh(&nf_conntrack_lock);
 	nf_ct_put(ct);
 }
@@ -345,6 +376,9 @@
 	struct hlist_nulls_node *n;
 	enum ip_conntrack_info ctinfo;
 	struct net *net;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s		conn_info;
+	#endif
 
 	ct = nf_ct_get(skb, &ctinfo);
 	net = nf_ct_net(ct);
@@ -386,6 +420,14 @@
 	/* Remove from unconfirmed list */
 	hlist_nulls_del_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode);
 
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.ctinfo = ctinfo;
+	rtl_nf_conntrack_confirm_hooks(&conn_info);	        			 
+	#endif
+
 	/* Timer relative to confirmation time, not original
 	   setting time, otherwise we'd get timer wrap in
 	   weird delay cases. */
@@ -401,6 +443,7 @@
 	 */
 	__nf_conntrack_hash_insert(ct, hash, repl_hash);
 	NF_CT_STAT_INC(net, insert);
+
 	spin_unlock_bh(&nf_conntrack_lock);
 
 	help = nfct_help(ct);
@@ -454,6 +497,7 @@
 
 #define NF_CT_EVICTION_RANGE	8
 
+#if !defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)	/* used only when NOT define GARBAGE_NEW */
 /* There's a small race here where we may free a just-assured
    connection.  Too bad: we're in trouble anyway. */
 static noinline int early_drop(struct net *net, unsigned int hash)
@@ -495,6 +539,7 @@
 	nf_ct_put(ct);
 	return dropped;
 }
+#endif
 
 struct nf_conn *nf_conntrack_alloc(struct net *net,
 				   const struct nf_conntrack_tuple *orig,
@@ -512,10 +557,20 @@
 	/* We don't want any race condition at early drop stage */
 	atomic_inc(&net->ct.count);
 
-	if (nf_conntrack_max &&
-	    unlikely(atomic_read(&net->ct.count) > nf_conntrack_max)) {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	if (nf_conntrack_max && unlikely(atomic_read(&net->ct.count) > rtl_nf_conntrack_threshold))
+#else	
+	if (nf_conntrack_max && unlikely(atomic_read(&net->ct.count) > nf_conntrack_max))
+#endif
+	{
+		/* Try dropping from this hash chain. */
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		if(!drop_one_conntrack(orig,repl))
+#else
 		unsigned int hash = hash_conntrack(orig);
-		if (!early_drop(net, hash)) {
+		if (!early_drop(net, hash)) 
+#endif
+		{
 			atomic_dec(&net->ct.count);
 			if (net_ratelimit())
 				printk(KERN_WARNING
@@ -585,6 +640,9 @@
 	struct nf_conn_help *help;
 	struct nf_conntrack_tuple repl_tuple;
 	struct nf_conntrack_expect *exp;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	if (!nf_ct_invert_tuple(&repl_tuple, tuple, l3proto, l4proto)) {
 		pr_debug("Can't invert tuple.\n");
@@ -632,6 +690,15 @@
 		NF_CT_STAT_INC(net, new);
 	}
 
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.l3proto = l3proto;
+	conn_info.l4proto = l4proto;
+	rtl_nf_init_conntrack_hooks(&conn_info);
+	#endif
+
 	/* Overload tuple linked list to put us in unconfirmed list. */
 	hlist_nulls_add_head_rcu(&ct->tuplehash[IP_CT_DIR_ORIGINAL].hnnode,
 		       &net->ct.unconfirmed);
@@ -718,6 +785,9 @@
 	u_int8_t protonum;
 	int set_reply = 0;
 	int ret;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s		conn_info;
+	#endif
 
 	/* Previously seen (loopback or untracked)?  Ignore. */
 	if (skb->nfct) {
@@ -779,6 +849,18 @@
 		return -ret;
 	}
 
+ 	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.l3proto = l3proto;
+	conn_info.l4proto = l4proto;
+	conn_info.protonum = protonum;
+	conn_info.hooknum = hooknum;
+	conn_info.ctinfo = ctinfo;
+	rtl_nf_conntrack_in_hooks(&conn_info);
+	#endif
+
 	if (set_reply && !test_and_set_bit(IPS_SEEN_REPLY_BIT, &ct->status))
 		nf_conntrack_event_cache(IPCT_STATUS, ct);
 
@@ -1234,6 +1316,10 @@
 	if (ret < 0)
 		goto err_helper;
 
+#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_init_hooks();
+#endif
+
 	return 0;
 
 err_helper:
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/nf_conntrack_proto.c linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto.c
--- linux-2.6.30.9/net/netfilter/nf_conntrack_proto.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto.c	2011-12-05 15:50:14.000000000 +0000
@@ -29,7 +29,12 @@
 #include <net/netfilter/nf_conntrack_l4proto.h>
 #include <net/netfilter/nf_conntrack_core.h>
 
+#if defined(FAST_PATH_SPI_ENABLED)
+	struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX]  __read_mostly;
+#else
 static struct nf_conntrack_l4proto **nf_ct_protos[PF_MAX] __read_mostly;
+#endif
+
 struct nf_conntrack_l3proto *nf_ct_l3protos[AF_MAX] __read_mostly;
 EXPORT_SYMBOL_GPL(nf_ct_l3protos);
 
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/nf_conntrack_proto_tcp.c linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto_tcp.c
--- linux-2.6.30.9/net/netfilter/nf_conntrack_proto_tcp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto_tcp.c	2011-12-05 15:50:14.000000000 +0000
@@ -28,6 +28,10 @@
 #include <net/netfilter/nf_log.h>
 #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+#include <net/netfilter/nf_nat_core.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
 
 /* Protects ct->proto.tcp */
 static DEFINE_RWLOCK(tcp_lock);
@@ -261,6 +265,13 @@
 	}
 };
 
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH) || defined(CONFIG_RTL_HARDWARE_NAT)
+int	tcp_get_timeouts_by_state(u_int8_t	state)
+{
+	return tcp_timeouts[state];
+}
+#endif
+
 static bool tcp_pkt_to_tuple(const struct sk_buff *skb, unsigned int dataoff,
 			     struct nf_conntrack_tuple *tuple)
 {
@@ -482,7 +493,10 @@
 	}
 }
 
-static bool tcp_in_window(const struct nf_conn *ct,
+#if !defined(FAST_PATH_SPI_ENABLED)
+static 
+#endif
+	bool tcp_in_window(const struct nf_conn *ct,
 			  struct ip_ct_tcp *state,
 			  enum ip_conntrack_dir dir,
 			  unsigned int index,
@@ -698,6 +712,7 @@
 		 res, sender->td_end, sender->td_maxend, sender->td_maxwin,
 		 receiver->td_end, receiver->td_maxend, receiver->td_maxwin);
 
+
 	return res;
 }
 
@@ -812,6 +827,7 @@
 	return NF_ACCEPT;
 }
 
+//#define RTL_FP_CHECK_SPI_ENABLED 1
 /* Returns verdict for packet, or -1 for invalid. */
 static int tcp_packet(struct nf_conn *ct,
 		      const struct sk_buff *skb,
@@ -828,6 +844,9 @@
 	struct tcphdr _tcph;
 	unsigned long timeout;
 	unsigned int index;
+	#if defined(CONFIG_RTL_819X)
+	rtl_nf_conntrack_inso_s	conn_info;
+	#endif
 
 	th = skb_header_pointer(skb, dataoff, sizeof(_tcph), &_tcph);
 	BUG_ON(th == NULL);
@@ -839,6 +858,17 @@
 	new_state = tcp_conntracks[dir][index][old_state];
 	tuple = &ct->tuplehash[dir].tuple;
 
+	#if defined(CONFIG_RTL_819X)
+	conn_info.net = net;
+	conn_info.ct = ct;
+	conn_info.skb = skb;
+	conn_info.hooknum = hooknum;
+	conn_info.ctinfo = ctinfo;
+	conn_info.new_state=new_state;
+	conn_info.old_state=old_state;
+	rtl_tcp_packet_hooks(&conn_info);
+	#endif
+
 	switch (new_state) {
 	case TCP_CONNTRACK_SYN_SENT:
 		if (old_state < TCP_CONNTRACK_TIME_WAIT)
@@ -959,11 +989,14 @@
 		break;
 	}
 
+#if defined(FAST_PATH_SPI_ENABLED) || !(defined(CONFIG_RTL_IPTABLES_FAST_PATH) ||defined(CONFIG_RTL_HARDWARE_NAT))
 	if (!tcp_in_window(ct, &ct->proto.tcp, dir, index,
 			   skb, dataoff, th, pf)) {
 		write_unlock_bh(&tcp_lock);
 		return -NF_ACCEPT;
 	}
+#endif
+
      in_window:
 	/* From now on we have got in-window packets */
 	ct->proto.tcp.last_index = index;
@@ -1015,7 +1048,13 @@
 		set_bit(IPS_ASSURED_BIT, &ct->status);
 		nf_conntrack_event_cache(IPCT_STATUS, ct);
 	}
+
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	nf_ct_refresh_acct_tcp(ct, ctinfo, skb, timeout, old_state, new_state);
+#else
 	nf_ct_refresh_acct(ct, ctinfo, skb, timeout);
+#endif
+	//nf_ct_refresh_acct(ct, ctinfo, skb, timeout);
 
 	return NF_ACCEPT;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/nf_conntrack_proto_udp.c linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto_udp.c
--- linux-2.6.30.9/net/netfilter/nf_conntrack_proto_udp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_proto_udp.c	2011-12-05 15:50:14.000000000 +0000
@@ -24,9 +24,12 @@
 #include <net/netfilter/nf_log.h>
 #include <net/netfilter/ipv4/nf_conntrack_ipv4.h>
 #include <net/netfilter/ipv6/nf_conntrack_ipv6.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
 
-static unsigned int nf_ct_udp_timeout __read_mostly = 30*HZ;
-static unsigned int nf_ct_udp_timeout_stream __read_mostly = 180*HZ;
+unsigned int nf_ct_udp_timeout __read_mostly = 30*HZ;
+unsigned int nf_ct_udp_timeout_stream __read_mostly = 180*HZ;
 
 static bool udp_pkt_to_tuple(const struct sk_buff *skb,
 			     unsigned int dataoff,
@@ -74,12 +77,22 @@
 	/* If we've seen traffic both ways, this is some kind of UDP
 	   stream.  Extend timeout. */
 	if (test_bit(IPS_SEEN_REPLY_BIT, &ct->status)) {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		nf_ct_refresh_acct_udp(ct, ctinfo, skb, nf_ct_udp_timeout_stream, "ASSURED"); // assured
+#else
 		nf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_udp_timeout_stream);
+#endif			
+		
 		/* Also, more likely to be important, and not a probe */
 		if (!test_and_set_bit(IPS_ASSURED_BIT, &ct->status))
 			nf_conntrack_event_cache(IPCT_STATUS, ct);
-	} else
+	} else {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		nf_ct_refresh_acct_udp(ct, ctinfo, skb, nf_ct_udp_timeout, "UNREPLIED"); // unreplied
+#else
 		nf_ct_refresh_acct(ct, ctinfo, skb, nf_ct_udp_timeout);
+#endif
+	}
 
 	return NF_ACCEPT;
 }
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/nf_conntrack_standalone.c linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_standalone.c
--- linux-2.6.30.9/net/netfilter/nf_conntrack_standalone.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/nf_conntrack_standalone.c	2011-12-05 15:50:14.000000000 +0000
@@ -27,6 +27,11 @@
 #include <net/netfilter/nf_conntrack_helper.h>
 #include <net/netfilter/nf_conntrack_acct.h>
 
+
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/features/rtl_ps_hooks.h>
+#endif
+
 MODULE_LICENSE("GPL");
 
 #ifdef CONFIG_PROC_FS
@@ -113,6 +118,7 @@
 	struct nf_conn *ct = nf_ct_tuplehash_to_ctrack(hash);
 	const struct nf_conntrack_l3proto *l3proto;
 	const struct nf_conntrack_l4proto *l4proto;
+	//hyking add for hw use
 	int ret = 0;
 
 	NF_CT_ASSERT(ct);
@@ -129,6 +135,12 @@
 	NF_CT_ASSERT(l4proto);
 
 	ret = -ENOSPC;
+	//hyking add for hw use
+	#if defined(CONFIG_RTL_819X)
+	if(rtl_ct_seq_show_hooks(s,ct)==RTL_PS_HOOKS_BREAK)
+		goto release;		
+	#endif
+	
 	if (seq_printf(s, "%-8s %u %-8s %u %ld ",
 		       l3proto->name, nf_ct_l3num(ct),
 		       l4proto->name, nf_ct_protonum(ct),
@@ -338,7 +350,29 @@
 
 static struct ctl_table_header *nf_ct_netfilter_header;
 
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+extern unsigned int conntrack_min;
+extern unsigned int conntrack_max;
+extern unsigned int prot_limit[];
+
+extern int conntrack_dointvec(ctl_table *table, int write, struct file *filp,
+		     void *buffer, size_t *lenp, loff_t *ppos);
+extern int conntrack_dointvec_minmax(ctl_table *table, int write, struct file *filp,
+		     void *buffer, size_t *lenp, loff_t *ppos);
+#endif 
+
+
 static ctl_table nf_ct_sysctl_table[] = {
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+	{
+		.ctl_name	= NET_NF_CONNTRACK_MAX,
+		.procname	= "nf_conntrack_max",
+		.data		= &nf_conntrack_max,
+		.maxlen		= sizeof(int),
+		.mode		= 0644,
+		.proc_handler	= &conntrack_dointvec,
+	},
+#else
 	{
 		.ctl_name	= NET_NF_CONNTRACK_MAX,
 		.procname	= "nf_conntrack_max",
@@ -347,6 +381,7 @@
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#endif
 	{
 		.ctl_name	= NET_NF_CONNTRACK_COUNT,
 		.procname	= "nf_conntrack_count",
@@ -390,6 +425,29 @@
 		.mode		= 0644,
 		.proc_handler	= proc_dointvec,
 	},
+#if defined(CONFIG_RTL_CONNTRACK_GARBAGE_NEW)
+	{ 
+		.ctl_name	= NET_NF_CONNTRACK_GARBAGE_TCP,
+		.procname	= "nf_conntrack_tcp",
+		.data		= &prot_limit[PROT_TCP],
+		.maxlen		= sizeof(prot_limit[PROT_TCP]), 
+		.mode		= 0644,
+		.proc_handler	= &conntrack_dointvec_minmax,
+		.extra1		= &conntrack_min,
+		.extra2		= &conntrack_max,
+	},
+	{ 
+		.ctl_name	= NET_NF_CONNTRACK_GARBAGE_UDP,
+		.procname	= "nf_conntrack_udp",
+		.data		= &prot_limit[PROT_UDP],
+		.maxlen		= sizeof(prot_limit[PROT_UDP]), 
+		.mode		= 0644,
+		.proc_handler	= &conntrack_dointvec_minmax,
+		.extra1		= &conntrack_min,
+		.extra2		= &conntrack_max,
+	},
+#endif
+
 	{ .ctl_name = 0 }
 };
 
@@ -402,7 +460,11 @@
 		.data		= &nf_conntrack_max,
 		.maxlen		= sizeof(int),
 		.mode		= 0644,
+#if defined(CONFIG_RTL_NF_CONNTRACK_GARBAGE_NEW)
+		.proc_handler	= &conntrack_dointvec,
+#else
 		.proc_handler	= proc_dointvec,
+#endif
 	},
 	{ .ctl_name = 0 }
 };
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/xt_dscp.c linux-2.6.30.9-rsdk/net/netfilter/xt_dscp.c
--- linux-2.6.30.9/net/netfilter/xt_dscp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_dscp.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,6 +17,12 @@
 #include <linux/netfilter/xt_dscp.h>
 #include <linux/netfilter_ipv4/ipt_tos.h>
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
+
 MODULE_AUTHOR("Harald Welte <laforge@netfilter.org>");
 MODULE_DESCRIPTION("Xtables: DSCP/TOS field match");
 MODULE_LICENSE("GPL");
@@ -34,6 +40,29 @@
 	return (dscp == info->dscp) ^ !!info->invert;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int dscp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+
+	const struct xt_dscp_info *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+
+	if(ip == NULL || matchinfo == NULL || rule == NULL)
+		return 1;
+	
+	rule->ruleType_ = RTL865X_ACL_IP;
+	rule->tos_ = ipv4_get_dsfield((struct iphdr *)ip);
+	rule->tosMask_ = XT_DSCP_MASK;
+
+	return 0;
+}
+#endif
+
 static bool
 dscp_mt6(const struct sk_buff *skb, const struct xt_match_param *par)
 {
@@ -83,6 +112,10 @@
 		.match		= dscp_mt,
 		.matchsize	= sizeof(struct xt_dscp_info),
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= dscp_match2acl,
+#endif
+
 	},
 	{
 		.name		= "dscp",
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/xt_iprange.c linux-2.6.30.9-rsdk/net/netfilter/xt_iprange.c
--- linux-2.6.30.9/net/netfilter/xt_iprange.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_iprange.c	2011-12-05 15:50:14.000000000 +0000
@@ -16,6 +16,12 @@
 #include <linux/netfilter/xt_iprange.h>
 #include <linux/netfilter_ipv4/ipt_iprange.h>
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
+
 static bool
 iprange_mt_v0(const struct sk_buff *skb, const struct xt_match_param *par)
 {
@@ -85,6 +91,113 @@
 	return true;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int iprange_match2acl(const char *tablename,
+                          const void *ip,
+                          const struct xt_match *match,
+                          void *matchinfo,
+                          void *acl_rule,
+                          unsigned int *invflags)
+{
+ 
+        const struct ipt_iprange_info *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+ 
+        if(ip == NULL || matchinfo == NULL || rule == NULL)
+                return 1;
+ 
+        switch(rule->ruleType_)
+        {
+                case            RTL865X_ACL_TCP:
+                        rule->ruleType_ = RTL865X_ACL_TCP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_UDP:
+                        rule->ruleType_ = RTL865X_ACL_UDP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_IGMP:
+                        rule->ruleType_ = RTL865X_ACL_ICMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_ICMP:
+                        rule->ruleType_ = RTL865X_ACL_IGMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_SRCFILTER:
+                        rule->ruleType_ = RTL865X_ACL_SRCFILTER_IPRANGE;
+                        break;
+                case            RTL865X_ACL_MAC:
+                case            RTL865X_ACL_IP:
+                        rule->ruleType_ = RTL865X_ACL_IP_RANGE;
+                        break;
+                default:
+                        return 1;
+        }
+
+        rule->srcIpAddrLB_ = rule->dstIpAddrLB_ = 0;
+        rule->srcIpAddrUB_ = rule->dstIpAddrUB_ = 0xffffffff;
+        if (info->flags & IPRANGE_SRC) {
+                rule->srcIpAddrLB_ = ntohl(info->src.min_ip);
+                rule->srcIpAddrUB_ = ntohl(info->src.max_ip);
+        }
+        if (info->flags & IPRANGE_DST) {
+                rule->dstIpAddrLB_ = ntohl(info->dst.min_ip);
+                rule->dstIpAddrUB_ = ntohl(info->dst.max_ip);
+        }
+ 
+        return 0;
+}
+static int iprange_match2acl_mt4(const char *tablename,
+                          const void *ip,
+                          const struct xt_match *match,
+                          void *matchinfo,
+                          void *acl_rule,
+                          unsigned int *invflags)
+{
+ 
+        const struct xt_iprange_mtinfo *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+ 
+        if(ip == NULL || matchinfo == NULL || rule == NULL)
+                return 1;
+ 
+        switch(rule->ruleType_)
+        {
+                case            RTL865X_ACL_TCP:
+                        rule->ruleType_ = RTL865X_ACL_TCP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_UDP:
+                        rule->ruleType_ = RTL865X_ACL_UDP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_IGMP:
+                        rule->ruleType_ = RTL865X_ACL_ICMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_ICMP:
+                        rule->ruleType_ = RTL865X_ACL_IGMP_IPRANGE;
+                        break;
+                case            RTL865X_ACL_SRCFILTER:
+                        rule->ruleType_ = RTL865X_ACL_SRCFILTER_IPRANGE;
+                        break;
+                case            RTL865X_ACL_MAC:
+                case            RTL865X_ACL_IP:
+                        rule->ruleType_ = RTL865X_ACL_IP_RANGE;
+                        break;
+                default:
+                        return 1;
+        }
+
+        rule->srcIpAddrLB_ = rule->dstIpAddrLB_ = 0;
+        rule->srcIpAddrUB_ = rule->dstIpAddrUB_ = 0xffffffff;
+        if (info->flags & IPRANGE_SRC) {
+                rule->srcIpAddrLB_ = info->src_min.in.s_addr;
+                rule->srcIpAddrUB_ = info->src_max.in.s_addr;
+        }
+        if (info->flags & IPRANGE_DST) {
+                rule->dstIpAddrLB_ = info->dst_min.in.s_addr;
+                rule->dstIpAddrUB_ = info->dst_max.in.s_addr;
+        }
+ 
+        return 0;
+}
+#endif
+
 static inline int
 iprange_ipv6_sub(const struct in6_addr *a, const struct in6_addr *b)
 {
@@ -132,6 +245,10 @@
 		.match     = iprange_mt_v0,
 		.matchsize = sizeof(struct ipt_iprange_info),
 		.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+        	.match2acl      = iprange_match2acl,
+#endif
+
 	},
 	{
 		.name      = "iprange",
@@ -140,6 +257,9 @@
 		.match     = iprange_mt4,
 		.matchsize = sizeof(struct xt_iprange_mtinfo),
 		.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+        	.match2acl      = iprange_match2acl_mt4,
+#endif
 	},
 	{
 		.name      = "iprange",
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/xt_mac.c linux-2.6.30.9-rsdk/net/netfilter/xt_mac.c
--- linux-2.6.30.9/net/netfilter/xt_mac.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_mac.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,6 +17,13 @@
 #include <linux/netfilter_ipv6.h>
 #include <linux/netfilter/xt_mac.h>
 #include <linux/netfilter/x_tables.h>
+#include <net/dst.h>
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Netfilter Core Team <coreteam@netfilter.org>");
@@ -24,27 +31,117 @@
 MODULE_ALIAS("ipt_mac");
 MODULE_ALIAS("ip6t_mac");
 
+static int compare_with_header_cache_dest_mac(const struct sk_buff *skb, char *macaddr)
+{
+	struct dst_entry *dst = skb->dst;
+	struct hh_cache *hh;
+	int ret = 0;
+	
+	if ((dst)&&(dst->hh)&&(dst->hh->hh_data))
+	{
+	    	hh = dst->hh;
+	    	if (hh && (hh->hh_type==ETH_P_IP))
+		{
+	    		read_lock_bh(&hh->hh_lock);
+	      		memcpy(skb->data - 16, hh->hh_data, 16);
+	      		if (memcmp((((u8*)hh->hh_data) + 2), macaddr, ETH_ALEN) == 0)
+	      		    ret = 1;
+	    		read_unlock_bh(&hh->hh_lock);
+	    	}
+	}
+	else
+	{
+		if(!compare_ether_addr(eth_hdr(skb)->h_dest, macaddr))
+		{
+			ret=1;
+		}
+	}
+	return ret;
+}
+
 static bool mac_mt(const struct sk_buff *skb, const struct xt_match_param *par)
 {
     const struct xt_mac_info *info = par->matchinfo;
 
+	if (info->flags & MAC_SRC) {
     /* Is mac pointer valid? */
-    return skb_mac_header(skb) >= skb->head &&
-	   skb_mac_header(skb) + ETH_HLEN <= skb->data
+	    if ((skb_mac_header(skb) >= skb->head
+		    && (skb_mac_header(skb) + ETH_HLEN) <= skb->data
 	   /* If so, compare... */
-	   && ((!compare_ether_addr(eth_hdr(skb)->h_source, info->srcaddr))
-		^ info->invert);
+		    && ((!compare_ether_addr(eth_hdr(skb)->h_source, info->srcaddr.macaddr))
+			^ !!(info->flags & MAC_SRC_INV)))==0)
+	    	{
+			return 0;
+	    	}
 }
 
+	if (info->flags & MAC_DST) {
+	     /* Is mac pointer valid? */
+	    if( (skb_mac_header(skb) >= skb->head
+		    && (skb_mac_header(skb) + ETH_HLEN) <= skb->data
+		    /* If so, compare... */
+		    && (compare_with_header_cache_dest_mac(skb, (char*)(info->dstaddr.macaddr)) ^ !!(info->flags & MAC_DST_INV)))==0)
+	    	{
+			return 0;
+	    	}
+	}
+
+	return 1;
+
+}
+
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int mac_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+
+	const struct xt_mac_info *info = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+	if(matchinfo == NULL || rule == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_MAC;
+
+	//To initial first
+	memset(rule->srcMac_.octet, 0, ETH_ALEN);
+	memset(rule->srcMacMask_.octet, 0, ETH_ALEN);
+	memset(rule->dstMac_.octet, 0, ETH_ALEN);
+	memset(rule->dstMacMask_.octet, 0, ETH_ALEN);
+	
+	if (info->flags & MAC_SRC) {
+		memcpy(rule->srcMac_.octet, info->srcaddr.macaddr, ETH_ALEN);
+		memset(rule->srcMacMask_.octet, 0xff, ETH_ALEN);
+	}
+
+	if (info->flags & MAC_DST) {
+		memcpy(rule->dstMac_.octet, info->dstaddr.macaddr, ETH_ALEN);
+		memset(rule->dstMacMask_.octet, 0xff, ETH_ALEN);
+	}
+	
+	rule->typeLen_ = rule->typeLenMask_ = 0;
+	
+	return 0;
+}
+#endif
+
 static struct xt_match mac_mt_reg __read_mostly = {
 	.name      = "mac",
 	.revision  = 0,
 	.family    = NFPROTO_UNSPEC,
 	.match     = mac_mt,
 	.matchsize = sizeof(struct xt_mac_info),
-	.hooks     = (1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN) |
+/*	.hooks     = (1 << NF_INET_PRE_ROUTING) | (1 << NF_INET_LOCAL_IN) |
 	             (1 << NF_INET_FORWARD),
+*/
 	.me        = THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+	.match2acl	= mac_match2acl,
+#endif
+
 };
 
 static int __init mac_mt_init(void)
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/xt_MARK.c linux-2.6.30.9-rsdk/net/netfilter/xt_MARK.c
--- linux-2.6.30.9/net/netfilter/xt_MARK.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_MARK.c	2011-12-05 15:50:14.000000000 +0000
@@ -17,6 +17,12 @@
 
 #include <linux/netfilter/x_tables.h>
 #include <linux/netfilter/xt_MARK.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <linux/netfilter_ipv4/ip_tables.h>
+#include <net/pkt_cls.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 MODULE_LICENSE("GPL");
 MODULE_AUTHOR("Marc Boucher <marc@mbsi.ca>");
@@ -146,6 +152,141 @@
 }
 #endif /* CONFIG_COMPAT */
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+int xt_target2acl_v0(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			  rtl865x_AclRule_t *rule,
+			  unsigned int hook_mask, 
+			  void **data)
+{
+	struct net_device *dev, *matchDev;
+	struct ipt_entry *e;
+	const struct xt_mark_target_info *markinfo = targinfo;
+	rtl865x_qos_rule_t qosRule;
+
+
+	e = (struct ipt_entry *)entry;
+
+	{
+		dev = __dev_get_by_name(&init_net, e->ip.outiface);
+		memcpy(qosRule.inIfname, e->ip.iniface, IFNAMSIZ);
+		memcpy(qosRule.outIfname, e->ip.outiface, IFNAMSIZ);
+		
+		qosRule.mark = markinfo->mark;
+
+		////////////////////////
+		//Patch for hardware QoS
+		//To seperate uplink and downlink according to mark from iptables rule
+		if(qosRule.mark<53)
+		{
+			rule->upDown_=0;//Uplink
+		}
+		else
+		{
+			rule->upDown_=1;//Downlink
+		}
+		//////////////////////////
+		
+		qosRule.rule = rule;
+		
+		tc_getHandleByKey(markinfo->mark, &qosRule.handle, dev, &matchDev);
+		rtl865x_qosAddMarkRule(&qosRule);
+	}
+
+	return RTL865X_SKIP_THIS_RULE;
+}
+int xt_target2acl_v1(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			  rtl865x_AclRule_t *rule,
+			  unsigned int hook_mask, 
+			  void **data)
+{
+	struct net_device *dev, *matchDev;
+	struct ipt_entry *e;
+	const struct xt_mark_target_info_v1 *markinfo = targinfo;
+	rtl865x_qos_rule_t qosRule;
+
+
+	e = (struct ipt_entry *)entry;
+
+	{
+		dev = __dev_get_by_name(&init_net, e->ip.outiface);
+		memcpy(qosRule.inIfname, e->ip.iniface, IFNAMSIZ);
+		memcpy(qosRule.outIfname, e->ip.outiface, IFNAMSIZ);
+		
+		qosRule.mark = markinfo->mark;
+
+		////////////////////////
+		//Patch for hardware QoS
+		//To seperate uplink and downlink according to mark from iptables rule
+		if(qosRule.mark<53)
+		{
+			rule->upDown_=0;//Uplink
+		}
+		else
+		{
+			rule->upDown_=1;//Downlink
+		}
+		//////////////////////////
+		
+		qosRule.rule = rule;
+		
+		tc_getHandleByKey(markinfo->mark, &qosRule.handle, dev, &matchDev);
+		rtl865x_qosAddMarkRule(&qosRule);
+	}
+
+	return RTL865X_SKIP_THIS_RULE;
+}
+int xt_target2acl_v2(const char *tablename,
+			  const void *entry,
+			  const struct xt_target *target,
+			  void *targinfo,
+			  rtl865x_AclRule_t *rule,
+			  unsigned int hook_mask, 
+			  void **data)
+{
+	struct net_device *dev, *matchDev;
+	struct ipt_entry *e;
+	const struct xt_mark_tginfo2 *markinfo = targinfo;
+	rtl865x_qos_rule_t qosRule;
+
+
+	e = (struct ipt_entry *)entry;
+
+	{
+		dev = __dev_get_by_name(&init_net, e->ip.outiface);
+		memcpy(qosRule.inIfname, e->ip.iniface, IFNAMSIZ);
+		memcpy(qosRule.outIfname, e->ip.outiface, IFNAMSIZ);
+		
+		qosRule.mark = markinfo->mark;
+
+		////////////////////////
+		//Patch for hardware QoS
+		//To seperate uplink and downlink according to mark from iptables rule
+		if(qosRule.mark<53)
+		{
+			rule->upDown_=0;//Uplink
+		}
+		else
+		{
+			rule->upDown_=1;//Downlink
+		}
+		//////////////////////////
+		
+		qosRule.rule = rule;
+		
+		tc_getHandleByKey(markinfo->mark, &qosRule.handle, dev, &matchDev);
+		rtl865x_qosAddMarkRule(&qosRule);
+	}
+
+	return RTL865X_SKIP_THIS_RULE;
+}
+#endif
+
 static struct xt_target mark_tg_reg[] __read_mostly = {
 	{
 		.name		= "MARK",
@@ -160,6 +301,9 @@
 		.compat_to_user	= mark_tg_compat_to_user_v0,
 #endif
 		.table		= "mangle",
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.target2acl	= xt_target2acl_v0,
+#endif
 		.me		= THIS_MODULE,
 	},
 	{
@@ -175,6 +319,9 @@
 		.compat_to_user	= mark_tg_compat_to_user_v1,
 #endif
 		.table		= "mangle",
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.target2acl	= xt_target2acl_v1,
+#endif
 		.me		= THIS_MODULE,
 	},
 	{
@@ -183,6 +330,9 @@
 		.family         = NFPROTO_UNSPEC,
 		.target         = mark_tg,
 		.targetsize     = sizeof(struct xt_mark_tginfo2),
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT) && defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.target2acl	= xt_target2acl_v2,
+#endif
 		.me             = THIS_MODULE,
 	},
 };
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/xt_state.c linux-2.6.30.9-rsdk/net/netfilter/xt_state.c
--- linux-2.6.30.9/net/netfilter/xt_state.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_state.c	2011-12-05 15:50:14.000000000 +0000
@@ -52,6 +52,25 @@
 	nf_ct_l3proto_module_put(par->match->family);
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int state_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+	const struct xt_state_info *sinfo = (struct xt_state_info *)matchinfo;
+	
+	if(sinfo->statemask & XT_STATE_BIT(IP_CT_ESTABLISHED))
+	{
+		return RTL865X_ESTABLISH_RULE;
+	}
+	/*if state rule is added, don't add this rule to rtl865x ACL table...skip this rule now.*/
+	return RTL865X_SKIP_THIS_RULE;	
+}
+#endif
+
 static struct xt_match state_mt_reg[] __read_mostly = {
 	{
 		.name		= "state",
@@ -61,6 +80,9 @@
 		.destroy	= state_mt_destroy,
 		.matchsize	= sizeof(struct xt_state_info),
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= state_match2acl,
+#endif
 	},
 	{
 		.name		= "state",
@@ -70,6 +92,9 @@
 		.destroy	= state_mt_destroy,
 		.matchsize	= sizeof(struct xt_state_info),
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= state_match2acl,
+#endif
 	},
 };
 
diff -uNr --ignore-all-space linux-2.6.30.9/net/netfilter/xt_tcpudp.c linux-2.6.30.9-rsdk/net/netfilter/xt_tcpudp.c
--- linux-2.6.30.9/net/netfilter/xt_tcpudp.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netfilter/xt_tcpudp.c	2011-12-05 15:50:14.000000000 +0000
@@ -10,6 +10,11 @@
 #include <linux/netfilter_ipv4/ip_tables.h>
 #include <linux/netfilter_ipv6/ip6_tables.h>
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#endif
+
 MODULE_DESCRIPTION("Xtables: TCP, UDP and UDP-Lite match");
 MODULE_LICENSE("GPL");
 MODULE_ALIAS("xt_tcp");
@@ -126,6 +131,43 @@
 	return true;
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int tcp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+
+	const struct ipt_ip *ip_info = (struct ipt_ip *) ip;
+	const struct xt_tcp *tcpinfo = matchinfo;
+	rtl865x_AclRule_t * rule = (rtl865x_AclRule_t *)acl_rule;
+
+	if(ip == NULL || matchinfo == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_TCP;
+	rule->srcIpAddr_ 		= ip_info->src.s_addr;
+	rule->srcIpAddrMask_	= ip_info->smsk.s_addr;
+	rule->dstIpAddr_		= ip_info->dst.s_addr;
+	rule->dstIpAddrMask_	= ip_info->dmsk.s_addr;
+
+	rule->tcpSrcPortLB_	= tcpinfo->spts[0];
+	rule->tcpSrcPortUB_	= tcpinfo->spts[1];
+	rule->tcpDstPortLB_	= tcpinfo->dpts[0];
+	rule->tcpDstPortUB_	= tcpinfo->dpts[1];
+	rule->tcpFlag_		= tcpinfo->flg_cmp;
+	rule->tcpFlagMask_	= tcpinfo->flg_mask;
+
+	if(tcpinfo->invflags & (XT_TCP_INV_SRCPT | XT_TCP_INV_DSTPT | XT_TCP_INV_FLAGS))
+		if(invflags)
+			*invflags = 1;	
+	
+	return 0;
+}
+#endif
+
 static bool tcp_mt_check(const struct xt_mtchk_param *par)
 {
 	const struct xt_tcp *tcpinfo = par->matchinfo;
@@ -161,6 +203,41 @@
 			      !!(udpinfo->invflags & XT_UDP_INV_DSTPT));
 }
 
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+static int udp_match2acl(const char *tablename,
+			  const void *ip,
+			  const struct xt_match *match,
+			  void *matchinfo,
+			  void *acl_rule,
+			  unsigned int *invflags)
+{
+	const struct ipt_ip *ip_info = (struct ipt_ip *) ip;
+	const struct xt_udp *udpinfo = matchinfo;
+	rtl865x_AclRule_t *rule = (rtl865x_AclRule_t *)acl_rule;
+
+	if(ip == NULL || matchinfo == NULL)
+		return 1;
+
+	rule->ruleType_ = RTL865X_ACL_UDP;
+	rule->srcIpAddr_ 		= ip_info->src.s_addr;
+	rule->srcIpAddrMask_	= ip_info->smsk.s_addr;
+	rule->dstIpAddr_		= ip_info->dst.s_addr;
+	rule->dstIpAddrMask_	= ip_info->dmsk.s_addr;
+
+	rule->udpSrcPortLB_	= udpinfo->spts[0];
+	rule->udpSrcPortUB_	= udpinfo->spts[1];
+	rule->udpDstPortLB_	= udpinfo->dpts[0];
+	rule->udpDstPortUB_	= udpinfo->dpts[1];
+	
+
+	if(udpinfo->invflags & (XT_UDP_INV_SRCPT | XT_UDP_INV_DSTPT))
+		if(invflags)
+			*invflags = 1;	
+		
+	return 0;
+}
+#endif
+
 static bool udp_mt_check(const struct xt_mtchk_param *par)
 {
 	const struct xt_udp *udpinfo = par->matchinfo;
@@ -178,6 +255,9 @@
 		.matchsize	= sizeof(struct xt_tcp),
 		.proto		= IPPROTO_TCP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= tcp_match2acl,
+#endif
 	},
 	{
 		.name		= "tcp",
@@ -187,6 +267,9 @@
 		.matchsize	= sizeof(struct xt_tcp),
 		.proto		= IPPROTO_TCP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= tcp_match2acl,
+#endif
 	},
 	{
 		.name		= "udp",
@@ -196,6 +279,9 @@
 		.matchsize	= sizeof(struct xt_udp),
 		.proto		= IPPROTO_UDP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= udp_match2acl,
+#endif
 	},
 	{
 		.name		= "udp",
@@ -205,6 +291,9 @@
 		.matchsize	= sizeof(struct xt_udp),
 		.proto		= IPPROTO_UDP,
 		.me		= THIS_MODULE,
+#if defined(CONFIG_RTL_IPTABLES_RULE_2_ACL)
+		.match2acl	= udp_match2acl,
+#endif
 	},
 	{
 		.name		= "udplite",
diff -uNr --ignore-all-space linux-2.6.30.9/net/netlink/af_netlink.c linux-2.6.30.9-rsdk/net/netlink/af_netlink.c
--- linux-2.6.30.9/net/netlink/af_netlink.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/netlink/af_netlink.c	2011-12-05 15:50:14.000000000 +0000
@@ -1491,8 +1491,61 @@
 	return NULL;
 }
 EXPORT_SYMBOL(netlink_kernel_create);
+#if defined(CONFIG_RTL_819X)
+int rtk_nlrecvmsg(struct sk_buff *skb,int _len, void *_recv_data)
+{
+	int pid;
+//	struct sk_buff *skb;
+  	struct nlmsghdr *nlh;
 
+	pid=0;
+//  	printk("net_link: data is ready to read.\n");
+  	//skb = skb_get(_skb);
 
+	if (skb->len >= NLMSG_SPACE(0)) {
+    		nlh = nlmsg_hdr(skb);
+		memcpy(_recv_data,NLMSG_DATA(nlh),_len);
+    		pid = nlh->nlmsg_pid; /*pid of sending process */
+//    		printk("net_link: pid is %d\n", pid);    		
+		//kfree_skb(skb);	
+		return pid;
+  	}
+	else
+	{
+		//kfree_skb(skb);	
+		return -1;
+	}
+}
+EXPORT_SYMBOL(rtk_nlrecvmsg);
+
+int rtk_nlsendmsg (int _pid,struct sock *_nl_sk,int _len,void *_send_info) 
+{
+        struct nlmsghdr *nlh;
+        struct sk_buff *skb;
+        int rc;
+        int len;
+
+	 len = NLMSG_SPACE(_len+sizeof(struct nlmsghdr)+32);
+ 
+        skb = alloc_skb(len, GFP_ATOMIC);
+        if (!skb){
+                printk(KERN_ERR "net_link: allocate failed.\n");
+                return -1;
+        }
+        nlh = nlmsg_put(skb,0,0,0,len,0);
+        NETLINK_CB(skb).pid = 0; /* from kernel */
+ 
+        memcpy(NLMSG_DATA(nlh), _send_info, _len);
+//        printk("net_link: going to send.\n");
+        rc = netlink_unicast(_nl_sk, skb, _pid, MSG_DONTWAIT);
+        if (rc < 0) {
+                printk(KERN_ERR "net_link: can not unicast skb (%d)\n", rc);
+        }
+//        printk("net_link: send to %d is ok.\n",_pid);
+        return 0;
+}
+EXPORT_SYMBOL(rtk_nlsendmsg);
+#endif
 void
 netlink_kernel_release(struct sock *sk)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/net/sched/cls_api.c linux-2.6.30.9-rsdk/net/sched/cls_api.c
--- linux-2.6.30.9/net/sched/cls_api.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/sched/cls_api.c	2011-12-05 15:50:14.000000000 +0000
@@ -29,6 +29,11 @@
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
 #include <net/pkt_cls.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 /* The list of all installed classifier types */
 
@@ -136,6 +141,9 @@
 	unsigned long fh;
 	int err;
 	int tp_created = 0;
+	#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	int	handle;
+	#endif
 
 	if (net != &init_net)
 		return -EINVAL;
@@ -322,6 +330,20 @@
 			*back = tp;
 			spin_unlock_bh(root_lock);
 		}
+
+		#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		cops->getHandleByKey(t->tcm_handle, &handle, q);
+		switch (n->nlmsg_type) {
+			case RTM_NEWTFILTER:
+				rtl_qosSetPriorityByMark(dev->name, t->tcm_handle, handle, TRUE);
+				break;
+			case RTM_DELTFILTER:
+				rtl_qosSetPriorityByMark(dev->name, t->tcm_handle, handle, FALSE);
+				break;
+			default:
+				break;
+		};
+		#endif
 		tfilter_notify(skb, n, tp, fh, RTM_NEWTFILTER);
 	} else {
 		if (tp_created)
@@ -337,6 +359,58 @@
 	return err;
 }
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+int tc_getHandleByKey(__u32 key, __u32 *handle, struct net_device *d, struct net_device **m)
+{
+	struct Qdisc  *q;
+	struct Qdisc_class_ops *cops;
+	int			i;
+	char			*ifName;
+	struct net_device *dev;
+
+	if (d==NULL)
+	{
+		for(i=0;i<NETIF_NUMBER;i++)
+		{
+			ifName = &netIfNameArray[i][0];
+			if (ifName[0]!=0&&
+				(dev = __dev_get_by_name(&init_net, ifName))!=NULL)
+			{
+				q = netdev_get_tx_queue(dev, 0)->qdisc_sleeping;
+
+				if ((cops = q->ops->cl_ops)==NULL || cops->getHandleByKey==NULL)
+				{
+					continue;
+				}
+				else if (cops->getHandleByKey(key, handle, q)!=0)
+				{
+					continue;
+				}
+				else
+				{
+					*m = dev;
+					return 0;
+				}
+			}
+		}
+	}
+	else
+	{
+		q = netdev_get_tx_queue(d, 0)->qdisc_sleeping;
+		if ((cops = q->ops->cl_ops)==NULL || cops->getHandleByKey==NULL)
+		{
+			return -1;
+		}
+		else
+		{
+			return cops->getHandleByKey(key, handle, q);
+		}
+	}
+
+	return -1;
+}
+#endif
+
 static int tcf_fill_node(struct sk_buff *skb, struct tcf_proto *tp,
 			 unsigned long fh, u32 pid, u32 seq, u16 flags, int event)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/net/sched/cls_fw.c linux-2.6.30.9-rsdk/net/sched/cls_fw.c
--- linux-2.6.30.9/net/sched/cls_fw.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/sched/cls_fw.c	2011-12-05 15:50:14.000000000 +0000
@@ -27,6 +27,11 @@
 #include <net/netlink.h>
 #include <net/act_api.h>
 #include <net/pkt_cls.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl_types.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 #define HTSIZE (PAGE_SIZE/sizeof(struct fw_filter *))
 
@@ -78,6 +83,62 @@
 		return handle & (HTSIZE - 1);
 }
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+static int fw_classifyMark(__u32 mark, struct tcf_proto *tp,
+			  struct tcf_result *res)
+{
+	struct fw_head *head;
+	struct fw_filter *f;
+	u32 id;
+
+	head = (struct fw_head*)tp->root;
+	
+	if (head != NULL) {
+		id = mark & head->mask;
+		for (f=head->ht[fw_hash(id)]; f; f=f->next) {
+			if (f->id == id) {
+				*res = f->res;
+				return 0;
+			}
+		}
+	} else {
+		/* old method */
+		id = mark;
+		if (id && (TC_H_MAJ(id) == 0 || !(TC_H_MAJ(id^tp->q->handle)))) {
+			res->classid = id;
+			res->class = 0;
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+static int fw_arrange_rules(struct tcf_proto *tp)
+{
+	rtl865x_qos_rule_t	*qosRule;
+	struct tcf_result	res;
+
+	qosRule = rtl865x_qosRuleHead;
+	while(qosRule)
+	{
+		if (fw_classifyMark(qosRule->mark, tp, &res)==0)
+		{
+			qosRule->handle = res.classid;
+		}
+		else if(TC_H_MAJ(qosRule->handle)==TC_H_MAJ(tp->classid))
+			qosRule->handle = 0;
+
+		qosRule = qosRule->next;
+	}
+
+	rtl865x_qosArrangeRuleByNetif();
+	
+	return SUCCESS;
+}
+
+#endif
+
 static int fw_classify(struct sk_buff *skb, struct tcf_proto *tp,
 			  struct tcf_result *res)
 {
@@ -141,6 +202,9 @@
 static inline void
 fw_delete_filter(struct tcf_proto *tp, struct fw_filter *f)
 {
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	fw_arrange_rules(tp);
+#endif
 	tcf_unbind_filter(tp, &f->res);
 	tcf_exts_destroy(tp, &f->exts);
 	kfree(f);
@@ -228,6 +292,10 @@
 
 	tcf_exts_change(tp, &f->exts, &e);
 
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	fw_arrange_rules(tp);
+#endif
+
 	return 0;
 errout:
 	tcf_exts_destroy(tp, &e);
@@ -292,6 +360,11 @@
 	tcf_tree_unlock(tp);
 
 	*arg = (unsigned long)f;
+
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	fw_arrange_rules(tp);
+#endif
+
 	return 0;
 
 errout:
@@ -374,6 +447,9 @@
 static struct tcf_proto_ops cls_fw_ops __read_mostly = {
 	.kind		=	"fw",
 	.classify	=	fw_classify,
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	.classifyMark	=	fw_classifyMark,
+#endif
 	.init		=	fw_init,
 	.destroy	=	fw_destroy,
 	.get		=	fw_get,
diff -uNr --ignore-all-space linux-2.6.30.9/net/sched/Makefile linux-2.6.30.9-rsdk/net/sched/Makefile
--- linux-2.6.30.9/net/sched/Makefile	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/sched/Makefile	2011-12-05 15:50:14.000000000 +0000
@@ -46,3 +46,6 @@
 obj-$(CONFIG_NET_EMATCH_U32)	+= em_u32.o
 obj-$(CONFIG_NET_EMATCH_META)	+= em_meta.o
 obj-$(CONFIG_NET_EMATCH_TEXT)	+= em_text.o
+
+#EXTRA_CFLAGS += -I $(DIR_LINUX)/drivers/net/rtl819x
+EXTRA_AFLAGS += $(EXTRA_CFLAGS)
diff -uNr --ignore-all-space linux-2.6.30.9/net/sched/sch_api.c linux-2.6.30.9-rsdk/net/sched/sch_api.c
--- linux-2.6.30.9/net/sched/sch_api.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/sched/sch_api.c	2011-12-05 15:50:14.000000000 +0000
@@ -33,6 +33,10 @@
 #include <net/sock.h>
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
+#if	defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
 
 static int qdisc_notify(struct sk_buff *oskb, struct nlmsghdr *n, u32 clid,
 			struct Qdisc *old, struct Qdisc *new);
@@ -939,6 +943,31 @@
 	return 0;
 }
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+/*
+   Patch for hardware
+  */
+
+static int tc_sync_hardware(struct net_device *dev)
+{
+	struct Qdisc_class_ops *cops;
+
+	if (dev==NULL||netdev_get_tx_queue(dev,0)->qdisc_sleeping==NULL
+		||netdev_get_tx_queue(dev,0)->qdisc_sleeping->ops==NULL)
+		return -EINVAL;
+
+	cops = netdev_get_tx_queue(dev,0)->qdisc_sleeping->ops->cl_ops;
+
+	if (cops && cops->syncHwQueue)
+		return cops->syncHwQueue(dev);
+	else
+	{
+		rtl865x_qosFlushBandwidth(dev->name);
+		return rtl865x_closeQos(dev->name);
+	}
+}
+#endif
+
 /*
  * Delete/get qdisc.
  */
@@ -998,6 +1027,10 @@
 			return -ENOENT;
 		if ((err = qdisc_graft(dev, p, skb, n, clid, NULL, q)) != 0)
 			return err;
+
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+		tc_sync_hardware(dev);
+#endif
 	} else {
 		qdisc_notify(skb, n, clid, NULL, q);
 	}
@@ -1144,6 +1177,10 @@
 		return err;
 	}
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	tc_sync_hardware(dev);
+#endif
+
 	return 0;
 }
 
@@ -1624,6 +1661,23 @@
 }
 EXPORT_SYMBOL(tc_classify_compat);
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+int tc_classifyMark(__u32 mark, struct tcf_proto *tp, struct tcf_result *res)
+{
+	for ( ; tp; tp = tp->next)
+	{
+		if (tp->ops!=NULL && tp->ops->classifyMark!=NULL &&
+			tp->ops->classifyMark(mark, tp, res)==0)
+		{
+			return 0;
+		}
+	}
+
+	return -1;
+}
+
+#endif
+
 int tc_classify(struct sk_buff *skb, struct tcf_proto *tp,
 		struct tcf_result *res)
 {
diff -uNr --ignore-all-space linux-2.6.30.9/net/sched/sch_htb.c linux-2.6.30.9-rsdk/net/sched/sch_htb.c
--- linux-2.6.30.9/net/sched/sch_htb.c	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/net/sched/sch_htb.c	2011-12-05 15:50:14.000000000 +0000
@@ -38,6 +38,16 @@
 #include <linux/workqueue.h>
 #include <net/netlink.h>
 #include <net/pkt_sched.h>
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+#include <net/rtl/rtl_types.h>
+//#include <AsicDriver/rtl865x_asicCom.h>
+//#include <AsicDriver/rtl865x_asicL2.h>
+#include <net/rtl/rtl865x_netif.h>
+#include <net/rtl/rtl865x_outputQueue.h>
+#if defined(CONFIG_PROC_FS)
+#include <linux/proc_fs.h>
+#endif
+#endif
 
 /* HTB algorithm.
     Author: devik@cdi.cz
@@ -1508,6 +1518,261 @@
 		cl->filter_cnt--;
 }
 
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+
+#define	BANDWIDTH_GAP_FOR_PORT		10000
+#if defined(CONFIG_RTL_8196C)
+#define	FULL_SPEED	100000000
+#elif defined(CONFIG_RTL_8198)
+#define	FULL_SPEED	1000000000
+#else
+#error "Please select the correct chip model."
+#endif
+
+static int htb_syncHwQueue(struct net_device *dev)
+{
+	/*	Qdisc exist	*/
+	struct Qdisc	*q;
+	u32			queueNum;
+	u32			topClassNum;
+	u32			idx;
+	struct htb_class	*cl;
+	struct htb_class	*classHandle[TC_HTB_MAXDEPTH-1];
+	rtl865x_qos_t		queueInfo[RTL8651_OUTPUTQUEUE_SIZE];
+	struct htb_sched 	*defQ;
+	u32				defClassId;
+	u32 tmpBandwidth1, tmpBandwidth2;
+	int				i;
+
+	memset(queueInfo, 0, RTL8651_OUTPUTQUEUE_SIZE*sizeof(rtl865x_qos_t));
+	queueNum = topClassNum = 0;
+
+	defQ = qdisc_priv(netdev_get_tx_queue(dev, 0)->qdisc_sleeping);
+	defClassId = TC_H_MAKE(netdev_get_tx_queue(dev, 0)->qdisc_sleeping->handle, defQ->defcls);
+
+	for (i = 0; i < dev->num_tx_queues; i++)
+	{
+		struct netdev_queue *txq = netdev_get_tx_queue(dev, i);
+		struct Qdisc *txq_root = txq->qdisc_sleeping;
+		spin_lock_bh(qdisc_lock(txq_root));
+		list_for_each_entry(q, &txq_root->list, list)
+		{
+			if (q->parent)
+			{
+				cl = htb_find(q->parent, netdev_get_tx_queue(dev, 0)->qdisc_sleeping);
+
+				if (cl==NULL)
+				{
+					spin_unlock_bh(qdisc_lock(txq_root));
+					return -EINVAL;
+				}
+				{
+					queueInfo[queueNum].bandwidth = cl->rate->rate.rate<<3;
+					queueInfo[queueNum].ceil = cl->ceil->rate.rate<<3;
+					queueInfo[queueNum].handle = queueInfo[queueNum].queueId = cl->common.classid;
+					memcpy(queueInfo[queueNum].ifname, 
+						dev->name, sizeof(dev->name));
+									
+					if (cl->common.classid==defClassId)
+						queueInfo[queueNum].flags |= QOS_DEF_QUEUE;
+					else
+						queueInfo[queueNum].flags &= (~QOS_DEF_QUEUE);
+
+					if (queueInfo[queueNum].bandwidth==queueInfo[queueNum].ceil)
+					{
+						/*	Consider ceil==rate as as STR	*/
+						queueInfo[queueNum].flags = (queueInfo[queueNum].flags & (~QOS_TYPE_MASK)) | QOS_TYPE_STR | QOS_VALID_MASK;
+					}
+					else
+					{
+						/*	Otherwise, set all queue as WFQ	*/
+						queueInfo[queueNum].flags = (queueInfo[queueNum].flags & (~QOS_TYPE_MASK)) | QOS_TYPE_WFQ | QOS_VALID_MASK;
+					}
+
+					while(cl && cl->level!=TC_HTB_MAXDEPTH-1)
+					{
+						cl = cl->parent;
+					}
+
+					if (cl&&(cl->level==TC_HTB_MAXDEPTH-1))
+					{
+						int	newRoot;
+						
+						newRoot = 1;
+						for(idx=0;idx<topClassNum;idx++)
+						{
+							if (classHandle[idx]->common.classid==cl->common.classid)
+							{
+								newRoot = 0;
+								break;
+							}
+						}
+
+						if (newRoot)
+						{
+							classHandle[topClassNum] = cl;
+							topClassNum++;
+						}
+					}
+				}
+				queueNum++;
+			}
+		}
+		spin_unlock_bh(qdisc_lock(txq_root));
+	}
+
+	if (topClassNum == 0)
+	{
+		rtl865x_qosFlushBandwidth(dev->name);
+		rtl865x_closeQos(dev->name);
+	}
+	else
+	{
+		int32		i;
+		int32		portBandwidth, tmpPortBandwidth;
+		int32		totalRnum;
+		int32		totalGbandwidth, totalRbandwidth, calcRbandwidth;
+
+		portBandwidth = 0;
+		for(idx=0;idx<topClassNum;idx++)
+		{
+			{
+				portBandwidth += (classHandle[idx]->ceil->rate.rate<<3);
+			}
+		}
+
+		/*	Do port bandwidth adjust here		*/
+		tmpPortBandwidth = portBandwidth + (BANDWIDTH_GAP_FOR_PORT);
+#if 0
+		tmpPortBandwidth = portBandwidth<<3;
+		tmpPortBandwidth += tmpPortBandwidth>>3;
+		tmpPortBandwidth -= tmpPortBandwidth>>5;
+		if (tmpPortBandwidth>0x200000)
+			tmpPortBandwidth = ((tmpPortBandwidth/1000)<<10);
+		else
+			tmpPortBandwidth = ((tmpPortBandwidth<<10)/1000);
+#endif
+
+		/////////////////////////////////////////////////////////////////////////////
+		//Patch for qos: to improve no-match rule throughput especially for low speed(~500kbps)
+		//tmpPortBandwidth+=192000;	//Added 192kbps
+		/////////////////////////////////////////////////////////////////////////////
+
+		rtl865x_qosSetBandwidth(dev->name, tmpPortBandwidth);
+
+		totalGbandwidth = totalRbandwidth = totalRnum = 0;
+
+		/*	Check for G type queue's total bandwidth	*/
+		for(i=0; i<queueNum; i++)
+		{
+			if((queueInfo[i].ceil==portBandwidth)
+				&& queueInfo[i].bandwidth<queueInfo[i].ceil)	/* change bandwidth granulity from bps(bit/sec) to Bps(byte/sec) */
+			{
+				/*totalGbandwidth += ((queueInfo[i].bandwidth<<3)/1000)<<7;*/
+				totalGbandwidth += ((queueInfo[i].bandwidth));
+			}
+			else if (queueInfo[i].ceil<portBandwidth)
+			{
+				/*totalRbandwidth += ((queueInfo[i].ceil<<3)/1000)<<7;*/
+				totalRbandwidth += ((queueInfo[i].ceil));
+				totalRnum++;
+
+				tmpBandwidth1=queueInfo[i].ceil;
+				tmpBandwidth2=(tmpBandwidth1>>13)<<13;
+				if(tmpBandwidth1-tmpBandwidth2>(EGRESS_BANDWIDTH_GRANULARITY>>1))	// 4KByte which is 32kbit
+				{
+					queueInfo[i].bandwidth=queueInfo[i].ceil=((queueInfo[i].ceil>>13)+1)<<13;
+				}
+				else
+				{
+					queueInfo[i].bandwidth=queueInfo[i].ceil=(queueInfo[i].ceil>>13)<<13;
+				}
+				
+				if(queueInfo[i].bandwidth<EGRESS_BANDWIDTH_GRANULARITY)	/* 8K bytes == 64K bits	*/
+					queueInfo[i].bandwidth=queueInfo[i].ceil=EGRESS_BANDWIDTH_GRANULARITY;
+			}
+			/*
+			else
+			{
+				printk("Set output queue error: Queue bandwidth[%d]bps > Port bandwidth[%d]bps\n", 
+					queueInfo[i].ceil, portBandwidth);
+			}
+			*/
+		}
+
+		if ( totalRbandwidth!=0 && ((totalGbandwidth+totalRbandwidth)>portBandwidth))
+		{
+			/*	Should reduce the R type bandwidth	*/
+			calcRbandwidth = portBandwidth - totalGbandwidth;
+
+#if 0
+			for(i=0; i<queueNum; i++)
+			{
+				if (queueInfo[i].bandwidth==queueInfo[i].ceil)
+				{
+					queueInfo[i].ceil = queueInfo[i].bandwidth 
+						= queueInfo[i].bandwidth - (totalRbandwidth-calcRbandwidth)/totalRnum;
+				}
+			}
+#endif
+		}
+
+		for(i=0; i<queueNum; i++)
+		{
+			if (queueInfo[i].bandwidth!=queueInfo[i].ceil)
+			{
+				/*	Do queue bandwidth adjust here		*/
+				queueInfo[i].ceil += queueInfo[i].ceil>>3;
+				if (queueInfo[i].ceil>0x200000)
+					queueInfo[i].ceil = ((queueInfo[i].ceil/1000)<<10);
+				else
+					queueInfo[i].ceil = ((queueInfo[i].ceil<<10)/1000);
+
+				if (queueInfo[i].ceil>FULL_SPEED)
+					queueInfo[i].ceil = FULL_SPEED;
+			}
+			else
+			{
+				/*	str	*/
+				if (queueInfo[i].ceil>1000000)
+					queueInfo[i].ceil = queueInfo[i].bandwidth = (queueInfo[i].ceil/1000000)<<20;
+				else if (queueInfo[i].ceil>1000)
+					queueInfo[i].ceil = queueInfo[i].bandwidth = (queueInfo[i].ceil/1000)<<10;
+
+				if (queueInfo[i].ceil>FULL_SPEED)
+					queueInfo[i].ceil = queueInfo[i].bandwidth = FULL_SPEED;
+			}
+		}
+
+		rtl865x_qosProcessQueue(dev->name, queueInfo);
+	}
+
+	return 0;
+}
+
+static int htb_getClassIDByMark(__u32 mark, __u32 *classID, struct Qdisc *sch)
+{
+	struct htb_sched	*q = qdisc_priv(sch);
+	struct tcf_result	res;
+	struct tcf_proto	*tcf;
+
+	tcf = q->filter_list;
+	if(tcf)
+	{
+		if ((tc_classifyMark(mark, tcf, &res))==SUCCESS)
+		{
+			*classID = res.classid;
+			return SUCCESS;
+		}
+
+		/* we have got inner class; apply inner filter chain */
+	}
+
+	return FAILED;
+}
+
+#endif
+
 static void htb_walk(struct Qdisc *sch, struct qdisc_walker *arg)
 {
 	struct htb_sched *q = qdisc_priv(sch);
@@ -1547,6 +1812,10 @@
 	.unbind_tcf	=	htb_unbind_filter,
 	.dump		=	htb_dump_class,
 	.dump_stats	=	htb_dump_class_stats,
+#if defined(CONFIG_RTL_HW_QOS_SUPPORT)
+	.syncHwQueue =	htb_syncHwQueue,
+	.getHandleByKey	=	htb_getClassIDByMark,
+#endif
 };
 
 static struct Qdisc_ops htb_qdisc_ops __read_mostly = {
diff -uNr --ignore-all-space linux-2.6.30.9/scripts/gen_initramfs_list.sh linux-2.6.30.9-rsdk/scripts/gen_initramfs_list.sh
--- linux-2.6.30.9/scripts/gen_initramfs_list.sh	2009-10-05 16:38:08.000000000 +0100
+++ linux-2.6.30.9-rsdk/scripts/gen_initramfs_list.sh	2011-12-05 15:50:14.000000000 +0000
@@ -9,6 +9,13 @@
 # The script may also be used to generate the inputfile used for gen_init_cpio
 # This script assumes that gen_init_cpio is located in usr/ directory
 
+HOST_LINUX_VERSION=`uname -r|grep "^2\.4\."`
+if [ "$HOST_LINUX_VERSION" = "" ]; then
+lzma_exe=rtkload/lzma-26
+else
+lzma_exe=rtkload/lzma-24
+fi
+
 # error out on errors
 set -e
 
@@ -225,7 +232,7 @@
 output="/dev/stdout"
 output_file=""
 is_cpio_compressed=
-compr="gzip -9 -f"
+compr="gzip -9 -f -"
 
 arg="$1"
 case "$arg" in
@@ -239,9 +246,9 @@
 		output_file="$1"
 		cpio_list="$(mktemp ${TMPDIR:-/tmp}/cpiolist.XXXXXX)"
 		output=${cpio_list}
-		echo "$output_file" | grep -q "\.gz$" && compr="gzip -9 -f"
-		echo "$output_file" | grep -q "\.bz2$" && compr="bzip2 -9 -f"
-		echo "$output_file" | grep -q "\.lzma$" && compr="lzma -9 -f"
+		echo "$output_file" | grep -q "\.gz$" && compr="gzip -9 -f -"
+		echo "$output_file" | grep -q "\.bz2$" && compr="bzip2 -9 -f -"
+		echo "$output_file" | grep -q "\.lzma$" && compr="$lzma_exe e -eos -si -so"
 		echo "$output_file" | grep -q "\.cpio$" && compr="cat"
 		shift
 		;;
@@ -292,7 +299,7 @@
 	if [ "${is_cpio_compressed}" = "compressed" ]; then
 		cat ${cpio_tfile} > ${output_file}
 	else
-		(cat ${cpio_tfile} | ${compr}  - > ${output_file}) \
+		(cat ${cpio_tfile} | ${compr} > ${output_file}) \
 		|| (rm -f ${output_file} ; false)
 	fi
 	[ -z ${cpio_file} ] && rm ${cpio_tfile}
