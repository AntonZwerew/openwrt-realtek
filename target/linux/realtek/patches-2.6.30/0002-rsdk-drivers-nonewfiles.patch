--- linux-2.6.30.9/drivers/char/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/char/Makefile	2013-05-02 01:47:50.410227327 +0300
@@ -8,6 +8,7 @@
 FONTMAPFILE = cp437.uni
 
 obj-y	 += mem.o random.o tty_io.o n_tty.o tty_ioctl.o tty_ldisc.o tty_buffer.o tty_port.o
+EXTRA_CFLAGS += -I.
 
 obj-$(CONFIG_LEGACY_PTYS)	+= pty.o
 obj-$(CONFIG_UNIX98_PTYS)	+= pty.o
@@ -97,6 +98,8 @@ obj-$(CONFIG_CS5535_GPIO)	+= cs5535_gpio
 obj-$(CONFIG_GPIO_VR41XX)	+= vr41xx_giu.o
 obj-$(CONFIG_GPIO_TB0219)	+= tb0219.o
 obj-$(CONFIG_TELCLOCK)		+= tlclk.o
+obj-$(CONFIG_RTL_NFBI_MDIO)	+= rtl_mdio/
+obj-$(CONFIG_NFBI_HOST)		+= rtl_nfbi/
 
 obj-$(CONFIG_MWAVE)		+= mwave/
 obj-$(CONFIG_AGP)		+= agp/
--- linux-2.6.30.9/drivers/char/pty.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/char/pty.c	2013-05-02 01:47:50.487227320 +0300
@@ -27,6 +27,7 @@
 #include <linux/uaccess.h>
 #include <linux/bitops.h>
 #include <linux/devpts_fs.h>
+#include <linux/smp_lock.h>
 
 #include <asm/system.h>
 
--- linux-2.6.30.9/drivers/crypto/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/crypto/Kconfig	2013-05-02 01:47:50.559227314 +0300
@@ -209,4 +209,26 @@ config CRYPTO_DEV_PPC4XX
 	help
 	  This option allows you to have support for AMCC crypto acceleration.
 
+config CRYPTO_DEV_REALTEK
+	tristate "Driver Realtek Crypto Engine"
+	select CRYPTO_HASH
+	select CRYPTO_ALGAPI
+	select CRYPTO_BLKCIPHER
+	select CRYPTO_CBC
+	select CRYPTO_CTR
+	select CRYPTO_ECB
+	select CRYPTO_MD5
+	select CRYPTO_SHA1
+	select CRYPTO_AES
+	select CRYPTO_DES
+	help
+	  This option allows you to have support for Realtek Crypto Engine.
+
+config CRYPTO_DEV_REALTEK_TEST
+	tristate "Driver Realtek Crypto Engine Test"
+	select CRYPTO_TEST
+	depends on CRYPTO_DEV_REALTEK
+	help
+	  This option for Realtek Crypto Engine Internal Test.
+
 endif # CRYPTO_HW
--- linux-2.6.30.9/drivers/crypto/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/crypto/Makefile	2013-05-02 01:47:50.559227314 +0300
@@ -5,3 +5,4 @@ obj-$(CONFIG_CRYPTO_DEV_HIFN_795X) += hi
 obj-$(CONFIG_CRYPTO_DEV_TALITOS) += talitos.o
 obj-$(CONFIG_CRYPTO_DEV_IXP4XX) += ixp4xx_crypto.o
 obj-$(CONFIG_CRYPTO_DEV_PPC4XX) += amcc/
+obj-$(CONFIG_CRYPTO_DEV_REALTEK) += realtek/
--- linux-2.6.30.9/drivers/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/Makefile	2013-05-02 01:47:49.674227386 +0300
@@ -24,7 +24,7 @@ obj-$(CONFIG_REGULATOR)		+= regulator/
 # char/ comes before serial/ etc so that the VT console is the boot-time
 # default.
 obj-y				+= char/
-
+obj-$(CONFIG_STAGING)		+= staging/
 # gpu/ comes after char for AGP vs DRM startup
 obj-y				+= gpu/
 
@@ -65,7 +65,7 @@ obj-$(CONFIG_USB_OTG_UTILS)	+= usb/otg/
 obj-$(CONFIG_USB)		+= usb/
 obj-$(CONFIG_USB_MUSB_HDRC)	+= usb/musb/
 obj-$(CONFIG_PCI)		+= usb/
-obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
+## obj-$(CONFIG_USB_GADGET)	+= usb/gadget/
 obj-$(CONFIG_SERIO)		+= input/serio/
 obj-$(CONFIG_GAMEPORT)		+= input/gameport/
 obj-$(CONFIG_INPUT)		+= input/
@@ -105,5 +105,5 @@ obj-$(CONFIG_PPC_PS3)		+= ps3/
 obj-$(CONFIG_OF)		+= of/
 obj-$(CONFIG_SSB)		+= ssb/
 obj-$(CONFIG_VIRTIO)		+= virtio/
-obj-$(CONFIG_STAGING)		+= staging/
+
 obj-y				+= platform/
--- linux-2.6.30.9/drivers/media/video/uvc/uvc_video.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/media/video/uvc/uvc_video.c	2013-05-02 01:47:52.326227171 +0300
@@ -531,6 +531,14 @@ static void uvc_video_decode_isoc(struct
 		if (urb->iso_frame_desc[i].status < 0) {
 			uvc_trace(UVC_TRACE_FRAME, "USB isochronous frame "
 				"lost (%d).\n", urb->iso_frame_desc[i].status);
+			
+			//Start to avoid to flicking images with isochronous by jason
+			if (buf) {
+				buf->state = UVC_BUF_STATE_QUEUED;
+				buf->buf.bytesused = 0;
+				i = urb->number_of_packets;
+			}		
+			//End to avoid to flicking images with isochronous by jason
 			continue;
 		}
 
--- linux-2.6.30.9/drivers/mtd/chips/cfi_cmdset_0001.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/chips/cfi_cmdset_0001.c	2013-05-02 01:47:52.621227148 +0300
@@ -1,20 +1,10 @@
 /*
- * Common Flash Interface support:
- *   Intel Extended Vendor Command Set (ID 0x0001)
  *
- * (C) 2000 Red Hat. GPL'd
+ *  Copyright (c) 2011 Realtek Semiconductor Corp.
  *
- *
- * 10/10/2000	Nicolas Pitre <nico@cam.org>
- * 	- completely revamped method functions so they are aware and
- * 	  independent of the flash geometry (buswidth, interleave, etc.)
- * 	- scalability vs code size is completely set at compile-time
- * 	  (see include/linux/mtd/cfi.h for selection)
- *	- optimized write buffer method
- * 02/05/2002	Christopher Hoover <ch@hpl.hp.com>/<ch@murgatroid.com>
- *	- reworked lock/unlock/erase support for var size flash
- * 21/03/2007   Rodolfo Giometti <giometti@linux.it>
- * 	- auto unlock sectors on resume for auto locking flash on power up
+ *  This program is free software; you can redistribute it and/or modify
+ *  it under the terms of the GNU General Public License version 2 as
+ *  published by the Free Software Foundation.
  */
 
 #include <linux/module.h>
--- linux-2.6.30.9/drivers/mtd/chips/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/chips/Kconfig	2013-05-02 01:47:52.620227148 +0300
@@ -240,6 +240,12 @@ config MTD_XIP
 	  This allows MTD support to work with flash memory which is also
 	  used for XIP purposes.  If you're not sure what this is all about
 	  then say N.
+config RTL819X_SPI_FLASH
+        bool "RTL819x SPI flash support"
+        depends on MTD
+        help
+          Support SPI flash for MX25L,SST series
+
 
 endmenu
 
--- linux-2.6.30.9/drivers/mtd/chips/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/chips/Makefile	2013-05-02 01:47:52.620227148 +0300
@@ -13,3 +13,4 @@ obj-$(CONFIG_MTD_JEDECPROBE)	+= jedec_pr
 obj-$(CONFIG_MTD_RAM)		+= map_ram.o
 obj-$(CONFIG_MTD_ROM)		+= map_rom.o
 obj-$(CONFIG_MTD_ABSENT)	+= map_absent.o
+obj-$(CONFIG_RTL819X_SPI_FLASH) += rtl819x/
--- linux-2.6.30.9/drivers/mtd/devices/doc2001.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/devices/doc2001.c	2013-05-02 01:47:52.629227147 +0300
@@ -10,8 +10,11 @@
 #include <asm/errno.h>
 #include <asm/io.h>
 #include <asm/uaccess.h>
+#include <linux/miscdevice.h>
+#include <linux/pci.h>
 #include <linux/delay.h>
 #include <linux/slab.h>
+#include <linux/sched.h>
 #include <linux/init.h>
 #include <linux/types.h>
 #include <linux/bitops.h>
@@ -20,6 +23,48 @@
 #include <linux/mtd/nand.h>
 #include <linux/mtd/doc2000.h>
 
+#ifdef CONFIG_RTL_819X
+/*porting for RTL865xC-RTL8190 SDK by alva_zhang@2007.11*/
+#include <linux/config.h>
+#include <linux/mtd/partitions.h>
+
+#define CALL_APP_TO_LOAD_DEFAULT	// call user program to load default
+extern int flash_hw_start;
+#define noCONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 3
+extern int flash_hw_start, flash_hw_len, flash_ds_start, flash_ds_len, flash_write_flag;
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+#define RTL_BOOTCODE_END (0x6000)
+static struct mtd_partition rtl8196_partitions[ ] = {
+        {
+                name:         "boot+cfg+linux",
+                size:           (CONFIG_RTL_ROOT_IMAGE_OFFSET-0),
+                offset:         0x00000000,
+        },
+        {
+                name:           "root fs",
+                   size:        (CONFIG_RTL_FLASH_SIZE-CONFIG_RTL_ROOT_IMAGE_OFFSET),
+                offset:         (CONFIG_RTL_ROOT_IMAGE_OFFSET),
+        }
+};
+#else
+static struct mtd_partition rtl8196_partitions[ ] = {
+        {
+                name:         "boot+cfg+linux",
+                size:           0xF0000,
+                offset:         0x00000000,
+        },
+        {
+                name:           "root fs",
+                   size:        0x110000,
+                offset:         0xF0000,
+        }
+};
+#endif
+#define NB_OF(x)  (sizeof(x)/sizeof(x[0]))
+#endif /*#ifdef CONFIG_RTL_819X */
+
+
 /* #define ECC_DEBUG */
 
 /* I have no idea why some DoC chips can not use memcop_form|to_io().
@@ -32,12 +77,29 @@ static int doc_read(struct mtd_info *mtd
 		    size_t *retlen, u_char *buf);
 static int doc_write(struct mtd_info *mtd, loff_t to, size_t len,
 		     size_t *retlen, const u_char *buf);
+
+#ifdef CONFIG_RTL_819X
+/* Do nothing here*/
+#else
 static int doc_read_oob(struct mtd_info *mtd, loff_t ofs,
 			struct mtd_oob_ops *ops);
 static int doc_write_oob(struct mtd_info *mtd, loff_t ofs,
 			 struct mtd_oob_ops *ops);
+#endif
+
 static int doc_erase (struct mtd_info *mtd, struct erase_info *instr);
 
+#ifdef CONFIG_RTL_819X
+/*porting for RTL865xC-RTL8190 SDK by alva_zhang@2007.11*/
+static int erase_one_block(struct DiskOnChip *this, __u32 addr, __u32 len);
+#endif
+
+#ifdef CONFIG_RTL_819X
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+int find_section_boundary(struct mtd_info *mtd,unsigned int start, unsigned int end, unsigned int *rstart, unsigned *rend);
+#endif
+#endif
+
 static struct mtd_info *docmillist = NULL;
 
 /* Perform the required delay cycles by reading from the NOP register */
@@ -149,6 +211,10 @@ static inline void DoC_Address(void __io
 	DoC_Delay(docptr, 4);
 }
 
+#ifdef CONFIG_RTL_819X
+/*porting for RTL865xC-RTL8190 SDK by alva_zhang@2007.11*/
+/* Do nothing here*/
+#else
 /* DoC_SelectChip: Select a given flash chip within the current floor */
 static int DoC_SelectChip(void __iomem * docptr, int chip)
 {
@@ -281,6 +347,7 @@ static void DoC_ScanChips(struct DiskOnC
 	printk(KERN_INFO "%d flash chips found. Total DiskOnChip size: %ld MiB\n",
 	       this->numchips ,this->totlen >> 20);
 }
+#endif /*#ifdef CONFIG_RTL_819X */
 
 static int DoCMil_is_alias(struct DiskOnChip *doc1, struct DiskOnChip *doc2)
 {
@@ -318,9 +385,16 @@ static int DoCMil_is_alias(struct DiskOn
 void DoCMil_init(struct mtd_info *mtd)
 {
 	struct DiskOnChip *this = mtd->priv;
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 	struct DiskOnChip *old = NULL;
+#endif
 
 	/* We must avoid being called twice for the same device. */
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 	if (docmillist)
 		old = docmillist->priv;
 
@@ -337,17 +411,31 @@ void DoCMil_init(struct mtd_info *mtd)
 		else
 			old = NULL;
 	}
+#endif /*CONFIG_RTL_819X*/
 
 	mtd->name = "DiskOnChip Millennium";
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 	printk(KERN_NOTICE "DiskOnChip Millennium found at address 0x%lX\n",
 	       this->physadr);
+#endif
+
+	mtd->type = MTD_NORFLASH;
+	mtd->flags = MTD_CAP_NORFLASH;
+#ifdef CONFIG_RTL_819X
+#else
+	mtd->ecctype = MTD_ECC_RS_DiskOnChip;
+#endif
 
-	mtd->type = MTD_NANDFLASH;
-	mtd->flags = MTD_CAP_NANDFLASH;
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else	
 	mtd->size = 0;
 
 	/* FIXME: erase size is not always 8KiB */
 	mtd->erasesize = 0x2000;
+#endif
 
 	mtd->writesize = 512;
 	mtd->oobsize = 16;
@@ -357,10 +445,19 @@ void DoCMil_init(struct mtd_info *mtd)
 	mtd->unpoint = NULL;
 	mtd->read = doc_read;
 	mtd->write = doc_write;
+
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else		
 	mtd->read_oob = doc_read_oob;
 	mtd->write_oob = doc_write_oob;
+#endif
+
 	mtd->sync = NULL;
 
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else	
 	this->totlen = 0;
 	this->numchips = 0;
 	this->curfloor = -1;
@@ -368,6 +465,7 @@ void DoCMil_init(struct mtd_info *mtd)
 
 	/* Ident all the chips present. */
 	DoC_ScanChips(this);
+#endif
 
 	if (!this->totlen) {
 		kfree(mtd);
@@ -376,15 +474,199 @@ void DoCMil_init(struct mtd_info *mtd)
 		this->nextdoc = docmillist;
 		docmillist = mtd;
 		mtd->size  = this->totlen;
+//#ifdef CONFIG_RTK_MTD_ROOT
+#ifdef CONFIG_RTL_819X
+		add_mtd_partitions(mtd, rtl8196_partitions,  NB_OF(rtl8196_partitions));
+#else
 		add_mtd_device(mtd);
+#endif
 		return;
 	}
 }
 EXPORT_SYMBOL_GPL(DoCMil_init);
 
+#ifdef CONFIG_RTL_819X 
+static int doc_write_ecc (struct mtd_info *mtd, loff_t to, size_t len,
+			  size_t *retlen, const u_char *buf, u_char *eccbuf)
+{
+	int i,ret;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr =(unsigned long) this->virtadr;
+	unsigned int ofs;
+	unsigned short val,val1;
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	unsigned int rstart,rend;
+	unsigned int start,end;
+#endif
+// david ------------
+unsigned long timeo, offset;
+unsigned long flags; 
+//-------------------
+
+	/* Don't allow write past end of device */
+	if (to >= this->totlen)
+	{
+// david
+//		printk("write to >= total len\n");
+	printk(KERN_WARNING "write to >= total len\n");
+		return -EINVAL;
+	}
+	DEBUG(MTD_DEBUG_LEVEL1,"going to write len=0x%x,to =0x%x\n", (int)len, (int)to);
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	start=to;
+	end=0xFFFFFFF;
+	if(flash_write_flag & 1)
+	{
+		if(0 == start)
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_HW_SETTING_OFFSET )
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		end=CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+	}
+			
+	if(flash_write_flag & 2 )
+	{
+		if(0 == start)
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_DEFAULT_SETTING_OFFSET )
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		
+		end = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+	}
+			
+	if( flash_write_flag & 4 )
+	{
+		if(0 == start)
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_CURRENT_SETTING_OFFSET )
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;	
+		end = CONFIG_RTL_WEB_PAGES_OFFSET;
+	}
+	find_section_boundary(mtd,start,end,&rstart,&rend);
+
+#endif
+
+	*retlen = len;
+	ofs = docptr + to;
+	for(i=0; i< len; i+=2)
+	{
+// david -----------------------------------------------------
+#if 0
+		val = *(unsigned short *)buf;
+
+		*(volatile unsigned short *)(0xbfc00000 + 0x555 * 2)= 0xaa;
+		*(volatile unsigned short *)(0xbfc00000 + 0x2aa * 2)= 0x55;
+		*(volatile unsigned short *)(0xbfc00000 + 0x555 * 2)= 0xa0;
+		*(volatile unsigned short *)(ofs )= val;
+
+	       	j=0xfffff1;
+        	do{
+                	val1=*(volatile unsigned short *)(ofs);
+  	            	if( ((val1^val) & 0x80)==0 )
+ 				break;
+
+       		}while(j--!=1);
+		if (j <= 2)
+			printk("program fails\n");
+#else
+
+//		if ( ofs < (docptr+CONFIG_MTD_DOCPROBE_ADDRESS) )
+//			goto next_word;
+
+		offset = (to >> this->chipshift)*(1 << this->chipshift);
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+		if(ofs <(docptr+rstart))
+			goto next_word;
+		if(ofs >= (docptr+rend))
+		{
+			return 0;
+		}
+#else
+#if !defined(COMPACK_SETTING) && !defined(NO_CHECK_REGION)
+		if ( flash_write_flag != 0x8000
+//#ifdef CONFIG_RTK_MTD_ROOT
+#ifdef CONFIG_RTL_819X
+			|| offset < (rtl8196_partitions[0].size+ rtl8196_partitions[0].offset)
+#endif
+			)
+		{
+
+			if ( (flash_write_flag & 1) && (ofs < (docptr+flash_hw_start)) )
+				goto next_word;
+
+			if ( (flash_write_flag & 2) && (ofs < (docptr+flash_ds_start)) )
+				goto next_word;
+
+			if ( (flash_write_flag & 4) && (ofs < (docptr+flash_ds_start+flash_ds_len)) )
+				goto next_word;
+		}
+#endif // COMPACK_SETTING && NO_CHECK_REGION
+#endif //CONFIG_RTL_FLASH_MAPPING_ENABLE
+		val = *(unsigned short *)buf;
+
+		mtd_save_flags(flags);mtd_cli(); // david
+		
+		*(volatile unsigned short *)(0xbfc00000 + offset + 0x555 * 2)= 0xaa;
+		*(volatile unsigned short *)(0xbfc00000 + offset + 0x2aa * 2)= 0x55;
+		*(volatile unsigned short *)(0xbfc00000 + offset + 0x555 * 2)= 0xa0;
+		*(volatile unsigned short *)(ofs )= val;
+		
+		mtd_restore_flags(flags); // david
+
+		timeo = jiffies + (HZ * 50);
+        	do{    		
+#if 0
+			val1=*(volatile unsigned short *)(ofs);
+			if ( val1 == val )
+				break;
+#endif
+			unsigned short val2;
+      	
+			val2=*(volatile unsigned short *)(ofs);
+			val1=*(volatile unsigned short *)(ofs);	
+			
+			if (((val1^val2) & 0x40) != 0)
+				continue;	 	        
+	 	        if (((val1^val) & 0x80) != 0)
+ 				continue;
+ 			if ( val1 == val )		
+				break;
+//--------------	      	    	
+		} while ( !time_after(jiffies, timeo) );
+
+		if ( time_after(jiffies, timeo)) {
+			printk(KERN_WARNING "program timeout!");
+			printk(KERN_WARNING " write: %x, read:%x, addr: %x\n", val, val1, ofs);
+			return -1;
+		}
+
+#ifndef COMPACK_SETTING
+next_word:
+#endif
+
+#endif
+//---------------------------------------------------------
+		ofs += 2;
+		buf += 2;
+	
+	}
+
+	ret = 0 ;
+//	printk("in doc_write_ecc ret=%08x\n", ret);
+	return ret;
+}
+#endif /* #ifdef CONFIG_RTL_819X  */
+
 static int doc_read (struct mtd_info *mtd, loff_t from, size_t len,
 		     size_t *retlen, u_char *buf)
 {
+#ifdef CONFIG_RTL_819X 
+static int doc_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf, u_char *eccbuf);
+/* Just a special case of doc_read_ecc */
+	return doc_read_ecc(mtd, from, len, retlen, buf, NULL);
+#else
 	int i, ret;
 	volatile char dummy;
 	unsigned char syndrome[6], eccbuf[6];
@@ -491,11 +773,49 @@ static int doc_read (struct mtd_info *mt
 	WriteDOC(DOC_ECC_DIS, docptr , ECCConf);
 
 	return ret;
+
+#endif /* #ifdef CONFIG_RTL_819X  */
+}
+
+#ifdef CONFIG_RTL_819X 
+static int doc_read_ecc (struct mtd_info *mtd, loff_t from, size_t len,
+			 size_t *retlen, u_char *buf, u_char *eccbuf)
+{
+	int i;
+	unsigned short tmp;
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr+from;
+
+	/* Don't allow read past end of device */
+	if (from >= this->totlen)
+		return -EINVAL;
+	for(i=0; i< len; i+=2)
+	{
+		tmp = *(volatile unsigned short *)(docptr);
+		*(unsigned short *)buf = tmp;
+		buf += 2;
+		docptr +=2;
+	}
+	if (len & 0x01)
+	{
+		tmp = *(volatile unsigned long *)(docptr);
+        *(unsigned char *)buf = (tmp >> 8) & 0xff;
+	}
+
+	/* Let the caller know we completed it */
+	*retlen = len;
+
+	return 0;
 }
+#endif /*#ifdef CONFIG_RTL_819X */
 
 static int doc_write (struct mtd_info *mtd, loff_t to, size_t len,
 		      size_t *retlen, const u_char *buf)
 {
+#ifdef CONFIG_RTL_819X 
+       char eccbuf[6];
+	return doc_write_ecc(mtd, to, len, retlen, buf, eccbuf);
+#else
 	int i,ret = 0;
 	char eccbuf[6];
 	volatile char dummy;
@@ -617,8 +937,12 @@ static int doc_write (struct mtd_info *m
 	*retlen = len;
 
 	return ret;
+#endif /*#ifdef CONFIG_RTL_819X  */
 }
 
+#ifdef CONFIG_RTL_819X 
+/*do nothing here*/
+#else
 static int doc_read_oob(struct mtd_info *mtd, loff_t ofs,
 			struct mtd_oob_ops *ops)
 {
@@ -753,9 +1077,229 @@ static int doc_write_oob(struct mtd_info
 
 	return ret;
 }
+#endif /*#ifdef CONFIG_RTL_819X  */
+
+#ifdef CONFIG_RTL_819X
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+int find_section_boundary(struct mtd_info *mtd,unsigned int start, unsigned int end, unsigned int *rstart, unsigned *rend)
+{
+	int i = 0;
+	int j = 0;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+	while ((i < mtd->numeraseregions) &&
+		(start >= regions[i].offset)) {
+		i++;
+	}
+	i--;
+
+	j = 1;
+	while((j <= regions[i].numblocks) &&
+		(start >= (regions[i].offset+regions[i].erasesize*j))) {
+		j++;
+	}
+	*rstart=(regions[i].offset+regions[i].erasesize*(j-1));
+	
+	i=0;
+	while ((i < mtd->numeraseregions) &&
+		(end >= regions[i].offset)) {
+		 i++;
+	}
+	i--;
+
+	j = 1;
+	while((j <= regions[i].numblocks) &&
+		(end >= (regions[i].offset+regions[i].erasesize*j))) {
+		j++;
+	}
+	*rend=(regions[i].offset+regions[i].erasesize*j);
+	
+}
+#endif
+#endif
 
 int doc_erase (struct mtd_info *mtd, struct erase_info *instr)
 {
+#ifdef CONFIG_RTL_819X 
+
+struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long adr, len;
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE	
+	unsigned int rstart,rend;
+        unsigned int start,end;
+#endif
+	int i;
+	int first;
+	struct mtd_erase_region_info *regions = mtd->eraseregions;
+
+	DEBUG(MTD_DEBUG_LEVEL1, "going to erase sector addr=%08x,len=%08x\n",
+		instr->addr, instr->len);
+
+	if (instr->addr > mtd->size) {
+		printk(KERN_WARNING "Erase addr greater than max size (0x%x > 0x%x)\n",
+			instr->addr, mtd->size );
+		return -EINVAL;
+	}
+
+	if ((instr->len + instr->addr) > mtd->size) {
+		printk(KERN_WARNING "Erase size greater than max size (0x%x + 0x%x > 0x%x)\n",
+		       instr->addr, instr->len, mtd->size );
+		return -EINVAL;
+	}
+
+	/* Check that both start and end of the requested erase are
+	 * aligned with the erasesize at the appropriate addresses.
+	 */
+
+	i = 0;
+
+        /* Skip all erase regions which are ended before the start of
+           the requested erase. Actually, to save on the calculations,
+           we skip to the first erase region which starts after the
+           start of the requested erase, and then go back one.
+        */
+
+        while ((i < mtd->numeraseregions) &&
+	       (instr->addr >= regions[i].offset)) {
+               i++;
+	}
+        i--;
+
+	/* OK, now i is pointing at the erase region in which this
+	 * erase request starts. Check the start of the requested
+	 * erase range is aligned with the erase size which is in
+	 * effect here.
+	 */
+
+	if (instr->addr & (regions[i].erasesize-1)) {
+		return -EINVAL;
+	}
+
+	/* Remember the erase region we start on. */
+
+	first = i;
+
+	/* Next, check that the end of the requested erase is aligned
+	 * with the erase region at that address.
+	 */
+
+	while ((i < mtd->numeraseregions) &&
+	       ((instr->addr + instr->len) >= regions[i].offset)) {
+                i++;
+	}
+
+	/* As before, drop back one to point at the region in which
+	 * the address actually falls.
+	 */
+
+	i--;
+
+	if ((instr->addr + instr->len) & (regions[i].erasesize-1)) {
+                return -EINVAL;
+	}
+
+
+	adr = instr->addr;
+	len = instr->len;
+
+	i = first;
+	instr->state = MTD_ERASING;
+
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	start=adr;
+	end=0xFFFFFFF;
+	if(flash_write_flag & 1)
+	{
+		if(0 == start)
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_HW_SETTING_OFFSET )
+			start = CONFIG_RTL_HW_SETTING_OFFSET;
+		end = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+	}
+			
+       if(flash_write_flag & 2 )
+       {
+    		if(0 == start)
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_DEFAULT_SETTING_OFFSET )
+			start = CONFIG_RTL_DEFAULT_SETTING_OFFSET;
+		end = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+    	}
+			
+    	if(flash_write_flag & 4 )
+   	{
+   		if(0 == start)
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+		else if( start > CONFIG_RTL_CURRENT_SETTING_OFFSET )
+			start = CONFIG_RTL_CURRENT_SETTING_OFFSET;
+		
+		end = CONFIG_RTL_WEB_PAGES_OFFSET;
+   	}
+
+	find_section_boundary(mtd,start,end,&rstart,&rend);
+
+	//printk("line[%d] rstart 0x%x rend 0x%x\n",__LINE__,rstart,rend);
+	
+	/*don't erase bootcode*/
+	if(rstart < RTL_BOOTCODE_END)
+		rstart = RTL_BOOTCODE_END;
+	
+	//printk("line[%d] rstart 0x%x rend 0x%x\n",__LINE__,rstart,rend);
+#endif
+
+	while (len) {
+//		if (adr >= CONFIG_MTD_DOCPROBE_ADDRESS) {
+
+#if defined(COMPACK_SETTING) || defined(NO_CHECK_REGION)
+		if ( erase_one_block(this, adr, regions[i].erasesize) )
+			return -1;
+
+#else
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	   if(adr >= rstart)
+#else
+		if ( ((flash_write_flag & 1) && (adr == flash_hw_start)) ||
+				((flash_write_flag & 2) &&(adr >= flash_ds_start && adr < (flash_ds_start+flash_ds_len))) 
+				|| ((flash_write_flag & 4) && (adr >= (flash_ds_start+flash_ds_len))) 
+//#ifdef CONFIG_RTK_MTD_ROOT
+#ifdef CONFIG_RTL_819X
+				|| (adr >= (rtl8196_partitions[0].size+ rtl8196_partitions[0].offset))
+#endif			
+				|| (flash_write_flag == 0x8000)
+				) 
+#endif	
+		{
+			if ( erase_one_block(this, adr, regions[i].erasesize) )
+				return -1;
+		}
+			
+#endif // COMPACK_SETTING || NO_CHECK_REGION
+
+		adr += regions[i].erasesize;
+		if (len < regions[i].erasesize)
+			len = 0;
+		else
+			len -= regions[i].erasesize;
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+		if(rend <= adr)
+		{
+			/*no need to erase other block*/
+			len=0;
+		}
+#endif
+		if ( adr >= (regions[i].offset + regions[i].erasesize*regions[i].numblocks))
+			i++;
+	}
+
+	instr->state = MTD_ERASE_DONE;
+	if (instr->callback) {
+		instr->callback(instr);
+	}
+
+	return 0;
+#else
 	volatile char dummy;
 	struct DiskOnChip *this = mtd->priv;
 	__u32 ofs = instr->addr;
@@ -809,7 +1353,52 @@ int doc_erase (struct mtd_info *mtd, str
 	mtd_erase_callback(instr);
 
 	return 0;
+
+#endif /*#ifdef CONFIG_RTL_819X */
+}
+
+#ifdef CONFIG_RTL_819X 
+static int erase_one_block(struct DiskOnChip *this, __u32 addr, __u32 len)
+{
+	unsigned long timeo;
+	unsigned long docptr = this->virtadr;
+	__u32 ofs, offset;
+	unsigned long flags; // david
+
+
+	DEBUG(MTD_DEBUG_LEVEL1, "Erase sector, addr=0x%x, docptr=0x%x, len=0x%x\n",
+		(int)addr, (int)docptr, (int)len);
+
+	// issue erase command!
+	ofs = docptr + addr;
+
+	offset = (addr >> this->chipshift)*(1 << this->chipshift);
+
+	mtd_save_flags(flags);mtd_cli(); // david
+	*(volatile unsigned short *)(docptr + offset + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(docptr + offset + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(docptr + offset + 0x555 * 2) = 0x80;
+	*(volatile unsigned short *)(docptr + offset + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(docptr + offset + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(ofs ) = 0x30;
+	mtd_restore_flags(flags); // david
+
+	timeo = jiffies + (HZ * 40);
+
+	while (1) {
+     		if ((*(volatile unsigned short *)(ofs))==0xffff) {
+			DEBUG(MTD_DEBUG_LEVEL1, "Erase success!\n");
+			break;
+		}
+		if (time_after(jiffies, timeo)) {
+			printk(KERN_WARNING "Erase timeout!\n");
+			return -1;
+		}		
+		udelay(1);
+     	}
+	return 0;
 }
+#endif /*#ifdef CONFIG_RTL_819X */
 
 /****************************************************************************
  *
--- linux-2.6.30.9/drivers/mtd/devices/docprobe.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/devices/docprobe.c	2013-05-02 01:47:52.630227147 +0300
@@ -36,7 +36,7 @@
    <linux-mtd@lists.infradead.org>.
 */
 #define DOC_SINGLE_DRIVER
-
+#include <linux/config.h>
 #include <linux/kernel.h>
 #include <linux/module.h>
 #include <asm/errno.h>
@@ -56,10 +56,68 @@
 #define CONFIG_MTD_DOCPROBE_ADDRESS 0
 #endif
 
+#ifdef CONFIG_RTL_819X
+// david ----------------------
+/* MXIC */
+#define MANUFACTURER_MXIC	0x00C2
+#define MX29LV800B		0x225B
+#define MX29LV160AB		0x2249
+#define MX29LV320AB		0x22A8
+#define MX29LV640AB		0x22CB
+
+/*AMD*/
+#define MANUFACTURER_AMD	0x0001
+#define AM29LV800BB		0x225B
+#define AM29LV160DB		0x2249
+#define AM29LV320DB		0x22F9
+
+/*ST*/
+#define MANUFACTURER_ST		0x0020
+#define M29W160DB		0X2249
+
+/* ESMT */
+#define MANUFACTURER_ESMT	0x008C
+#define F49L160BA		0x2249
+
+/* SAMSUNG */
+#define MANUFACTURER_SAMSUNG	0x00EC
+#define K8D1716UBC		0x2277
+
+/* ESI */
+#define MANUFACTURER_ESI	0x004A
+#define ES29LV320D		0x22F9
+
+/* EON */
+#define MANUFACTURER_EON	0x007F
+#define EN29LV160A		0x2249
+
+#ifdef CONFIG_RTL8196B
+#define FLASH_BASE 0xbd000000
+#else
+#define FLASH_BASE 0xbe000000
+#endif
+
+struct flash_info {
+	const __u16 mfr_id;
+	const __u16 dev_id;
+	const char *name;
+	const u_long size;
+	const int shift;  // shift number of chip size
+	const int numeraseregions;
+	const struct mtd_erase_region_info regions[4];
+};
+
+static int probeChip(struct DiskOnChip *doc, struct mtd_info *mtd);
+//-----------------------------
+#endif /*#ifdef CONFIG_RTL_819X*/
+
+//static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
+//module_param(doc_config_location, ulong, 0);
+//MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
 
-static unsigned long doc_config_location = CONFIG_MTD_DOCPROBE_ADDRESS;
-module_param(doc_config_location, ulong, 0);
-MODULE_PARM_DESC(doc_config_location, "Physical memory address at which to probe for DiskOnChip");
+#ifdef CONFIG_RTL_819X
+ /* Do nothing here*/
+#else
 
 static unsigned long __initdata doc_locations[] = {
 #if defined (__alpha__) || defined(__i386__) || defined(__x86_64__)
@@ -76,6 +134,13 @@ static unsigned long __initdata doc_loca
 	0xe0000, 0xe2000, 0xe4000, 0xe6000,
 	0xe8000, 0xea000, 0xec000, 0xee000,
 #endif /*  CONFIG_MTD_DOCPROBE_HIGH */
+#elif defined(__PPC__)
+	0xe4000000,
+#elif defined(CONFIG_MOMENCO_OCELOT)
+	0x2f000000,
+        0xff000000,
+#elif defined(CONFIG_MOMENCO_OCELOT_G) || defined (CONFIG_MOMENCO_OCELOT_C)
+        0xff000000,
 #else
 #warning Unknown architecture for DiskOnChip. No default probe locations defined
 #endif
@@ -217,8 +282,9 @@ static inline int __init doccheck(void _
 #endif
 	return 0;
 }
+#endif /*#ifdef CONFIG_RTL_819X*/
 
-static int docfound;
+//static int docfound;
 
 extern void DoC2k_init(struct mtd_info *);
 extern void DoCMil_init(struct mtd_info *);
@@ -229,11 +295,18 @@ static void __init DoC_Probe(unsigned lo
 	void __iomem *docptr;
 	struct DiskOnChip *this;
 	struct mtd_info *mtd;
-	int ChipID;
+	//int ChipID;
 	char namebuf[15];
 	char *name = namebuf;
+
+	
+	char *im_funcname = NULL;
+	char *im_modname = NULL;
+	
+	
 	void (*initroutine)(struct mtd_info *) = NULL;
 
+#ifndef CONFIG_RTL_819X
 	docptr = ioremap(physadr, DOC_IOREMAP_LEN);
 
 	if (!docptr)
@@ -302,8 +375,286 @@ static void __init DoC_Probe(unsigned lo
 		kfree(mtd);
 	}
 	iounmap(docptr);
+#else
+      docptr = FLASH_BASE;
+      //-----------------------------
+
+
+	mtd = kmalloc(sizeof(struct DiskOnChip) + sizeof(struct mtd_info), GFP_KERNEL);
+
+	if (!mtd) {
+			printk(KERN_WARNING "Cannot allocate memory for data structures. Dropping.\n");
+			iounmap((void *)docptr);
+			return;
 }
 
+	this = (struct DiskOnChip *)(&mtd[1]);
+
+	memset((char *)mtd,0, sizeof(struct mtd_info));
+	memset((char *)this, 0, sizeof(struct DiskOnChip));
+
+	mtd->priv = this;
+	this->virtadr = docptr;
+	this->physadr = physadr;
+	this->ChipID = DOC_ChipID_DocMil;
+
+	name="Millennium";
+	im_funcname = "DoCMil_init";
+	im_modname = "doc2001";
+
+	if ( probeChip(this, mtd) == 0) // david added,
+		initroutine = &DoCMil_init;
+
+	if (initroutine) {
+		(*initroutine)(mtd);
+		return;
+	}
+	printk(KERN_NOTICE "Cannot find driver for DiskOnChip %s at 0x%lX\n", name, physadr);
+	iounmap((void *)docptr);
+
+#endif /*#ifdef CONFIG_RTL_819X*/
+}
+
+#ifdef CONFIG_RTL_819X
+// david -------------------------------------------------------------------
+static int probeChip(struct DiskOnChip *doc, struct mtd_info *mtd)
+{
+	/* Keep this table on the stack so that it gets deallocated after the
+	 * probe is done.
+	 */
+	const struct flash_info table[] = {
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV800B,
+		name: "MXIC MX29LV800B",
+		size: 0x00100000,
+		shift: 20,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV160AB,
+		name: "MXIC MX29LV160AB",
+		size: 0x00200000,
+		shift: 21,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV320AB,
+		name: "MXIC MX29LV320AB",
+		size: 0x00400000,
+		shift: 22,
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 63 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV800BB,
+		name: "AMD AM29LV800BB",
+		size: 0x00100000,
+		shift: 20,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 15 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV160DB,
+		name: "AMD AM29LV160DB",
+		size: 0x00200000,
+		shift: 21,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_AMD,
+		dev_id: AM29LV320DB,
+		name: "AMD AM29LV320DB",
+		size: 0x00400000,
+		shift: 22,
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 63 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_ST,
+		dev_id: M29W160DB,
+		name: "ST M29W160DB",
+		size: 0x00200000,
+		shift: 21,/*21 bit=> that is 2 MByte size*/
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_MXIC,
+		dev_id: MX29LV640AB,
+		name: "MXIC MX29LV640AB",
+		size: 0x00800000,
+		shift: 23,/*22 bit=> that is 8 MByte size*/
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:   8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 127 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_SAMSUNG,
+		dev_id: K8D1716UBC,
+		name: "SAMSUNG K8D1716UBC",
+		size: 0x00200000,
+		shift: 21,/*21 bit=> that is 2 MByte size*/
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_ESMT,
+		dev_id: F49L160BA,
+		name: "ESMT F49L160BA",
+		size: 0x00200000,
+		shift: 21,/*21 bit=> that is 2 MByte size*/
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_ESI,
+		dev_id: ES29LV320D,
+		name: "ESI ES29LV320D",
+		size: 0x00400000,
+		shift: 22,/*22 bit=> that is 4 MByte size*/
+		numeraseregions: 2,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x02000, numblocks:  8 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 63 }
+		}
+	},
+	{
+		mfr_id: MANUFACTURER_EON,
+		dev_id: EN29LV160A,
+		name: "EON EN29LV160A",
+		size: 0x00200000,
+		shift: 21,
+		numeraseregions: 4,
+		regions: {
+			{ offset: 0x000000, erasesize: 0x04000, numblocks:  1 },
+			{ offset: 0x004000, erasesize: 0x02000, numblocks:  2 },
+			{ offset: 0x008000, erasesize: 0x08000, numblocks:  1 },
+			{ offset: 0x010000, erasesize: 0x10000, numblocks: 31 }
+		}
+	}
+	};
+
+	struct DiskOnChip *this = (struct DiskOnChip *)mtd->priv;
+	unsigned long docptr = this->virtadr;
+	__u16 mfid, devid;
+	int i, j, k, interleave=1, chipsize;
+
+	// issue reset and auto-selection command
+	*(volatile unsigned short *)(FLASH_BASE) = 0xf0;
+
+	*(volatile unsigned short *)(FLASH_BASE + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(FLASH_BASE + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(FLASH_BASE + 0x555 * 2) = 0x90;
+
+	mfid = *((volatile unsigned short *)docptr);
+	devid = *((volatile unsigned short *)(docptr + 1*2));
+
+        *(volatile unsigned short *)(FLASH_BASE) = 0xf0;
+
+	for (i=0; i< sizeof(table)/sizeof(table[0]); i++) {
+		if ( mfid==table[i].mfr_id && devid==table[i].dev_id)
+			break;
+	}
+	if ( i == sizeof(table)/sizeof(table[0]) )
+		return -1;
+
+	// Look for 2nd flash
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size) = 0xf0;
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size + 0x555 * 2) = 0xaa;
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size + 0x2aa * 2) = 0x55;
+	*(volatile unsigned short *)(FLASH_BASE + table[i].size + 0x555 * 2) = 0x90;
+
+	mfid = *((volatile unsigned short *)(docptr + table[i].size));
+	devid = *((volatile unsigned short *)(docptr + table[i].size + 1*2));
+
+	*(volatile unsigned short *)(FLASH_BASE+table[i].size) = 0xf0;
+	if ( mfid==table[i].mfr_id && devid==table[i].dev_id) {
+		interleave++;
+	}
+
+	printk(KERN_NOTICE "Found %d x %ldM Byte %s at 0x%lx\n",
+		interleave, (table[i].size)/(1024*1024), table[i].name, docptr);
+
+	mtd->size = table[i].size*interleave;
+	mtd->numeraseregions = table[i].numeraseregions*interleave;
+
+	mtd->eraseregions = kmalloc(sizeof(struct mtd_erase_region_info) *
+				    mtd->numeraseregions*interleave, GFP_KERNEL);
+	if (!mtd->eraseregions) {
+		printk(KERN_WARNING "Failed to allocate "
+		       "memory for MTD erase region info\n");
+		kfree(mtd);
+		return -1;
+	}
+
+	for (k=0, chipsize=0; interleave>0; interleave--, chipsize+=table[i].size) {
+		for (j=0; j<table[i].numeraseregions; j++, k++) {
+			mtd->eraseregions[k].offset = table[i].regions[j].offset+chipsize;
+			mtd->eraseregions[k].erasesize = table[i].regions[j].erasesize;
+			mtd->eraseregions[k].numblocks = table[i].regions[j].numblocks;
+			if (mtd->erasesize < mtd->eraseregions[k].erasesize)
+				mtd->erasesize = mtd->eraseregions[k].erasesize;
+		}
+	}
+
+	this->totlen = mtd->size;
+	this->numchips = interleave;
+	this->chipshift = table[i].shift;
+
+	return 0;
+}
+//---------------------------------------------------------------------------
+#endif /*#ifdef CONFIG_RTL_819X */
+
 
 /****************************************************************************
  *
@@ -313,6 +664,14 @@ static void __init DoC_Probe(unsigned lo
 
 static int __init init_doc(void)
 {
+#ifdef CONFIG_RTL_819X
+      printk(KERN_NOTICE "RealTek E-Flash System Driver. (C) 2002 RealTek Corp.\n");
+	DoC_Probe(CONFIG_MTD_DOCPROBE_ADDRESS);
+	/* So it looks like we've been used and we get unloaded */
+//	MOD_INC_USE_COUNT;
+//	MOD_DEC_USE_COUNT;
+	return 0;
+#else
 	int i;
 
 	if (doc_config_location) {
@@ -328,6 +687,7 @@ static int __init init_doc(void)
 	if (!docfound)
 		printk(KERN_INFO "No recognised DiskOnChip devices found\n");
 	return -EAGAIN;
+#endif	
 }
 
 module_init(init_doc);
--- linux-2.6.30.9/drivers/mtd/maps/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/maps/Makefile	2013-05-02 01:47:52.636227146 +0300
@@ -62,3 +62,4 @@ obj-$(CONFIG_MTD_INTEL_VR_NOR)	+= intel_
 obj-$(CONFIG_MTD_BFIN_ASYNC)	+= bfin-async-flash.o
 obj-$(CONFIG_MTD_RBTX4939)	+= rbtx4939-flash.o
 obj-$(CONFIG_MTD_VMU)		+= vmu-flash.o
+obj-$(CONFIG_RTL819X_SPI_FLASH) += rtl819x_flash.o
--- linux-2.6.30.9/drivers/mtd/mtdblock.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/mtd/mtdblock.c	2013-05-02 01:47:52.649227145 +0300
@@ -18,6 +18,26 @@
 #include <linux/mtd/blktrans.h>
 #include <linux/mutex.h>
 
+#include <linux/config.h>
+
+#ifdef CONFIG_RTL_819X
+// david ---------------
+//#define CONFIG_MTD_DEBUG
+#define CONFIG_MTD_DEBUG_VERBOSE 3
+
+
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+int flash_write_flag=0;		// 1: hw setting 2: default setting, 4: current setting, 8: system image
+#else
+int flash_hw_start=0x6000;	// hw setting start address
+int flash_hw_len=0x2000;	// hw setting length
+int flash_ds_start=0x8000;	// default & current setting start address
+int flash_ds_len=0x8000;	// default & current setting length
+
+int flash_write_flag=0;		// 1: hw setting 2: default setting, 4: current setting, 8: system image
+#endif
+#endif /*#ifdef CONFIG_RTL_819X */
+
 
 static struct mtdblk_dev {
 	struct mtd_info *mtd;
@@ -134,6 +154,58 @@ static int do_cached_write (struct mtdbl
 	DEBUG(MTD_DEBUG_LEVEL2, "mtdblock: write on \"%s\" at 0x%lx, size 0x%x\n",
 		mtd->name, pos, len);
 
+	
+#ifdef CONFIG_RTL_819X
+#ifdef CONFIG_RTL_FLASH_MAPPING_ENABLE
+	/*since len is normal 0x200 less than every section*/
+	if(flash_write_flag != 0x8000) 
+	{
+		flash_write_flag = 0;
+		if ( pos >= CONFIG_RTL_HW_SETTING_OFFSET && pos < CONFIG_RTL_DEFAULT_SETTING_OFFSET ) {
+			flash_write_flag |= 1;
+			if ((pos+len) > CONFIG_RTL_DEFAULT_SETTING_OFFSET ) {
+				flash_write_flag |= 2;
+				if ((pos+len) > CONFIG_RTL_CURRENT_SETTING_OFFSET )
+					flash_write_flag |= 4;
+			}
+		}
+		if ( pos >= CONFIG_RTL_DEFAULT_SETTING_OFFSET && pos < CONFIG_RTL_CURRENT_SETTING_OFFSET ) {
+			flash_write_flag |= 2;
+			if ((pos+len) > CONFIG_RTL_CURRENT_SETTING_OFFSET ) {
+				flash_write_flag |= 4;
+			}
+		}
+		else if ( pos >= CONFIG_RTL_CURRENT_SETTING_OFFSET && pos < CONFIG_RTL_WEB_PAGES_OFFSET ){
+			flash_write_flag |= 4;
+		}
+	}
+#else
+// david --------------
+	if ( flash_write_flag != 0x8000) 
+	{
+		flash_write_flag = 0;
+		if (pos >= flash_hw_start && pos < (flash_hw_start+flash_hw_len) ) {
+			flash_write_flag |= 1;
+			if ((len - flash_hw_len) > 0) {
+				flash_write_flag |= 2;
+				if ((len - flash_ds_len -flash_hw_len) > 0)
+					flash_write_flag |= 4;
+			}
+		}
+		if (pos >= flash_ds_start && pos < (flash_ds_start+flash_ds_len) ) {
+			flash_write_flag |= 2;
+			if ((len - flash_ds_len) > 0) {
+				flash_write_flag |= 4;
+			}
+		}
+		else if ( pos >= (flash_ds_start+flash_ds_len) ){
+			flash_write_flag |= 4;
+		}
+	}
+//---------------------
+#endif //CONFIG_RTL_FLASH_MAPPING_ENABLE
+#endif
+
 	if (!sect_size)
 		return mtd->write(mtd, pos, len, &retlen, buf);
 
--- linux-2.6.30.9/drivers/net/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/Kconfig	2013-05-02 01:47:52.704227141 +0300
@@ -27,7 +27,7 @@ menuconfig NETDEVICES
 if NETDEVICES
 
 config COMPAT_NET_DEV_OPS
-       default y
+       default n
        bool "Enable older network device API compatibility"
        ---help---
           This option enables kernel compatibility with older network devices
@@ -2146,6 +2146,22 @@ config R8169_VLAN
 
 	  If in doubt, say Y.
 
+config R8168
+    tristate "Realtek 8168 gigabit ethernet support"
+    depends on PCI
+    select CRC32
+    default y
+    ---help---
+      Say Y here if you have a Realtek 8168 PCI Gigabit Ethernet adapter.
+
+      To compile this driver as a module, choose M here: the module
+      will be called r8168.  This is recommended.
+
+config R8168_NAPI
+    bool "NAPI support"
+    depends on R8168
+    default y
+
 config SB1250_MAC
 	tristate "SB1250 Gigabit Ethernet support"
 	depends on SIBYTE_SB1xxx_SOC
@@ -2987,19 +3003,39 @@ config PPP_BSDCOMP
 	  module; it is called bsd_comp and will show up in the directory
 	  modules once you have said "make modules". If unsure, say N.
 
-config PPP_MPPE
-       tristate "PPP MPPE compression (encryption) (EXPERIMENTAL)"
-       depends on PPP && EXPERIMENTAL
-       select CRYPTO
+config PPP_MPPE_MPPC
+       tristate "Microsoft PPP compression/encryption (MPPC/MPPE)"
+       depends on PPP
        select CRYPTO_SHA1
        select CRYPTO_ARC4
-       select CRYPTO_ECB
        ---help---
-         Support for the MPPE Encryption protocol, as employed by the
-	 Microsoft Point-to-Point Tunneling Protocol.
+         Support for the Microsoft Point-To-Point Compression (RFC2118) and 
+         Microsoft Point-To-Point Encryption (RFC3078). These protocols are
+         supported by Microsoft Windows and wide range of "hardware" access
+         servers. MPPE is common protocol in Virtual Private Networks. According
+         to RFC3078, MPPE supports 40, 56 and 128-bit key lengths. Depending on
+         PPP daemon configuration on both ends of the link, following scenarios
+         are possible:
+               - only compression (MPPC) is used,
+               - only encryption (MPPE) is used,
+               - compression and encryption (MPPC+MPPE) are used.
+
+         Please note that Hi/Fn (http://www.hifn.com) holds patent on MPPC so
+         you should check if this patent is valid in your country in order to
+         avoid legal problems.
 
-	 See http://pptpclient.sourceforge.net/ for information on
-	 configuring PPTP clients and servers to utilize this method.
+         For more information please visit http://mppe-mppc.alphacron.de
+ 
+         To compile this driver as a module, choose M here. The module will
+         be called ppp_mppe_mppc.ko.
+
+
+config PPP_IDLE_TIMEOUT_REFINE
+	tristate "PPP idle timeout refine"
+	depends on PPP
+	help
+	  skip some kinds of packets from DUT to WAN or WAN to DUT that will cause PPPoE/PPTP/L2TP idle timeout 
+          can't work well
 
 config PPPOE
 	tristate "PPP over Ethernet (EXPERIMENTAL)"
@@ -3155,4 +3191,22 @@ config VIRTIO_NET
 	  This is the virtual network driver for virtio.  It can be used with
           lguest or QEMU based VMMs (like KVM or Xen).  Say Y or M.
 
+config R8198EP
+        bool "Realtek 8198 slave pcie support"
+        ---help---
+          Say Y here if you have a Realtek 8198 slave pcie Ethernet adapter.
+
+config R8198EP_HOST
+        tristate "Host site view for slave PCIe RTL8198"
+        depends on R8198EP
+        ---help---
+          Say Y here if you have a Realtek 8198 slave pcie Ethernet adapter.
+config R8198EP_DEVICE
+        tristate "Device site view for salve PCIe RTL8198"
+        depends on R8198EP
+        ---help---
+          Say Y here if you have a Realtek 8198 slave pcie Ethernet adapter.
+
+
+source "drivers/net/rtl819x/Kconfig"
 endif # NETDEVICES
--- linux-2.6.30.9/drivers/net/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/Makefile	2013-05-02 01:47:52.705227141 +0300
@@ -142,7 +142,7 @@ obj-$(CONFIG_PPP_ASYNC) += ppp_async.o
 obj-$(CONFIG_PPP_SYNC_TTY) += ppp_synctty.o
 obj-$(CONFIG_PPP_DEFLATE) += ppp_deflate.o
 obj-$(CONFIG_PPP_BSDCOMP) += bsd_comp.o
-obj-$(CONFIG_PPP_MPPE) += ppp_mppe.o
+obj-$(CONFIG_PPP_MPPE_MPPC) += ppp_mppe_mppc.o
 obj-$(CONFIG_PPPOE) += pppox.o pppoe.o
 obj-$(CONFIG_PPPOL2TP) += pppox.o pppol2tp.o
 
@@ -218,6 +218,7 @@ obj-$(CONFIG_VETH) += veth.o
 obj-$(CONFIG_NET_NETX) += netx-eth.o
 obj-$(CONFIG_DL2K) += dl2k.o
 obj-$(CONFIG_R8169) += r8169.o
+obj-$(CONFIG_R8168) += r8168/
 obj-$(CONFIG_AMD8111_ETH) += amd8111e.o
 obj-$(CONFIG_IBMVETH) += ibmveth.o
 obj-$(CONFIG_S2IO) += s2io.o
@@ -271,3 +272,12 @@ obj-$(CONFIG_VIRTIO_NET) += virtio_net.o
 obj-$(CONFIG_SFC) += sfc/
 
 obj-$(CONFIG_WIMAX) += wimax/
+
+obj-$(CONFIG_RTL_819X_SWCORE) += rtl819x/built-in.o
+subdir-$(CONFIG_RTL_819X_SWCORE) += rtl819x
+
+obj-$(CONFIG_RTK_VLAN_SUPPORT) += rtk_vlan.o
+obj-$(CONFIG_R8198EP) += r8198ep/
+
+#DIR_RTLASIC = $(DIR_LINUX)/drivers/net/rtl819x/
+#EXTRA_CFLAGS += -I$(DIR_RTLASIC)
--- linux-2.6.30.9/drivers/net/ppp_generic.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/ppp_generic.c	2013-05-02 01:47:53.185227102 +0300
@@ -42,6 +42,9 @@
 #include <linux/tcp.h>
 #include <linux/smp_lock.h>
 #include <linux/spinlock.h>
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#include <linux/smp_lock.h>
+#endif
 #include <linux/rwsem.h>
 #include <linux/stddef.h>
 #include <linux/device.h>
@@ -52,6 +55,49 @@
 #include <linux/nsproxy.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
+#include <linux/icmp.h>
+
+#if defined(CONFIG_RTL_PPPOE_HWACC) || defined (CONFIG_RTL_FAST_PPPOE) 
+#include <linux/if_pppox.h>
+#endif
+
+#include <net/rtl/rtl_types.h>
+#if defined(CONFIG_RTL_819X)
+#include <net/rtl/rtl_nic.h>
+#endif
+
+#include <net/rtl/rtl865x_netif.h>
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+#include <net/rtl/rtl865x_ppp.h>
+#endif
+
+#if defined (CONFIG_RTL_HW_QOS_SUPPORT)	// sync from voip customer for multiple ppp
+#include <net/rtl/rtl865x_outputQueue.h>
+#endif
+
+#if defined(NAT_SPEEDUP)||defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	#define FAST_PPTP
+	#define FAST_L2TP
+#endif
+
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+enum SE_TYPE
+{
+	/*1:if_ether, 2:pppoe,3:pptp,4:l2tp*/
+	SE_ETHER = 1,
+	SE_PPPOE = 2,
+	SE_PPTP = 3,
+	SE_L2TP = 4,
+};
+#else
+enum SE_TYPE
+{
+	SE_PPPOE = 1,
+	SE_PPTP = 2,
+	SE_L2TP = 3,
+};
+#endif /*CONFIG_RTL865X_LAYERED_DRIVER*/
+
 
 #define PPP_VERSION	"2.4.2"
 
@@ -88,10 +134,18 @@ struct ppp_file {
 	int		dead;		/* unit/channel has been shut down */
 };
 
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#define PF_TO_X(pf, X)         ((X *)((char *)(pf) - offsetof(X, file)))
+#else
 #define PF_TO_X(pf, X)		container_of(pf, X, file)
+#endif
 
 #define PF_TO_PPP(pf)		PF_TO_X(pf, struct ppp)
 #define PF_TO_CHANNEL(pf)	PF_TO_X(pf, struct channel)
+//#if defined(CONFIG_PPP_MPPE_MPPC)
+//#undef ROUNDUP
+//#define ROUNDUP(n, x)          (((n) + (x) - 1) / (x))
+//#endif
 
 /*
  * Data structure describing one ppp unit.
@@ -107,6 +161,9 @@ struct ppp {
 	spinlock_t	rlock;		/* lock for receive side 58 */
 	spinlock_t	wlock;		/* lock for transmit side 5c */
 	int		mru;		/* max receive unit 60 */
+#if defined(CONFIG_PPP_MPPE_MPPC)
+	int             mru_alloc;      /* MAX(1500,MRU) for dev_alloc_skb() */
+#endif
 	unsigned int	flags;		/* control bits 64 */
 	unsigned int	xstate;		/* transmit state bits 68 */
 	unsigned int	rstate;		/* receive state bits 6c */
@@ -130,6 +187,7 @@ struct ppp {
 	u32		minseq;		/* MP: min of most recent seqnos */
 	struct sk_buff_head mrq;	/* MP: receive reconstruction queue */
 #endif /* CONFIG_PPP_MULTILINK */
+	struct net_device_stats stats;	/* statistics */
 #ifdef CONFIG_PPP_FILTER
 	struct sock_filter *pass_filter;	/* filter for packets to pass */
 	struct sock_filter *active_filter;/* filter for pkts to reset idle */
@@ -138,6 +196,67 @@ struct ppp {
 	struct net	*ppp_net;	/* the net we belong to */
 };
 
+#ifdef FAST_PPTP
+#define MPPE_CCOUNT(p) ((((p)[2] & 0x0f) << 8) + (p)[3])
+typedef struct {
+    unsigned i;
+    unsigned j;
+    unsigned char S[256];
+} arcfour_context;
+
+
+#define MPPE_MAX_KEY_LEN       16      /* largest key length (128-bit) */	/* reference from ppp_mppe.h*/
+
+
+#if defined(CONFIG_PPP_MPPE_MPPC)
+typedef struct ppp_mppe_state {		/* reference from ppp_mppe_mppc.c	*/
+    struct crypto_tfm *arc4_tfm;
+    u8		master_key[MPPE_MAX_KEY_LEN];
+    u8		session_key[MPPE_MAX_KEY_LEN];
+    u8		mppc;		/* do we use compression (MPPC)? */
+    u8		mppe;		/* do we use encryption (MPPE)? */
+    u8		keylen;		/* key length in bytes */
+    u8		bitkeylen;	/* key length in bits */
+    u16		ccount;		/* coherency counter */
+    u16		bits;		/* MPPC/MPPE control bits */
+    u8		stateless;	/* do we use stateless mode? */
+    u8		nextflushed;	/* set A bit in the next outgoing packet;
+				   used only by compressor*/
+    u8		flushexpected;	/* drop packets until A bit is received;
+				   used only by decompressor*/
+    u8		*hist;		/* MPPC history */
+    u16		*hash;		/* Hash table; used only by compressor */
+    u16		histptr;	/* history "cursor" */
+    int		unit;
+    int		debug;
+    int		mru;
+    struct compstat stats;
+}ppp_mppe_state;
+#else
+typedef struct ppp_mppe_state {			/* reference from ppp_mppe.c	*/
+	struct crypto_blkcipher *arc4;
+	struct crypto_hash *sha1;
+	unsigned char *sha1_digest;
+	unsigned char master_key[MPPE_MAX_KEY_LEN];
+	unsigned char session_key[MPPE_MAX_KEY_LEN];
+	unsigned keylen;	/* key length in bytes             */
+	/* NB: 128-bit == 16, 40-bit == 8! */
+	/* If we want to support 56-bit,   */
+	/* the unit has to change to bits  */
+	unsigned char bits;	/* MPPE control bits */
+	unsigned ccount;	/* 12-bit coherency count (seqno)  */
+	unsigned stateful;	/* stateful mode flag */
+	int discard;		/* stateful mode packet loss flag */
+	int sanity_errors;	/* take down LCP if too many */
+	int unit;
+	int debug;
+	struct compstat stats;
+} ppp_mppe_state;
+#endif
+
+#endif
+
+
 /*
  * Bits in flags: SC_NO_TCP_CCID, SC_CCP_OPEN, SC_CCP_UP, SC_LOOP_TRAFFIC,
  * SC_MULTILINK, SC_MP_SHORTSEQ, SC_MP_XSHORTSEQ, SC_COMP_TCP, SC_REJ_COMP_TCP,
@@ -145,9 +264,15 @@ struct ppp {
  * Bits in rstate: SC_DECOMP_RUN, SC_DC_ERROR, SC_DC_FERROR.
  * Bits in xstate: SC_COMP_RUN
  */
+#if defined(CONFIG_PPP_MPPE_MPPC)
+#define SC_FLAG_BITS	(SC_NO_TCP_CCID|SC_CCP_OPEN|SC_CCP_UP|SC_LOOP_TRAFFIC \
+			 |SC_MULTILINK|SC_MP_SHORTSEQ|SC_MP_XSHORTSEQ \
+			 |SC_COMP_TCP|SC_REJ_COMP_TCP)
+#else
 #define SC_FLAG_BITS	(SC_NO_TCP_CCID|SC_CCP_OPEN|SC_CCP_UP|SC_LOOP_TRAFFIC \
 			 |SC_MULTILINK|SC_MP_SHORTSEQ|SC_MP_XSHORTSEQ \
 			 |SC_COMP_TCP|SC_REJ_COMP_TCP|SC_MUST_COMP)
+#endif
 
 /*
  * Private data structure for each channel.
@@ -169,6 +294,12 @@ struct channel {
 	u32		lastseq;	/* MP: last sequence # received */
 	int     speed;		/* speed of the corresponding ppp channel*/
 #endif /* CONFIG_PPP_MULTILINK */
+#if defined(CONFIG_RTL_PPPOE_HWACC) || defined (CONFIG_RTL_FAST_PPPOE)
+	u8		pppoe;
+	u8		rsv1;
+	u16		rsv2;
+#endif /* CONFIG_RTL865X_HW_TABLES */
+
 };
 
 /*
@@ -235,13 +366,31 @@ struct ppp_net {
 static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
 			struct file *file, unsigned int cmd, unsigned long arg);
 static void ppp_xmit_process(struct ppp *ppp);
+#ifdef FAST_PPTP
+static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw);
+#else
 static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb);
+#endif
+
 static void ppp_push(struct ppp *ppp);
 static void ppp_channel_push(struct channel *pch);
 static void ppp_receive_frame(struct ppp *ppp, struct sk_buff *skb,
 			      struct channel *pch);
 static void ppp_receive_error(struct ppp *ppp);
+#ifdef FAST_PPTP
+struct sk_buff *ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw);
+#ifdef CONFIG_FAST_PATH_MODULE
+int (*FastPath_hook9)( void )=NULL;
+int (*FastPath_hook10)(struct sk_buff *skb)=NULL;
+EXPORT_SYMBOL(FastPath_hook9);
+EXPORT_SYMBOL(FastPath_hook10);
+EXPORT_SYMBOL(ppp_receive_nonmp_frame);
+#endif
+
+#else
 static void ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb);
+#endif
+
 static struct sk_buff *ppp_decompress_frame(struct ppp *ppp,
 					    struct sk_buff *skb);
 #ifdef CONFIG_PPP_MULTILINK
@@ -555,10 +704,25 @@ static int get_filter(void __user *arg,
 }
 #endif /* CONFIG_PPP_FILTER */
 
+#if defined (CONFIG_RTL_FAST_PPPOE)
+extern int set_pppoe_info(char *ppp_dev, char *wan_dev, unsigned short sid,
+							unsigned int our_ip,unsigned int	peer_ip,
+							unsigned char * our_mac, unsigned char *peer_mac);
+
+extern int clear_pppoe_info(char *ppp_dev, char *wan_dev, unsigned short sid,
+								unsigned int our_ip,unsigned int	peer_ip,
+								unsigned char * our_mac, unsigned char *peer_mac);
+extern int get_pppoe_last_rx_tx(char * ppp_dev,char * wan_dev,unsigned short sid,
+									unsigned int our_ip,unsigned int peer_ip,
+									unsigned char * our_mac,unsigned char * peer_mac,
+									unsigned long * last_rx,unsigned long * last_tx);
+extern int fast_pppoe_fw;
+
+#endif
 static long ppp_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
 {
 	struct ppp_file *pf = file->private_data;
-	struct ppp *ppp;
+	struct ppp *ppp = NULL;
 	int err = -EFAULT, val, val2, i;
 	struct ppp_idle idle;
 	struct npioctl npi;
@@ -611,11 +775,83 @@ static long ppp_ioctl(struct file *file,
 		case PPPIOCCONNECT:
 			if (get_user(unit, p))
 				break;
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2	// sync from voip customer for multiple ppp
+			#if defined (CONFIG_RTL_HW_QOS_SUPPORT)
+			rtl865x_qosRearrangeRule();
+			#endif
+#endif
 			err = ppp_connect_channel(pch, unit);
+
+#if defined(CONFIG_RTL_PPPOE_HWACC) || defined (CONFIG_RTL_FAST_PPPOE)
+ 			if(err == 0 && pch->pppoe==TRUE)
+			{
+				struct sock *sk = (struct sock *) pch->chan->private;
+				struct pppox_sock *po = pppox_sk(sk);
+				struct net_device *local_dev = po->pppoe_dev;
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+				{
+
+
+					rtl865x_attachMasterNetif(pch->ppp->dev->name, local_dev->name);
+					//add the netif mapping table
+					rtl_add_ps_drv_netif_mapping(pch->ppp->dev,pch->ppp->dev->name);	// sync from voip customer for multiple ppp
+				}
+				rtl865x_addPpp(pch->ppp->dev->name , (ether_addr_t*)po->pppoe_pa.remote, po->pppoe_pa.sid, SE_PPPOE);
+#endif
+#endif
+#if defined (CONFIG_RTL_FAST_PPPOE)
+				set_pppoe_info(pch->ppp->dev->name, local_dev->name, po->pppoe_pa.sid,
+							0,0,NULL, (unsigned char *)po->pppoe_pa.remote);	
+#endif							
+			}
+#endif
+
+
+		#ifdef FAST_PPTP // sync from voip customer for multiple ppp
+			{
+				extern void set_pptp_device(char *ppp_device);
+				extern int fast_pptp_fw;
+				if (err==0 && fast_pptp_fw)
+					set_pptp_device(pch->ppp->dev->name);
+			}
+		#endif
+
+		#ifdef FAST_L2TP // sync from voip customer for multiple ppp
+			{
+				extern void set_l2tp_device(char *ppp_device);
+				if (err==0)
+					set_l2tp_device(pch->ppp->dev->name);
+			}
+		#endif
+
 			break;
 
 		case PPPIOCDISCONN:
 			err = ppp_disconnect_channel(pch);
+#if defined(CONFIG_RTL_PPPOE_HWACC) || defined (CONFIG_RTL_FAST_PPPOE)
+			if (err == 0 && pch->pppoe==TRUE)
+			{
+				pch->pppoe = FALSE;
+
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+
+				rtl865x_detachMasterNetif(ppp->dev->name);
+				//del the netif mapping table
+				rtl_del_ps_drv_netif_mapping(pch->ppp->dev);
+				rtl865x_delPppbyIfName(ppp->dev->name);
+#endif
+
+#endif
+
+#if defined (CONFIG_RTL_FAST_PPPOE)
+				clear_pppoe_info(pch->ppp->dev->name, NULL, 0,
+										0,0,NULL, NULL); 
+#endif
+			}
+#endif
+
 			break;
 
 		default:
@@ -642,7 +878,13 @@ static long ppp_ioctl(struct file *file,
 	case PPPIOCSMRU:
 		if (get_user(val, p))
 			break;
+#if defined(CONFIG_PPP_MPPE_MPPC)
+             ppp->mru_alloc = ppp->mru = val;
+       	if (ppp->mru_alloc < PPP_MRU)
+           		ppp->mru_alloc = PPP_MRU;   /* increase for broken peers */
+#else
 		ppp->mru = val;
+#endif
 		err = 0;
 		break;
 
@@ -689,6 +931,53 @@ static long ppp_ioctl(struct file *file,
 		break;
 
 	case PPPIOCGIDLE:
+#ifdef FAST_L2TP
+		{
+			extern int fast_l2tp_fw;
+			unsigned long get_fast_l2tp_lastxmit(void);
+		 	unsigned long fastl2tp_lastxmit;
+			if(fast_l2tp_fw)
+			{
+				fastl2tp_lastxmit = get_fast_l2tp_lastxmit();
+				if(ppp->last_xmit < fastl2tp_lastxmit)
+					ppp->last_xmit = fastl2tp_lastxmit;
+			}
+		}
+#endif
+#ifdef FAST_PPTP
+		{
+			extern int fast_pptp_fw;
+			extern unsigned long get_fastpptp_lastxmit(void);
+			unsigned long fastpptp_lastxmit;
+			if(fast_pptp_fw)
+			{
+				fastpptp_lastxmit = get_fastpptp_lastxmit();
+				if(ppp->last_xmit < fastpptp_lastxmit)
+					ppp->last_xmit = fastpptp_lastxmit;
+			}
+		}
+#endif
+#if defined (CONFIG_RTL_FAST_PPPOE)
+		{
+			unsigned long fast_pppoe_last_rx=0;
+			unsigned long fast_pppoe_last_tx=0;
+
+			if(fast_pppoe_fw)
+			{
+				if(ppp->dev!=NULL)
+				{
+					get_pppoe_last_rx_tx(ppp->dev->name,NULL,0,0,0,NULL,NULL,&fast_pppoe_last_rx,&fast_pppoe_last_tx);
+
+					if(ppp->last_xmit < fast_pppoe_last_tx)
+						ppp->last_xmit = fast_pppoe_last_tx; 
+					
+					if(ppp->last_recv < fast_pppoe_last_rx)
+						ppp->last_xmit = fast_pppoe_last_rx;	
+				}
+			}
+		}
+#endif
+
 		idle.xmit_idle = (jiffies - ppp->last_xmit) / HZ;
 		idle.recv_idle = (jiffies - ppp->last_recv) / HZ;
 		if (copy_to_user(argp, &idle, sizeof(idle)))
@@ -788,6 +1077,15 @@ static long ppp_ioctl(struct file *file,
 	return err;
 }
 
+struct net_device_stats *get_ppp_stats(struct ppp *ppp)
+{
+	return (&ppp->stats);
+}
+
+#ifdef CONFIG_FAST_PATH_MODULE
+EXPORT_SYMBOL(get_ppp_stats);
+#endif
+
 static int ppp_unattached_ioctl(struct net *net, struct ppp_file *pf,
 			struct file *file, unsigned int cmd, unsigned long arg)
 {
@@ -951,13 +1249,114 @@ out:
 /*
  * Network interface unit routines.
  */
-static int
-ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+ #if defined(FAST_L2TP)
+extern int fast_l2tp_to_wan(void *skb);
+extern int check_for_fast_l2tp_to_wan(void *skb);
+extern void event_ppp_dev_down(const char * name);
+#endif
+#if defined(FAST_PPTP) || defined(FAST_L2TP)
+int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#else
+static int ppp_start_xmit(struct sk_buff *skb, struct net_device *dev)
+#endif
+
 {
 	struct ppp *ppp = netdev_priv(dev);
 	int npi, proto;
 	unsigned char *pp;
 
+#ifdef FAST_PPTP
+	int is_fast_fw=0;
+   #if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	extern int fast_pptp_fw;
+	#ifdef CONFIG_FAST_PATH_MODULE
+	if((FastPath_hook9!=NULL) &&(FastPath_hook10!=NULL))
+	{
+		if (FastPath_hook9()) {
+			if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L')
+			{
+				is_fast_fw=1;
+				memset(skb->cb, '\x0', 3);
+			}
+			else {
+				extern int fast_pptp_to_wan(struct sk_buff *skb);
+				if (FastPath_hook10(skb))
+					return 0;
+			}
+		}
+	}
+	#else
+	if (fast_pptp_fw) {
+		if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L')
+		{
+			is_fast_fw=1;
+			memset(skb->cb, '\x0', 3);
+		}
+		else {
+			extern int is_pptp_device(char *ppp_device);	// sync from voip customer for multiple ppp
+			extern int fast_pptp_to_wan(void *skb);
+			if (is_pptp_device(ppp->dev->name) && fast_pptp_to_wan((void*)skb))	// sync from voip customer for multiple ppp
+				return 0;
+		}
+	}
+	#endif
+   #else
+	if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L')
+		is_fast_fw=1;
+   #endif
+#endif
+
+#if 0
+#ifdef FAST_L2TP
+#ifndef FAST_PPTP
+		int is_fast_fw=0;
+#endif
+
+#ifdef CONFIG_RTL_IPTABLES_FAST_PATH
+#if 0//def CONFIG_FAST_PATH_MODULE
+		if((FastPath_hook9!=NULL) &&(FastPath_hook10!=NULL))
+		{
+			if (FastPath_hook9()) {
+			if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L') {
+				is_fast_fw = 1;
+				memset(skb->cb, '\x0', 3);
+			}
+			else {
+				//extern int fast_pptp_to_wan(struct sk_buff *skb);
+#ifdef CONFIG_RTL865X_HW_PPTPL2TP
+				if (!accelerate && FastPath_hook10(skb))
+					return 0;
+#else
+				if (FastPath_hook10(skb))
+					return 0;
+#endif /* CONFIG_RTL865X_HW_PPTPL2TP */
+			}
+			}
+		}
+#else
+		extern int fast_l2tp_fw;
+		if (fast_l2tp_fw) {
+			if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L') {
+				is_fast_fw = 1;
+				memset(skb->cb, '\x0', 3);
+			}
+			else {
+				extern int is_l2tp_device(char *ppp_device);
+				extern int fast_l2tp_to_wan(struct sk_buff *skb);
+				if (is_l2tp_device(ppp->dev->name)&&fast_l2tp_to_wan(skb))
+					return 0;
+			}
+		}
+#endif
+#else
+		if (skb->cb[0]=='R' && skb->cb[1]=='T' && skb->cb[2]=='L') {
+			is_fast_fw = 1;
+			memset(skb->cb, '\x0', 3);
+		}
+#endif
+#endif
+#endif
+
 	npi = ethertype_to_npindex(ntohs(skb->protocol));
 	if (npi < 0)
 		goto outf;
@@ -985,9 +1384,37 @@ ppp_start_xmit(struct sk_buff *skb, stru
 	pp[0] = proto >> 8;
 	pp[1] = proto;
 
+#ifdef FAST_PPTP
+	if (is_fast_fw)
+		ppp_send_frame(ppp, skb, 1);
+	else {
+#ifdef FAST_L2TP
+			skb_pull(skb,2);
+			extern int is_l2tp_device(char *ppp_device);	// sync from voip customer for multiple ppp
+			if (is_l2tp_device(ppp->dev->name) && (check_for_fast_l2tp_to_wan((void*)skb)==1) && (fast_l2tp_to_wan((void*)skb) == 1)) // sync from voip customer for multiple ppp
+			{
+				/* Note: if pkt go here, l2tp dial-on-demand will not be triggered,
+				so some risk exist here! -- 2010/04/25 zj */
+				return 0;
+			}
+			else
+			{
+				pp = skb_push(skb, 2);
+				proto = npindex_to_proto[npi];
+				pp[0] = proto >> 8;
+				pp[1] = proto;
+			}
+#endif
+		netif_stop_queue(dev);
+		skb_queue_tail(&ppp->file.xq, skb);
+		ppp_xmit_process(ppp);
+	}
+#else
 	netif_stop_queue(dev);
 	skb_queue_tail(&ppp->file.xq, skb);
 	ppp_xmit_process(ppp);
+#endif
+
 	return 0;
 
  outf:
@@ -1050,7 +1477,11 @@ static void ppp_setup(struct net_device
 	dev->hard_header_len = PPP_HDRLEN;
 	dev->mtu = PPP_MTU;
 	dev->addr_len = 0;
+#if defined(CONFIG_RTL_819X)
+	dev->tx_queue_len = 64;
+#else
 	dev->tx_queue_len = 3;
+#endif
 	dev->type = ARPHRD_PPP;
 	dev->flags = IFF_POINTOPOINT | IFF_NOARP | IFF_MULTICAST;
 	dev->features |= NETIF_F_NETNS_LOCAL;
@@ -1074,7 +1505,12 @@ ppp_xmit_process(struct ppp *ppp)
 		ppp_push(ppp);
 		while (!ppp->xmit_pending
 		       && (skb = skb_dequeue(&ppp->file.xq)))
+#ifdef FAST_PPTP
+			ppp_send_frame(ppp, skb, 0);
+#else
 			ppp_send_frame(ppp, skb);
+#endif
+
 		/* If there's no work left to do, tell the core net
 		   code that we can accept some more. */
 		if (!ppp->xmit_pending && !skb_peek(&ppp->file.xq))
@@ -1083,6 +1519,7 @@ ppp_xmit_process(struct ppp *ppp)
 	ppp_xmit_unlock(ppp);
 }
 
+#if !defined(CONFIG_PPP_MPPE_MPPC)
 static inline struct sk_buff *
 pad_compress_skb(struct ppp *ppp, struct sk_buff *skb)
 {
@@ -1132,19 +1569,81 @@ pad_compress_skb(struct ppp *ppp, struct
 	}
 	return new_skb;
 }
+#endif
+
+/*
+ * some kinds of packets from DUT to WAN will cause ppp interface active when lan==>wan traffic is off, 
+ * so we skip these packets. otherwise the ppp idletime out can't work well 
+ * return value 1 means this packet won't set the ppp to active
+ */
+#if defined(CONFIG_PPP_IDLE_TIMEOUT_REFINE)
+int timeoutCheck_skipp_pkt(struct iphdr *iph)
+{
+	
+	if(iph == NULL)
+	{
+		printk("the iphdr for PPP_IDLE_TIMEOUT_REFINE is NULL, is may cause some isses\n");
+		return 0;
+	}
+
+	if(iph->protocol == IPPROTO_ICMP)
+	{
+		struct icmphdr *icmph= (void *)iph + iph->ihl*4;
+		// we don't care dest unreacheable pkts(to wan) while recode last tx time
+		if(icmph->type==ICMP_DEST_UNREACH)
+		{
+			printk("it is ICMP dest unreacheable packet\n");
+			//if(net_ratelimit())printk("skip a icmp dest unreachable pkt from lan to wan\n");
+			return 1;
+		}
+	}
+	else if(iph->protocol == IPPROTO_TCP)
+	{
+		struct tcphdr *tcph;
+		tcph = (void *)iph + iph->ihl*4;
+		// we don't care tcp fin/rst pkts(to wan) while recode last tx time
+		if(tcph->fin || tcph->rst)
+		{
+			//if(net_ratelimit())printk("skip a tcp fin/rst pkt fin: %d rst :%d from lan to wan\n", tcph->fin, tcph->rst);
+			return 1;
+		}
+	}	
+	else if(iph->protocol == IPPROTO_IGMP)
+	{
+		// we don't care IGMP packets
+		printk("it is ICMP packet\n");
+		return 1;
+	}
+		
+	return 0;
+}
+#else //fastpath assemble code will call this function anyway.
+int timeoutCheck_skipp_pkt(struct iphdr *iph)
+{
+	return 0;
+}
+#endif
 
 /*
  * Compress and send a frame.
  * The caller should have locked the xmit path,
  * and xmit_pending should be 0.
  */
-static void
-ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
+#ifdef FAST_PPTP
+static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw)
+#else
+static void ppp_send_frame(struct ppp *ppp, struct sk_buff *skb)
+#endif
+
 {
 	int proto = PPP_PROTO(skb);
 	struct sk_buff *new_skb;
 	int len;
 	unsigned char *cp;
+#if defined(CONFIG_PPP_IDLE_TIMEOUT_REFINE)
+	struct iphdr *iphp;
+	iphp = (struct iphdr *)((unsigned char *)(skb->data+2));
+#endif
 
 	if (proto < 0x8000) {
 #ifdef CONFIG_PPP_FILTER
@@ -1168,6 +1667,9 @@ ppp_send_frame(struct ppp *ppp, struct s
 		skb_pull(skb, 2);
 #else
 		/* for data packets, record the time */
+#if defined(CONFIG_PPP_IDLE_TIMEOUT_REFINE)
+		if(timeoutCheck_skipp_pkt(iphp)!=1)
+#endif
 		ppp->last_xmit = jiffies;
 #endif /* CONFIG_PPP_FILTER */
 	}
@@ -1175,6 +1677,13 @@ ppp_send_frame(struct ppp *ppp, struct s
 	++ppp->dev->stats.tx_packets;
 	ppp->dev->stats.tx_bytes += skb->len - 2;
 
+#if defined(FAST_PPTP) && defined(NAT_SPEEDUP)
+{
+	extern void update_fast_pptp_state(void);
+ 	update_fast_pptp_state();
+}
+#endif
+
 	switch (proto) {
 	case PPP_IP:
 		if (!ppp->vj || (ppp->flags & SC_COMP_TCP) == 0)
@@ -1213,12 +1722,69 @@ ppp_send_frame(struct ppp *ppp, struct s
 	case PPP_CCP:
 		/* peek at outbound CCP frames */
 		ppp_ccp_peek(ppp, skb, 0);
+#if defined(CONFIG_PPP_MPPE_MPPC)
+               if (CCP_CODE(skb->data+2) == CCP_RESETACK
+                   && (ppp->xcomp->compress_proto == CI_MPPE
+                       || ppp->xcomp->compress_proto == CI_LZS)) {
+                   --ppp->dev->stats.tx_packets;
+                   ppp->dev->stats.tx_bytes -= skb->len - 2;
+                   kfree_skb(skb);
+                   return;
+               }
+#endif
 		break;
 	}
 
 	/* try to do packet compression */
 	if ((ppp->xstate & SC_COMP_RUN) && ppp->xc_state
 	    && proto != PPP_LCP && proto != PPP_CCP) {
+#if defined(CONFIG_PPP_MPPE_MPPC)
+               int comp_ovhd = 0;
+               /*
+                * because of possible data expansion when MPPC or LZS
+                * is used, allocate compressor's buffer 12.5% bigger
+                * than MTU
+                */
+               if (ppp->xcomp->compress_proto == CI_MPPE)
+                   comp_ovhd = ((ppp->dev->mtu * 9) / 8) + 1 + MPPE_OVHD;
+               else if (ppp->xcomp->compress_proto == CI_LZS)
+                   comp_ovhd = ((ppp->dev->mtu * 9) / 8) + 1 + LZS_OVHD;
+               new_skb = alloc_skb(ppp->dev->mtu + ppp->dev->hard_header_len
+                                   + comp_ovhd, GFP_ATOMIC);
+               if (new_skb == 0) {
+                       printk(KERN_ERR "PPP: no memory (comp pkt)\n");
+                        goto drop;
+                }
+               if (ppp->dev->hard_header_len > PPP_HDRLEN)
+                       skb_reserve(new_skb,
+                                   ppp->dev->hard_header_len - PPP_HDRLEN);
+
+               /* compressor still expects A/C bytes in hdr */
+               len = ppp->xcomp->compress(ppp->xc_state, skb->data - 2,
+                                          new_skb->data, skb->len + 2,
+                                          ppp->dev->mtu + PPP_HDRLEN);
+               if (len > 0 && (ppp->flags & SC_CCP_UP)) {
+                       kfree_skb(skb);
+                       skb = new_skb;
+                       skb_put(skb, len);
+                       skb_pull(skb, 2);       /* pull off A/C bytes */
+               } else if (len == 0) {
+                       /* didn't compress, or CCP not up yet */
+                       kfree_skb(new_skb);
+               } else {
+                       /*
+                        * (len < 0)
+                        * MPPE requires that we do not send unencrypted
+                        * frames.  The compressor will return -1 if we
+                        * should drop the frame.  We cannot simply test
+                        * the compress_proto because MPPE and MPPC share
+                        * the same number.
+                        */
+                       printk(KERN_ERR "ppp: compressor dropped pkt\n");
+                       kfree_skb(new_skb);
+                        goto drop;
+               }
+#else
 		if (!(ppp->flags & SC_CCP_UP) && (ppp->flags & SC_MUST_COMP)) {
 			if (net_ratelimit())
 				printk(KERN_ERR "ppp: compression required but down - pkt dropped.\n");
@@ -1227,6 +1793,7 @@ ppp_send_frame(struct ppp *ppp, struct s
 		skb = pad_compress_skb(ppp, skb);
 		if (!skb)
 			goto drop;
+#endif
 	}
 
 	/*
@@ -1242,6 +1809,9 @@ ppp_send_frame(struct ppp *ppp, struct s
 	}
 
 	ppp->xmit_pending = skb;
+#ifdef FAST_PPTP
+	if (!is_fast_fw)
+#endif
 	ppp_push(ppp);
 	return;
 
@@ -1637,7 +2207,11 @@ ppp_receive_frame(struct ppp *ppp, struc
 			ppp_receive_mp_frame(ppp, skb, pch);
 		else
 #endif /* CONFIG_PPP_MULTILINK */
+#ifdef FAST_PPTP
+			ppp_receive_nonmp_frame(ppp, skb, 0);
+#else
 			ppp_receive_nonmp_frame(ppp, skb);
+#endif
 		return;
 	}
 
@@ -1657,12 +2231,38 @@ ppp_receive_error(struct ppp *ppp)
 		slhc_toss(ppp->vj);
 }
 
-static void
-ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)
+#ifdef FAST_PPTP
+struct sk_buff *ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb, int is_fast_fw)
+#else
+static void ppp_receive_nonmp_frame(struct ppp *ppp, struct sk_buff *skb)
+#endif
+
 {
 	struct sk_buff *ns;
 	int proto, len, npi;
 
+//brad add for pptp mppe rx out of order
+#ifdef FAST_PPTP
+	if(is_fast_fw){
+		ppp_mppe_state *state;
+		unsigned int curr_ccount=0;
+			if((skb->data[2] & 0x10) == 0x10){
+					state = (ppp_mppe_state *) ppp->rc_state;
+					curr_ccount = MPPE_CCOUNT(skb->data);
+					if(state->ccount < 4096 && state->ccount != 0 ){
+						if(curr_ccount < state->ccount && curr_ccount > 0){
+								kfree_skb(skb);
+								return NULL;
+							}
+					}else if(curr_ccount == 4095 && state->ccount == 0){
+								kfree_skb(skb);
+								return NULL;
+
+					}
+			}
+		}
+#endif
+
 	/*
 	 * Decompress the frame, if compressed.
 	 * Note that some decompressors need to see uncompressed frames
@@ -1672,8 +2272,10 @@ ppp_receive_nonmp_frame(struct ppp *ppp,
 	    && (ppp->rstate & (SC_DC_FERROR | SC_DC_ERROR)) == 0)
 		skb = ppp_decompress_frame(ppp, skb);
 
+#if !defined(CONFIG_PPP_MPPE_MPPC)
 	if (ppp->flags & SC_MUST_COMP && ppp->rstate & SC_DC_FERROR)
 		goto err;
+#endif
 
 	proto = PPP_PROTO(skb);
 	switch (proto) {
@@ -1737,6 +2339,12 @@ ppp_receive_nonmp_frame(struct ppp *ppp,
 
 	npi = proto_to_npindex(proto);
 	if (npi < 0) {
+#ifdef FAST_PPTP
+		if (is_fast_fw) {
+			kfree_skb(skb);
+			return NULL;
+		}
+#endif
 		/* control or unknown frame - pass it to pppd */
 		skb_queue_tail(&ppp->file.rq, skb);
 		/* limit queue length by dropping old frames */
@@ -1786,14 +2394,30 @@ ppp_receive_nonmp_frame(struct ppp *ppp,
 			skb->dev = ppp->dev;
 			skb->protocol = htons(npindex_to_ethertype[npi]);
 			skb_reset_mac_header(skb);
+#ifdef FAST_PPTP
+			if (is_fast_fw)
+				return skb;
+			else
+#endif
+#if defined(CONFIG_RTL_819X)&&defined(RX_TASKLET)
+			netif_receive_skb(skb);
+#else
 			netif_rx(skb);
+#endif
 		}
 	}
+#ifdef FAST_PPTP
+	return NULL;
+#else
 	return;
+#endif
 
  err:
 	kfree_skb(skb);
 	ppp_receive_error(ppp);
+#ifdef FAST_PPTP
+	return NULL;
+#endif
 }
 
 static struct sk_buff *
@@ -1814,10 +2438,18 @@ ppp_decompress_frame(struct ppp *ppp, st
 
 		switch(ppp->rcomp->compress_proto) {
 		case CI_MPPE:
+#if defined(CONFIG_PPP_MPPE_MPPC)
+			obuff_size = ppp->mru_alloc + PPP_HDRLEN + 1;
+#else
 			obuff_size = ppp->mru + PPP_HDRLEN + 1;
+#endif
 			break;
 		default:
+#if defined(CONFIG_PPP_MPPE_MPPC)
+			obuff_size = ppp->mru_alloc + PPP_HDRLEN;
+#else
 			obuff_size = ppp->mru + PPP_HDRLEN;
+#endif
 			break;
 		}
 
@@ -1854,7 +2486,18 @@ ppp_decompress_frame(struct ppp *ppp, st
 	return skb;
 
  err:
+ #if defined(CONFIG_PPP_MPPE_MPPC)
+       if (ppp->rcomp->compress_proto != CI_MPPE
+           && ppp->rcomp->compress_proto != CI_LZS) {
+           /*
+            * If decompression protocol isn't MPPE/MPPC or LZS, we set
+            * SC_DC_ERROR flag and wait for CCP_RESETACK
+            */
 	ppp->rstate |= SC_DC_ERROR;
+       }
+ #else
+	ppp->rstate |= SC_DC_ERROR;
+ #endif
 	ppp_receive_error(ppp);
 	return skb;
 }
@@ -1943,7 +2586,11 @@ ppp_receive_mp_frame(struct ppp *ppp, st
 
 	/* Pull completed packets off the queue and receive them. */
 	while ((skb = ppp_mp_reconstruct(ppp)))
+#ifdef FAST_PPTP
+		ppp_receive_nonmp_frame(ppp, skb, 0);
+#else
 		ppp_receive_nonmp_frame(ppp, skb);
+#endif
 
 	return;
 
@@ -2169,6 +2816,19 @@ int ppp_unit_number(struct ppp_channel *
 	return unit;
 }
 
+#if defined (CONFIG_RTL_PPPOE_HWACC) || defined (CONFIG_RTL_FAST_PPPOE)
+/*
+ * Mark the pppoe type for a channel
+ */
+void ppp_channel_pppoe(struct ppp_channel *chan)
+{
+	struct channel *pch = chan->ppp;
+
+	pch->pppoe = TRUE;
+}
+#endif
+
+
 /*
  * Disconnect a channel from the generic layer.
  * This must be called in process context.
@@ -2541,6 +3201,9 @@ ppp_create_interface(struct net *net, in
 	ppp = netdev_priv(dev);
 	ppp->dev = dev;
 	ppp->mru = PPP_MRU;
+#if defined(CONFIG_PPP_MPPE_MPPC)
+	ppp->mru_alloc = PPP_MRU;
+#endif
 	init_ppp_file(&ppp->file, INTERFACE);
 	ppp->file.hdrlen = PPP_HDRLEN - 2;	/* don't count proto bytes */
 	for (i = 0; i < NUM_NP; ++i)
@@ -2633,7 +3296,15 @@ init_ppp_file(struct ppp_file *pf, int k
 static void ppp_shutdown_interface(struct ppp *ppp)
 {
 	struct ppp_net *pn;
-
+#ifdef CONFIG_RTL_PPPOE_HWACC
+	char dev_name[IFNAMSIZ];
+	memcpy(dev_name, ppp->dev->name, IFNAMSIZ);
+#endif
+
+#if defined (CONFIG_RTL_FAST_PPPOE)
+	clear_pppoe_info(ppp->dev->name, NULL, 0,
+								0,0,NULL, NULL); 
+#endif
 	pn = ppp_pernet(ppp->ppp_net);
 	mutex_lock(&pn->all_ppp_mutex);
 
@@ -2649,6 +3320,33 @@ static void ppp_shutdown_interface(struc
 	unit_put(&pn->units_idr, ppp->file.index);
 	ppp->file.dead = 1;
 	ppp->owner = NULL;
+
+#if defined(FAST_L2TP)
+	{
+		extern int fast_l2tp_fw;
+		if(fast_l2tp_fw)
+			event_ppp_dev_down(dev_name);
+	}
+#endif
+
+#ifdef CONFIG_RTL_PPPOE_HWACC
+#ifdef CONFIG_RTL_LAYERED_DRIVER
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L3
+#if 1
+	rtl865x_detachMasterNetif(dev_name);
+#endif
+#ifdef CONFIG_RTL_LAYERED_DRIVER_L2	// sync from voip customer for multiple ppp
+	#if defined (CONFIG_RTL_HW_QOS_SUPPORT)
+	rtl865x_qosFlushMarkRuleByDev(dev_name);
+	#endif
+#endif
+	rtl865x_delPppbyIfName(dev_name);
+#endif
+#else
+	rtl865x_delPppSession(dev_name,  SE_PPPOE);
+#endif
+#endif
+
 	wake_up_interruptible(&ppp->file.rwait);
 
 	mutex_unlock(&pn->all_ppp_mutex);
@@ -2892,6 +3590,12 @@ static void *unit_find(struct idr *p, in
 module_init(ppp_init);
 module_exit(ppp_cleanup);
 
+#if defined(CONFIG_RTL_IPTABLES_FAST_PATH)
+	#if defined(CONFIG_FAST_PATH_MODULE)
+	EXPORT_SYMBOL(ppp_start_xmit);
+	#endif
+#endif
+
 EXPORT_SYMBOL(ppp_register_net_channel);
 EXPORT_SYMBOL(ppp_register_channel);
 EXPORT_SYMBOL(ppp_unregister_channel);
--- linux-2.6.30.9/drivers/net/pppoe.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/pppoe.c	2013-05-02 01:47:53.188227102 +0300
@@ -304,6 +304,11 @@ static void pppoe_flush_dev(struct net_d
 	for (i = 0; i < PPPOE_HASH_SIZE; i++) {
 		struct pppox_sock *po = pn->hash_table[i];
 
+                if(!((unsigned int)po & 0x80000000))
+                {
+                	continue;
+                }
+
 		while (po != NULL) {
 			struct sock *sk;
 			if (po->pppoe_dev != dev) {
@@ -699,6 +704,10 @@ static int pppoe_connect(struct socket *
 		if (error)
 			goto err_put;
 
+#if defined (CONFIG_RTL_PPPOE_HWACC) || defined(CONFIG_RTL_FAST_PPPOE)
+		ppp_channel_pppoe(&po->chan);
+#endif
+
 		sk->sk_state = PPPOX_CONNECTED;
 	}
 
@@ -908,6 +917,9 @@ end:
  * xmit function for internal use.
  *
  ***********************************************************************/
+ #if defined(CONFIG_NET_SCHED)
+ extern int gQosEnabled;
+ #endif
 static int __pppoe_xmit(struct sock *sk, struct sk_buff *skb)
 {
 	struct pppox_sock *po = pppox_sk(sk);
@@ -943,7 +955,17 @@ static int __pppoe_xmit(struct sock *sk,
 	dev_hard_header(skb, dev, ETH_P_PPP_SES,
 			po->pppoe_pa.remote, NULL, data_len);
 
+	/*Improve pppoe wantype throughput when QoS disabled.*/
+#if defined(CONFIG_NET_SCHED)
+	if (gQosEnabled) 
+	{
 	dev_queue_xmit(skb);
+	}
+	else
+#endif
+	{
+		skb->dev->netdev_ops->ndo_start_xmit(skb,skb->dev);
+	}
 
 	return 1;
 
--- linux-2.6.30.9/drivers/net/tg3.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/tg3.c	2013-05-02 01:47:53.528227074 +0300
@@ -6242,6 +6242,11 @@ static int tg3_chip_reset(struct tg3 *tp
 				      PCI_EXP_DEVSTA_URD);
 	}
 
+    /* tonywu */
+    pci_write_config_word(tp->pdev, tp->pcie_cap + PCI_EXP_DEVCTL, 0);
+    pcie_set_readrq(tp->pdev, 128);
+    /* tonywu */
+
 	tg3_restore_pci_state(tp);
 
 	tp->tg3_flags &= ~TG3_FLAG_CHIP_RESETTING;
--- linux-2.6.30.9/drivers/net/wireless/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/wireless/Kconfig	2013-05-02 01:47:53.615227067 +0300
@@ -434,6 +434,12 @@ config RTL8187
 
 	  Thanks to Realtek for their support!
 
+config RTL8192SE_mac80211
+	tristate "Realtek 8192SE wireless chip support"
+	depends on MAC80211 && WLAN_80211
+	---help---
+	  This is a driver for RTL8192SE that support mac80211 
+
 config ADM8211
 	tristate "ADMtek ADM8211 support"
 	depends on MAC80211 && PCI && WLAN_80211 && EXPERIMENTAL
@@ -483,17 +489,9 @@ config MWL8K
 	  To compile this driver as a module, choose M here: the module
 	  will be called mwl8k.  If unsure, say N.
 
-source "drivers/net/wireless/p54/Kconfig"
-source "drivers/net/wireless/ath5k/Kconfig"
-source "drivers/net/wireless/ath9k/Kconfig"
-source "drivers/net/wireless/ar9170/Kconfig"
-source "drivers/net/wireless/ipw2x00/Kconfig"
 source "drivers/net/wireless/iwlwifi/Kconfig"
 source "drivers/net/wireless/hostap/Kconfig"
-source "drivers/net/wireless/b43/Kconfig"
-source "drivers/net/wireless/b43legacy/Kconfig"
-source "drivers/net/wireless/zd1211rw/Kconfig"
-source "drivers/net/wireless/rt2x00/Kconfig"
-source "drivers/net/wireless/orinoco/Kconfig"
+source "drivers/net/wireless/rtl8192cd/Kconfig"
+source "drivers/net/wireless/rtl8192e/Kconfig"
 
 endmenu
--- linux-2.6.30.9/drivers/net/wireless/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/net/wireless/Makefile	2013-05-02 01:47:53.615227067 +0300
@@ -2,8 +2,6 @@
 # Makefile for the Linux Wireless network device drivers.
 #
 
-obj-$(CONFIG_IPW2100) += ipw2x00/
-obj-$(CONFIG_IPW2200) += ipw2x00/
 
 obj-$(CONFIG_STRIP) += strip.o
 obj-$(CONFIG_ARLAN) += arlan.o 
@@ -24,16 +22,9 @@ obj-$(CONFIG_ATMEL)             += atmel
 obj-$(CONFIG_PCI_ATMEL)         += atmel_pci.o 
 obj-$(CONFIG_PCMCIA_ATMEL)      += atmel_cs.o
 
-obj-$(CONFIG_AT76C50X_USB)      += at76c50x-usb.o
 
-obj-$(CONFIG_PRISM54)		+= prism54/
 
 obj-$(CONFIG_HOSTAP)		+= hostap/
-obj-$(CONFIG_B43)		+= b43/
-obj-$(CONFIG_B43LEGACY)		+= b43legacy/
-obj-$(CONFIG_ZD1211RW)		+= zd1211rw/
-obj-$(CONFIG_RTL8180)		+= rtl818x/
-obj-$(CONFIG_RTL8187)		+= rtl818x/
 
 # 16-bit wireless PCMCIA client drivers
 obj-$(CONFIG_PCMCIA_RAYCS)	+= ray_cs.o
@@ -51,12 +42,8 @@ obj-$(CONFIG_ADM8211)	+= adm8211.o
 obj-$(CONFIG_MWL8K)	+= mwl8k.o
 
 obj-$(CONFIG_IWLWIFI)	+= iwlwifi/
-obj-$(CONFIG_RT2X00)	+= rt2x00/
 
-obj-$(CONFIG_P54_COMMON)	+= p54/
 
-obj-$(CONFIG_ATH5K)	+= ath5k/
-obj-$(CONFIG_ATH9K)	+= ath9k/
-obj-$(CONFIG_AR9170_USB)	+= ar9170/
 
-obj-$(CONFIG_MAC80211_HWSIM)	+= mac80211_hwsim.o
+obj-$(CONFIG_RTL8192CD)         += rtl8192cd/
+obj-$(CONFIG_WLAN_HAL_8192EE)         += rtl8192e/
--- linux-2.6.30.9/drivers/pci/access.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/pci/access.c	2013-05-02 01:47:54.647226984 +0300
@@ -38,6 +38,46 @@ int pci_bus_read_config_##size \
 	spin_unlock_irqrestore(&pci_lock, flags);			\
 	return res;							\
 }
+#ifdef CONFIG_RTL8198_REVISION_B
+int pci_bus_read_config_word
+	(struct pci_bus *bus, unsigned int devfn, int pos, u16 *value)
+{									
+	int res;							
+	unsigned long flags;						
+	u32 data = 0;							
+	if (PCI_word_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	
+	spin_lock_irqsave(&pci_lock, flags);	
+
+	int swap[4]={0,8,16,24};	int diff = pos&0x3;
+	res = bus->ops->read(bus, devfn, (pos&0xFFFFC), 4, &data);	
+	*value =(u16)( (data>>(swap[diff]))&0xffff);
+
+
+	
+	
+	//*value = (type)data;						
+	spin_unlock_irqrestore(&pci_lock, flags);			
+	return res;							
+}
+int pci_bus_read_config_byte
+	(struct pci_bus *bus, unsigned int devfn, int pos, u8 *value)
+{									
+	int res;							
+	unsigned long flags;						
+	u32 data = 0;							
+	if (PCI_word_BAD) return PCIBIOS_BAD_REGISTER_NUMBER;	
+	spin_lock_irqsave(&pci_lock, flags);	
+
+	int swap[4]={0,8,16,24};	int diff = pos&0x3;
+	res = bus->ops->read(bus, devfn, (pos&0xFFFFC), 4, &data);	
+	*value =(u8)( (data>>(swap[diff]))&0xff);
+	//*value = (type)data;						
+	spin_unlock_irqrestore(&pci_lock, flags);			
+	return res;							
+}
+
+#endif
+
 
 #define PCI_OP_WRITE(size,type,len) \
 int pci_bus_write_config_##size \
@@ -52,8 +92,11 @@ int pci_bus_write_config_##size \
 	return res;							\
 }
 
+#ifndef CONFIG_RTL8198_REVISION_B
 PCI_OP_READ(byte, u8, 1)
+
 PCI_OP_READ(word, u16, 2)
+#endif
 PCI_OP_READ(dword, u32, 4)
 PCI_OP_WRITE(byte, u8, 1)
 PCI_OP_WRITE(word, u16, 2)
--- linux-2.6.30.9/drivers/scsi/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/scsi/Kconfig	2013-05-02 01:47:55.017226954 +0300
@@ -82,6 +82,11 @@ config BLK_DEV_SD
 	  In this case, do not compile the driver for your SCSI host adapter
 	  (below) as a module either.
 
+config 4KB_HARDDISK_SUPPORT
+	bool "4kb sector size disk support"
+	depends on BLK_DEV_SD
+	default n
+
 config CHR_DEV_ST
 	tristate "SCSI tape support"
 	depends on SCSI
--- linux-2.6.30.9/drivers/scsi/scsi_lib.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/scsi/scsi_lib.c	2013-05-02 01:47:55.252226935 +0300
@@ -1626,7 +1626,7 @@ u64 scsi_calculate_bounce_limit(struct S
 
 	host_dev = scsi_get_device(shost);
 	if (host_dev && host_dev->dma_mask)
-		bounce_limit = *host_dev->dma_mask;
+		bounce_limit = *(host_dev->dma_mask);
 
 	return bounce_limit;
 }
--- linux-2.6.30.9/drivers/serial/8250.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/serial/8250.c	2013-05-02 01:47:55.684226900 +0300
@@ -44,10 +44,6 @@
 
 #include "8250.h"
 
-#ifdef CONFIG_SPARC
-#include "suncore.h"
-#endif
-
 /*
  * Configuration:
  *   share_irqs - whether we pass IRQF_SHARED to request_irq().  This option
@@ -117,13 +113,6 @@ static const struct old_serial_port old_
 
 #define UART_NR	CONFIG_SERIAL_8250_NR_UARTS
 
-#ifdef CONFIG_SERIAL_8250_RSA
-
-#define PORT_RSA_MAX 4
-static unsigned long probe_rsa[PORT_RSA_MAX];
-static unsigned int probe_rsa_count;
-#endif /* CONFIG_SERIAL_8250_RSA  */
-
 struct uart_8250_port {
 	struct uart_port	port;
 	struct timer_list	timer;		/* "no irq" timer */
@@ -181,196 +170,45 @@ static const struct serial8250_config ua
 		.fifo_size	= 1,
 		.tx_loadsz	= 1,
 	},
-	[PORT_16450] = {
-		.name		= "16450",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16550] = {
-		.name		= "16550",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16550A] = {
-		.name		= "16550A",
-		.fifo_size	= 16,
-		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO,
-	},
-	[PORT_CIRRUS] = {
-		.name		= "Cirrus",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16650] = {
-		.name		= "ST16650",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_16650V2] = {
-		.name		= "ST16650V2",
-		.fifo_size	= 32,
-		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |
-				  UART_FCR_T_TRIG_00,
-		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_16750] = {
-		.name		= "TI16750",
-		.fifo_size	= 64,
-		.tx_loadsz	= 64,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10 |
-				  UART_FCR7_64BYTE,
-		.flags		= UART_CAP_FIFO | UART_CAP_SLEEP | UART_CAP_AFE,
-	},
-	[PORT_STARTECH] = {
-		.name		= "Startech",
-		.fifo_size	= 1,
-		.tx_loadsz	= 1,
-	},
-	[PORT_16C950] = {
-		.name		= "16C950/954",
-		.fifo_size	= 128,
-		.tx_loadsz	= 128,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO,
-	},
+#ifdef CONFIG_SERIAL_SC16IS7X0
 	[PORT_16654] = {
 		.name		= "ST16654",
+#if 0
 		.fifo_size	= 64,
 		.tx_loadsz	= 32,
 		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_01 |
 				  UART_FCR_T_TRIG_10,
 		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_16850] = {
-		.name		= "XR16850",
-		.fifo_size	= 128,
-		.tx_loadsz	= 128,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO | UART_CAP_EFR | UART_CAP_SLEEP,
-	},
-	[PORT_RSA] = {
-		.name		= "RSA",
-		.fifo_size	= 2048,
-		.tx_loadsz	= 2048,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_11,
-		.flags		= UART_CAP_FIFO,
-	},
-	[PORT_NS16550A] = {
-		.name		= "NS16550A",
+#else
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO | UART_NATSEMI,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
+		.flags		= UART_CAP_FIFO,
+#endif
 	},
-	[PORT_XSCALE] = {
-		.name		= "XScale",
-		.fifo_size	= 32,
-		.tx_loadsz	= 32,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO | UART_CAP_UUE,
+#endif
+	[PORT_16550] = {
+		.name		= "16550",
+		.fifo_size	= 1,
+		.tx_loadsz	= 1,
 	},
-	[PORT_RM9000] = {
-		.name		= "RM9000",
+	[PORT_16550A] = {
+		.name		= "16550A",
 		.fifo_size	= 16,
 		.tx_loadsz	= 16,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
-		.flags		= UART_CAP_FIFO,
-	},
-	[PORT_OCTEON] = {
-		.name		= "OCTEON",
-		.fifo_size	= 64,
-		.tx_loadsz	= 64,
-		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_10,
+		.fcr		= UART_FCR_ENABLE_FIFO | UART_FCR_R_TRIG_00,
+#ifdef CONFIG_SERIAL_RTL8198_UART1
+		.flags		= UART_CAP_FIFO | UART_CAP_AFE,
+#else
 		.flags		= UART_CAP_FIFO,
+#endif
 	},
 };
 
-#if defined (CONFIG_SERIAL_8250_AU1X00)
-
-/* Au1x00 UART hardware has a weird register layout */
-static const u8 au_io_in_map[] = {
-	[UART_RX]  = 0,
-	[UART_IER] = 2,
-	[UART_IIR] = 3,
-	[UART_LCR] = 5,
-	[UART_MCR] = 6,
-	[UART_LSR] = 7,
-	[UART_MSR] = 8,
-};
-
-static const u8 au_io_out_map[] = {
-	[UART_TX]  = 1,
-	[UART_IER] = 2,
-	[UART_FCR] = 4,
-	[UART_LCR] = 5,
-	[UART_MCR] = 6,
-};
-
-/* sane hardware needs no mapping */
-static inline int map_8250_in_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_AU)
-		return offset;
-	return au_io_in_map[offset];
-}
-
-static inline int map_8250_out_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_AU)
-		return offset;
-	return au_io_out_map[offset];
-}
-
-#elif defined(CONFIG_SERIAL_8250_RM9K)
-
-static const u8
-	regmap_in[8] = {
-		[UART_RX]	= 0x00,
-		[UART_IER]	= 0x0c,
-		[UART_IIR]	= 0x14,
-		[UART_LCR]	= 0x1c,
-		[UART_MCR]	= 0x20,
-		[UART_LSR]	= 0x24,
-		[UART_MSR]	= 0x28,
-		[UART_SCR]	= 0x2c
-	},
-	regmap_out[8] = {
-		[UART_TX] 	= 0x04,
-		[UART_IER]	= 0x0c,
-		[UART_FCR]	= 0x18,
-		[UART_LCR]	= 0x1c,
-		[UART_MCR]	= 0x20,
-		[UART_LSR]	= 0x24,
-		[UART_MSR]	= 0x28,
-		[UART_SCR]	= 0x2c
-	};
-
-static inline int map_8250_in_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_RM9000)
-		return offset;
-	return regmap_in[offset];
-}
-
-static inline int map_8250_out_reg(struct uart_port *p, int offset)
-{
-	if (p->iotype != UPIO_RM9000)
-		return offset;
-	return regmap_out[offset];
-}
-
-#else
-
 /* sane hardware needs no mapping */
 #define map_8250_in_reg(up, offset) (offset)
 #define map_8250_out_reg(up, offset) (offset)
 
-#endif
-
 static unsigned int hub6_serial_in(struct uart_port *p, int offset)
 {
 	offset = map_8250_in_reg(p, offset) << p->regshift;
@@ -409,38 +247,6 @@ static unsigned int mem32_serial_in(stru
 	return readl(p->membase + offset);
 }
 
-#ifdef CONFIG_SERIAL_8250_AU1X00
-static unsigned int au_serial_in(struct uart_port *p, int offset)
-{
-	offset = map_8250_in_reg(p, offset) << p->regshift;
-	return __raw_readl(p->membase + offset);
-}
-
-static void au_serial_out(struct uart_port *p, int offset, int value)
-{
-	offset = map_8250_out_reg(p, offset) << p->regshift;
-	__raw_writel(value, p->membase + offset);
-}
-#endif
-
-static unsigned int tsi_serial_in(struct uart_port *p, int offset)
-{
-	unsigned int tmp;
-	offset = map_8250_in_reg(p, offset) << p->regshift;
-	if (offset == UART_IIR) {
-		tmp = readl(p->membase + (UART_IIR & ~3));
-		return (tmp >> 16) & 0xff; /* UART_IIR % 4 == 2 */
-	} else
-		return readb(p->membase + offset);
-}
-
-static void tsi_serial_out(struct uart_port *p, int offset, int value)
-{
-	offset = map_8250_out_reg(p, offset) << p->regshift;
-	if (!((offset == UART_IER) && (value & UART_IER_UUE)))
-		writeb(value, p->membase + offset);
-}
-
 static void dwapb_serial_out(struct uart_port *p, int offset, int value)
 {
 	int save_offset = offset;
@@ -451,7 +257,7 @@ static void dwapb_serial_out(struct uart
 		struct uart_8250_port *up = (struct uart_8250_port *)p;
 		up->lcr = value;
 	}
-	writeb(value, p->membase + offset);
+	writel(value, p->membase + offset);
 	/* Read the IER to ensure any interrupt is cleared before
 	 * returning from ISR. */
 	if (save_offset == UART_TX || save_offset == UART_IER)
@@ -470,13 +276,25 @@ static void io_serial_out(struct uart_po
 	outb(value, p->iobase + offset);
 }
 
+#ifdef CONFIG_SERIAL_SC16IS7X0
+static unsigned int i2c_serial_in(struct uart_port *p, int offset)
+{
+	extern unsigned int serial_in_i2c(unsigned int i2c_addr, int offset);
+	return serial_in_i2c( p ->iobase, offset );
+}
+static void i2c_serial_out(struct uart_port *p, int offset, int value)
+{
+	extern unsigned int serial_out_i2c(unsigned int i2c_addr, int offset, int value);
+	serial_out_i2c( p ->iobase, offset, value );
+}
+#endif
 static void set_io_from_upio(struct uart_port *p)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)p;
 	switch (p->iotype) {
-	case UPIO_HUB6:
-		p->serial_in = hub6_serial_in;
-		p->serial_out = hub6_serial_out;
+	case UPIO_DWAPB:
+		p->serial_in = mem32_serial_in;
+		p->serial_out = dwapb_serial_out;
 		break;
 
 	case UPIO_MEM:
@@ -484,27 +302,21 @@ static void set_io_from_upio(struct uart
 		p->serial_out = mem_serial_out;
 		break;
 
-	case UPIO_RM9000:
 	case UPIO_MEM32:
 		p->serial_in = mem32_serial_in;
 		p->serial_out = mem32_serial_out;
 		break;
 
-#ifdef CONFIG_SERIAL_8250_AU1X00
-	case UPIO_AU:
-		p->serial_in = au_serial_in;
-		p->serial_out = au_serial_out;
-		break;
-#endif
-	case UPIO_TSI:
-		p->serial_in = tsi_serial_in;
-		p->serial_out = tsi_serial_out;
+	case UPIO_HUB6:
+		p->serial_in = hub6_serial_in;
+		p->serial_out = hub6_serial_out;
 		break;
-
-	case UPIO_DWAPB:
-		p->serial_in = mem_serial_in;
-		p->serial_out = dwapb_serial_out;
+#ifdef CONFIG_SERIAL_SC16IS7X0
+	case UPIO_I2C:
+		p->serial_in = i2c_serial_in;
+		p->serial_out = i2c_serial_out;
 		break;
+#endif
 
 	default:
 		p->serial_in = io_serial_in;
@@ -520,12 +332,9 @@ serial_out_sync(struct uart_8250_port *u
 {
 	struct uart_port *p = &up->port;
 	switch (p->iotype) {
+	case UPIO_DWAPB:
 	case UPIO_MEM:
 	case UPIO_MEM32:
-#ifdef CONFIG_SERIAL_8250_AU1X00
-	case UPIO_AU:
-#endif
-	case UPIO_DWAPB:
 		p->serial_out(p, offset, value);
 		p->serial_in(p, UART_LCR);	/* safe, no side-effects */
 		break;
@@ -538,88 +347,22 @@ serial_out_sync(struct uart_8250_port *u
 	(up->port.serial_in(&(up)->port, (offset)))
 #define serial_out(up, offset, value)	\
 	(up->port.serial_out(&(up)->port, (offset), (value)))
-/*
- * We used to support using pause I/O for certain machines.  We
- * haven't supported this for a while, but just in case it's badly
- * needed for certain old 386 machines, I've left these #define's
- * in....
- */
-#define serial_inp(up, offset)		serial_in(up, offset)
-#define serial_outp(up, offset, value)	serial_out(up, offset, value)
 
 /* Uart divisor latch read */
 static inline int _serial_dl_read(struct uart_8250_port *up)
 {
-	return serial_inp(up, UART_DLL) | serial_inp(up, UART_DLM) << 8;
+	return serial_in(up, UART_DLL) | serial_in(up, UART_DLM) << 8;
 }
 
 /* Uart divisor latch write */
 static inline void _serial_dl_write(struct uart_8250_port *up, int value)
 {
-	serial_outp(up, UART_DLL, value & 0xff);
-	serial_outp(up, UART_DLM, value >> 8 & 0xff);
-}
-
-#if defined(CONFIG_SERIAL_8250_AU1X00)
-/* Au1x00 haven't got a standard divisor latch */
-static int serial_dl_read(struct uart_8250_port *up)
-{
-	if (up->port.iotype == UPIO_AU)
-		return __raw_readl(up->port.membase + 0x28);
-	else
-		return _serial_dl_read(up);
-}
-
-static void serial_dl_write(struct uart_8250_port *up, int value)
-{
-	if (up->port.iotype == UPIO_AU)
-		__raw_writel(value, up->port.membase + 0x28);
-	else
-		_serial_dl_write(up, value);
-}
-#elif defined(CONFIG_SERIAL_8250_RM9K)
-static int serial_dl_read(struct uart_8250_port *up)
-{
-	return	(up->port.iotype == UPIO_RM9000) ?
-		(((__raw_readl(up->port.membase + 0x10) << 8) |
-		(__raw_readl(up->port.membase + 0x08) & 0xff)) & 0xffff) :
-		_serial_dl_read(up);
+	serial_out(up, UART_DLL, value & 0xff);
+	serial_out(up, UART_DLM, value >> 8 & 0xff);
 }
 
-static void serial_dl_write(struct uart_8250_port *up, int value)
-{
-	if (up->port.iotype == UPIO_RM9000) {
-		__raw_writel(value, up->port.membase + 0x08);
-		__raw_writel(value >> 8, up->port.membase + 0x10);
-	} else {
-		_serial_dl_write(up, value);
-	}
-}
-#else
 #define serial_dl_read(up) _serial_dl_read(up)
 #define serial_dl_write(up, value) _serial_dl_write(up, value)
-#endif
-
-/*
- * For the 16C950
- */
-static void serial_icr_write(struct uart_8250_port *up, int offset, int value)
-{
-	serial_out(up, UART_SCR, offset);
-	serial_out(up, UART_ICR, value);
-}
-
-static unsigned int serial_icr_read(struct uart_8250_port *up, int offset)
-{
-	unsigned int value;
-
-	serial_icr_write(up, UART_ACR, up->acr | UART_ACR_ICRRD);
-	serial_out(up, UART_SCR, offset);
-	value = serial_in(up, UART_ICR);
-	serial_icr_write(up, UART_ACR, up->acr);
-
-	return value;
-}
 
 /*
  * FIFO support.
@@ -627,10 +370,10 @@ static unsigned int serial_icr_read(stru
 static void serial8250_clear_fifos(struct uart_8250_port *p)
 {
 	if (p->capabilities & UART_CAP_FIFO) {
-		serial_outp(p, UART_FCR, UART_FCR_ENABLE_FIFO);
-		serial_outp(p, UART_FCR, UART_FCR_ENABLE_FIFO |
+		serial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO);
+		serial_out(p, UART_FCR, UART_FCR_ENABLE_FIFO |
 			       UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-		serial_outp(p, UART_FCR, 0);
+		serial_out(p, UART_FCR, 0);
 	}
 }
 
@@ -643,657 +386,17 @@ static void serial8250_set_sleep(struct
 {
 	if (p->capabilities & UART_CAP_SLEEP) {
 		if (p->capabilities & UART_CAP_EFR) {
-			serial_outp(p, UART_LCR, 0xBF);
-			serial_outp(p, UART_EFR, UART_EFR_ECB);
-			serial_outp(p, UART_LCR, 0);
+			serial_out(p, UART_LCR, 0xBF);
+			serial_out(p, UART_EFR, UART_EFR_ECB);
+			serial_out(p, UART_LCR, 0);
 		}
-		serial_outp(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
+		serial_out(p, UART_IER, sleep ? UART_IERX_SLEEP : 0);
 		if (p->capabilities & UART_CAP_EFR) {
-			serial_outp(p, UART_LCR, 0xBF);
-			serial_outp(p, UART_EFR, 0);
-			serial_outp(p, UART_LCR, 0);
-		}
-	}
-}
-
-#ifdef CONFIG_SERIAL_8250_RSA
-/*
- * Attempts to turn on the RSA FIFO.  Returns zero on failure.
- * We set the port uart clock rate if we succeed.
- */
-static int __enable_rsa(struct uart_8250_port *up)
-{
-	unsigned char mode;
-	int result;
-
-	mode = serial_inp(up, UART_RSA_MSR);
-	result = mode & UART_RSA_MSR_FIFO;
-
-	if (!result) {
-		serial_outp(up, UART_RSA_MSR, mode | UART_RSA_MSR_FIFO);
-		mode = serial_inp(up, UART_RSA_MSR);
-		result = mode & UART_RSA_MSR_FIFO;
-	}
-
-	if (result)
-		up->port.uartclk = SERIAL_RSA_BAUD_BASE * 16;
-
-	return result;
-}
-
-static void enable_rsa(struct uart_8250_port *up)
-{
-	if (up->port.type == PORT_RSA) {
-		if (up->port.uartclk != SERIAL_RSA_BAUD_BASE * 16) {
-			spin_lock_irq(&up->port.lock);
-			__enable_rsa(up);
-			spin_unlock_irq(&up->port.lock);
-		}
-		if (up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16)
-			serial_outp(up, UART_RSA_FRR, 0);
-	}
-}
-
-/*
- * Attempts to turn off the RSA FIFO.  Returns zero on failure.
- * It is unknown why interrupts were disabled in here.  However,
- * the caller is expected to preserve this behaviour by grabbing
- * the spinlock before calling this function.
- */
-static void disable_rsa(struct uart_8250_port *up)
-{
-	unsigned char mode;
-	int result;
-
-	if (up->port.type == PORT_RSA &&
-	    up->port.uartclk == SERIAL_RSA_BAUD_BASE * 16) {
-		spin_lock_irq(&up->port.lock);
-
-		mode = serial_inp(up, UART_RSA_MSR);
-		result = !(mode & UART_RSA_MSR_FIFO);
-
-		if (!result) {
-			serial_outp(up, UART_RSA_MSR, mode & ~UART_RSA_MSR_FIFO);
-			mode = serial_inp(up, UART_RSA_MSR);
-			result = !(mode & UART_RSA_MSR_FIFO);
-		}
-
-		if (result)
-			up->port.uartclk = SERIAL_RSA_BAUD_BASE_LO * 16;
-		spin_unlock_irq(&up->port.lock);
-	}
-}
-#endif /* CONFIG_SERIAL_8250_RSA */
-
-/*
- * This is a quickie test to see how big the FIFO is.
- * It doesn't work at all the time, more's the pity.
- */
-static int size_fifo(struct uart_8250_port *up)
-{
-	unsigned char old_fcr, old_mcr, old_lcr;
-	unsigned short old_dl;
-	int count;
-
-	old_lcr = serial_inp(up, UART_LCR);
-	serial_outp(up, UART_LCR, 0);
-	old_fcr = serial_inp(up, UART_FCR);
-	old_mcr = serial_inp(up, UART_MCR);
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO |
-		    UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT);
-	serial_outp(up, UART_MCR, UART_MCR_LOOP);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	old_dl = serial_dl_read(up);
-	serial_dl_write(up, 0x0001);
-	serial_outp(up, UART_LCR, 0x03);
-	for (count = 0; count < 256; count++)
-		serial_outp(up, UART_TX, count);
-	mdelay(20);/* FIXME - schedule_timeout */
-	for (count = 0; (serial_inp(up, UART_LSR) & UART_LSR_DR) &&
-	     (count < 256); count++)
-		serial_inp(up, UART_RX);
-	serial_outp(up, UART_FCR, old_fcr);
-	serial_outp(up, UART_MCR, old_mcr);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	serial_dl_write(up, old_dl);
-	serial_outp(up, UART_LCR, old_lcr);
-
-	return count;
-}
-
-/*
- * Read UART ID using the divisor method - set DLL and DLM to zero
- * and the revision will be in DLL and device type in DLM.  We
- * preserve the device state across this.
- */
-static unsigned int autoconfig_read_divisor_id(struct uart_8250_port *p)
-{
-	unsigned char old_dll, old_dlm, old_lcr;
-	unsigned int id;
-
-	old_lcr = serial_inp(p, UART_LCR);
-	serial_outp(p, UART_LCR, UART_LCR_DLAB);
-
-	old_dll = serial_inp(p, UART_DLL);
-	old_dlm = serial_inp(p, UART_DLM);
-
-	serial_outp(p, UART_DLL, 0);
-	serial_outp(p, UART_DLM, 0);
-
-	id = serial_inp(p, UART_DLL) | serial_inp(p, UART_DLM) << 8;
-
-	serial_outp(p, UART_DLL, old_dll);
-	serial_outp(p, UART_DLM, old_dlm);
-	serial_outp(p, UART_LCR, old_lcr);
-
-	return id;
-}
-
-/*
- * This is a helper routine to autodetect StarTech/Exar/Oxsemi UART's.
- * When this function is called we know it is at least a StarTech
- * 16650 V2, but it might be one of several StarTech UARTs, or one of
- * its clones.  (We treat the broken original StarTech 16650 V1 as a
- * 16550, and why not?  Startech doesn't seem to even acknowledge its
- * existence.)
- *
- * What evil have men's minds wrought...
- */
-static void autoconfig_has_efr(struct uart_8250_port *up)
-{
-	unsigned int id1, id2, id3, rev;
-
-	/*
-	 * Everything with an EFR has SLEEP
-	 */
-	up->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;
-
-	/*
-	 * First we check to see if it's an Oxford Semiconductor UART.
-	 *
-	 * If we have to do this here because some non-National
-	 * Semiconductor clone chips lock up if you try writing to the
-	 * LSR register (which serial_icr_read does)
-	 */
-
-	/*
-	 * Check for Oxford Semiconductor 16C950.
-	 *
-	 * EFR [4] must be set else this test fails.
-	 *
-	 * This shouldn't be necessary, but Mike Hudson (Exoray@isys.ca)
-	 * claims that it's needed for 952 dual UART's (which are not
-	 * recommended for new designs).
-	 */
-	up->acr = 0;
-	serial_out(up, UART_LCR, 0xBF);
-	serial_out(up, UART_EFR, UART_EFR_ECB);
-	serial_out(up, UART_LCR, 0x00);
-	id1 = serial_icr_read(up, UART_ID1);
-	id2 = serial_icr_read(up, UART_ID2);
-	id3 = serial_icr_read(up, UART_ID3);
-	rev = serial_icr_read(up, UART_REV);
-
-	DEBUG_AUTOCONF("950id=%02x:%02x:%02x:%02x ", id1, id2, id3, rev);
-
-	if (id1 == 0x16 && id2 == 0xC9 &&
-	    (id3 == 0x50 || id3 == 0x52 || id3 == 0x54)) {
-		up->port.type = PORT_16C950;
-
-		/*
-		 * Enable work around for the Oxford Semiconductor 952 rev B
-		 * chip which causes it to seriously miscalculate baud rates
-		 * when DLL is 0.
-		 */
-		if (id3 == 0x52 && rev == 0x01)
-			up->bugs |= UART_BUG_QUOT;
-		return;
-	}
-
-	/*
-	 * We check for a XR16C850 by setting DLL and DLM to 0, and then
-	 * reading back DLL and DLM.  The chip type depends on the DLM
-	 * value read back:
-	 *  0x10 - XR16C850 and the DLL contains the chip revision.
-	 *  0x12 - XR16C2850.
-	 *  0x14 - XR16C854.
-	 */
-	id1 = autoconfig_read_divisor_id(up);
-	DEBUG_AUTOCONF("850id=%04x ", id1);
-
-	id2 = id1 >> 8;
-	if (id2 == 0x10 || id2 == 0x12 || id2 == 0x14) {
-		up->port.type = PORT_16850;
-		return;
-	}
-
-	/*
-	 * It wasn't an XR16C850.
-	 *
-	 * We distinguish between the '654 and the '650 by counting
-	 * how many bytes are in the FIFO.  I'm using this for now,
-	 * since that's the technique that was sent to me in the
-	 * serial driver update, but I'm not convinced this works.
-	 * I've had problems doing this in the past.  -TYT
-	 */
-	if (size_fifo(up) == 64)
-		up->port.type = PORT_16654;
-	else
-		up->port.type = PORT_16650V2;
-}
-
-/*
- * We detected a chip without a FIFO.  Only two fall into
- * this category - the original 8250 and the 16450.  The
- * 16450 has a scratch register (accessible with LCR=0)
- */
-static void autoconfig_8250(struct uart_8250_port *up)
-{
-	unsigned char scratch, status1, status2;
-
-	up->port.type = PORT_8250;
-
-	scratch = serial_in(up, UART_SCR);
-	serial_outp(up, UART_SCR, 0xa5);
-	status1 = serial_in(up, UART_SCR);
-	serial_outp(up, UART_SCR, 0x5a);
-	status2 = serial_in(up, UART_SCR);
-	serial_outp(up, UART_SCR, scratch);
-
-	if (status1 == 0xa5 && status2 == 0x5a)
-		up->port.type = PORT_16450;
-}
-
-static int broken_efr(struct uart_8250_port *up)
-{
-	/*
-	 * Exar ST16C2550 "A2" devices incorrectly detect as
-	 * having an EFR, and report an ID of 0x0201.  See
-	 * http://www.exar.com/info.php?pdf=dan180_oct2004.pdf
-	 */
-	if (autoconfig_read_divisor_id(up) == 0x0201 && size_fifo(up) == 16)
-		return 1;
-
-	return 0;
-}
-
-/*
- * We know that the chip has FIFOs.  Does it have an EFR?  The
- * EFR is located in the same register position as the IIR and
- * we know the top two bits of the IIR are currently set.  The
- * EFR should contain zero.  Try to read the EFR.
- */
-static void autoconfig_16550a(struct uart_8250_port *up)
-{
-	unsigned char status1, status2;
-	unsigned int iersave;
-
-	up->port.type = PORT_16550A;
-	up->capabilities |= UART_CAP_FIFO;
-
-	/*
-	 * Check for presence of the EFR when DLAB is set.
-	 * Only ST16C650V1 UARTs pass this test.
-	 */
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	if (serial_in(up, UART_EFR) == 0) {
-		serial_outp(up, UART_EFR, 0xA8);
-		if (serial_in(up, UART_EFR) != 0) {
-			DEBUG_AUTOCONF("EFRv1 ");
-			up->port.type = PORT_16650;
-			up->capabilities |= UART_CAP_EFR | UART_CAP_SLEEP;
-		} else {
-			DEBUG_AUTOCONF("Motorola 8xxx DUART ");
-		}
-		serial_outp(up, UART_EFR, 0);
-		return;
-	}
-
-	/*
-	 * Maybe it requires 0xbf to be written to the LCR.
-	 * (other ST16C650V2 UARTs, TI16C752A, etc)
-	 */
-	serial_outp(up, UART_LCR, 0xBF);
-	if (serial_in(up, UART_EFR) == 0 && !broken_efr(up)) {
-		DEBUG_AUTOCONF("EFRv2 ");
-		autoconfig_has_efr(up);
-		return;
+			serial_out(p, UART_LCR, 0xBF);
+			serial_out(p, UART_EFR, 0);
+			serial_out(p, UART_LCR, 0);
 	}
-
-	/*
-	 * Check for a National Semiconductor SuperIO chip.
-	 * Attempt to switch to bank 2, read the value of the LOOP bit
-	 * from EXCR1. Switch back to bank 0, change it in MCR. Then
-	 * switch back to bank 2, read it from EXCR1 again and check
-	 * it's changed. If so, set baud_base in EXCR2 to 921600. -- dwmw2
-	 */
-	serial_outp(up, UART_LCR, 0);
-	status1 = serial_in(up, UART_MCR);
-	serial_outp(up, UART_LCR, 0xE0);
-	status2 = serial_in(up, 0x02); /* EXCR1 */
-
-	if (!((status2 ^ status1) & UART_MCR_LOOP)) {
-		serial_outp(up, UART_LCR, 0);
-		serial_outp(up, UART_MCR, status1 ^ UART_MCR_LOOP);
-		serial_outp(up, UART_LCR, 0xE0);
-		status2 = serial_in(up, 0x02); /* EXCR1 */
-		serial_outp(up, UART_LCR, 0);
-		serial_outp(up, UART_MCR, status1);
-
-		if ((status2 ^ status1) & UART_MCR_LOOP) {
-			unsigned short quot;
-
-			serial_outp(up, UART_LCR, 0xE0);
-
-			quot = serial_dl_read(up);
-			quot <<= 3;
-
-			status1 = serial_in(up, 0x04); /* EXCR2 */
-			status1 &= ~0xB0; /* Disable LOCK, mask out PRESL[01] */
-			status1 |= 0x10;  /* 1.625 divisor for baud_base --> 921600 */
-			serial_outp(up, 0x04, status1);
-
-			serial_dl_write(up, quot);
-
-			serial_outp(up, UART_LCR, 0);
-
-			up->port.uartclk = 921600*16;
-			up->port.type = PORT_NS16550A;
-			up->capabilities |= UART_NATSEMI;
-			return;
-		}
-	}
-
-	/*
-	 * No EFR.  Try to detect a TI16750, which only sets bit 5 of
-	 * the IIR when 64 byte FIFO mode is enabled when DLAB is set.
-	 * Try setting it with and without DLAB set.  Cheap clones
-	 * set bit 5 without DLAB set.
-	 */
-	serial_outp(up, UART_LCR, 0);
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
-	status1 = serial_in(up, UART_IIR) >> 5;
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	serial_outp(up, UART_LCR, UART_LCR_DLAB);
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO | UART_FCR7_64BYTE);
-	status2 = serial_in(up, UART_IIR) >> 5;
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	serial_outp(up, UART_LCR, 0);
-
-	DEBUG_AUTOCONF("iir1=%d iir2=%d ", status1, status2);
-
-	if (status1 == 6 && status2 == 7) {
-		up->port.type = PORT_16750;
-		up->capabilities |= UART_CAP_AFE | UART_CAP_SLEEP;
-		return;
-	}
-
-	/*
-	 * Try writing and reading the UART_IER_UUE bit (b6).
-	 * If it works, this is probably one of the Xscale platform's
-	 * internal UARTs.
-	 * We're going to explicitly set the UUE bit to 0 before
-	 * trying to write and read a 1 just to make sure it's not
-	 * already a 1 and maybe locked there before we even start start.
-	 */
-	iersave = serial_in(up, UART_IER);
-	serial_outp(up, UART_IER, iersave & ~UART_IER_UUE);
-	if (!(serial_in(up, UART_IER) & UART_IER_UUE)) {
-		/*
-		 * OK it's in a known zero state, try writing and reading
-		 * without disturbing the current state of the other bits.
-		 */
-		serial_outp(up, UART_IER, iersave | UART_IER_UUE);
-		if (serial_in(up, UART_IER) & UART_IER_UUE) {
-			/*
-			 * It's an Xscale.
-			 * We'll leave the UART_IER_UUE bit set to 1 (enabled).
-			 */
-			DEBUG_AUTOCONF("Xscale ");
-			up->port.type = PORT_XSCALE;
-			up->capabilities |= UART_CAP_UUE;
-			return;
-		}
-	} else {
-		/*
-		 * If we got here we couldn't force the IER_UUE bit to 0.
-		 * Log it and continue.
-		 */
-		DEBUG_AUTOCONF("Couldn't force IER_UUE to 0 ");
-	}
-	serial_outp(up, UART_IER, iersave);
-}
-
-/*
- * This routine is called by rs_init() to initialize a specific serial
- * port.  It determines what type of UART chip this serial port is
- * using: 8250, 16450, 16550, 16550A.  The important question is
- * whether or not this UART is a 16550A or not, since this will
- * determine whether or not we can use its FIFO features or not.
- */
-static void autoconfig(struct uart_8250_port *up, unsigned int probeflags)
-{
-	unsigned char status1, scratch, scratch2, scratch3;
-	unsigned char save_lcr, save_mcr;
-	unsigned long flags;
-
-	if (!up->port.iobase && !up->port.mapbase && !up->port.membase)
-		return;
-
-	DEBUG_AUTOCONF("ttyS%d: autoconf (0x%04x, 0x%p): ",
-		       serial_index(&up->port), up->port.iobase, up->port.membase);
-
-	/*
-	 * We really do need global IRQs disabled here - we're going to
-	 * be frobbing the chips IRQ enable register to see if it exists.
-	 */
-	spin_lock_irqsave(&up->port.lock, flags);
-
-	up->capabilities = 0;
-	up->bugs = 0;
-
-	if (!(up->port.flags & UPF_BUGGY_UART)) {
-		/*
-		 * Do a simple existence test first; if we fail this,
-		 * there's no point trying anything else.
-		 *
-		 * 0x80 is used as a nonsense port to prevent against
-		 * false positives due to ISA bus float.  The
-		 * assumption is that 0x80 is a non-existent port;
-		 * which should be safe since include/asm/io.h also
-		 * makes this assumption.
-		 *
-		 * Note: this is safe as long as MCR bit 4 is clear
-		 * and the device is in "PC" mode.
-		 */
-		scratch = serial_inp(up, UART_IER);
-		serial_outp(up, UART_IER, 0);
-#ifdef __i386__
-		outb(0xff, 0x080);
-#endif
-		/*
-		 * Mask out IER[7:4] bits for test as some UARTs (e.g. TL
-		 * 16C754B) allow only to modify them if an EFR bit is set.
-		 */
-		scratch2 = serial_inp(up, UART_IER) & 0x0f;
-		serial_outp(up, UART_IER, 0x0F);
-#ifdef __i386__
-		outb(0, 0x080);
-#endif
-		scratch3 = serial_inp(up, UART_IER) & 0x0f;
-		serial_outp(up, UART_IER, scratch);
-		if (scratch2 != 0 || scratch3 != 0x0F) {
-			/*
-			 * We failed; there's nothing here
-			 */
-			DEBUG_AUTOCONF("IER test failed (%02x, %02x) ",
-				       scratch2, scratch3);
-			goto out;
-		}
-	}
-
-	save_mcr = serial_in(up, UART_MCR);
-	save_lcr = serial_in(up, UART_LCR);
-
-	/*
-	 * Check to see if a UART is really there.  Certain broken
-	 * internal modems based on the Rockwell chipset fail this
-	 * test, because they apparently don't implement the loopback
-	 * test mode.  So this test is skipped on the COM 1 through
-	 * COM 4 ports.  This *should* be safe, since no board
-	 * manufacturer would be stupid enough to design a board
-	 * that conflicts with COM 1-4 --- we hope!
-	 */
-	if (!(up->port.flags & UPF_SKIP_TEST)) {
-		serial_outp(up, UART_MCR, UART_MCR_LOOP | 0x0A);
-		status1 = serial_inp(up, UART_MSR) & 0xF0;
-		serial_outp(up, UART_MCR, save_mcr);
-		if (status1 != 0x90) {
-			DEBUG_AUTOCONF("LOOP test failed (%02x) ",
-				       status1);
-			goto out;
-		}
-	}
-
-	/*
-	 * We're pretty sure there's a port here.  Lets find out what
-	 * type of port it is.  The IIR top two bits allows us to find
-	 * out if it's 8250 or 16450, 16550, 16550A or later.  This
-	 * determines what we test for next.
-	 *
-	 * We also initialise the EFR (if any) to zero for later.  The
-	 * EFR occupies the same register location as the FCR and IIR.
-	 */
-	serial_outp(up, UART_LCR, 0xBF);
-	serial_outp(up, UART_EFR, 0);
-	serial_outp(up, UART_LCR, 0);
-
-	serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-	scratch = serial_in(up, UART_IIR) >> 6;
-
-	DEBUG_AUTOCONF("iir=%d ", scratch);
-
-	switch (scratch) {
-	case 0:
-		autoconfig_8250(up);
-		break;
-	case 1:
-		up->port.type = PORT_UNKNOWN;
-		break;
-	case 2:
-		up->port.type = PORT_16550;
-		break;
-	case 3:
-		autoconfig_16550a(up);
-		break;
-	}
-
-#ifdef CONFIG_SERIAL_8250_RSA
-	/*
-	 * Only probe for RSA ports if we got the region.
-	 */
-	if (up->port.type == PORT_16550A && probeflags & PROBE_RSA) {
-		int i;
-
-		for (i = 0 ; i < probe_rsa_count; ++i) {
-			if (probe_rsa[i] == up->port.iobase &&
-			    __enable_rsa(up)) {
-				up->port.type = PORT_RSA;
-				break;
-			}
-		}
-	}
-#endif
-
-#ifdef CONFIG_SERIAL_8250_AU1X00
-	/* if access method is AU, it is a 16550 with a quirk */
-	if (up->port.type == PORT_16550A && up->port.iotype == UPIO_AU)
-		up->bugs |= UART_BUG_NOMSR;
-#endif
-
-	serial_outp(up, UART_LCR, save_lcr);
-
-	if (up->capabilities != uart_config[up->port.type].flags) {
-		printk(KERN_WARNING
-		       "ttyS%d: detected caps %08x should be %08x\n",
-		       serial_index(&up->port), up->capabilities,
-		       uart_config[up->port.type].flags);
-	}
-
-	up->port.fifosize = uart_config[up->port.type].fifo_size;
-	up->capabilities = uart_config[up->port.type].flags;
-	up->tx_loadsz = uart_config[up->port.type].tx_loadsz;
-
-	if (up->port.type == PORT_UNKNOWN)
-		goto out;
-
-	/*
-	 * Reset the UART.
-	 */
-#ifdef CONFIG_SERIAL_8250_RSA
-	if (up->port.type == PORT_RSA)
-		serial_outp(up, UART_RSA_FRR, 0);
-#endif
-	serial_outp(up, UART_MCR, save_mcr);
-	serial8250_clear_fifos(up);
-	serial_in(up, UART_RX);
-	if (up->capabilities & UART_CAP_UUE)
-		serial_outp(up, UART_IER, UART_IER_UUE);
-	else
-		serial_outp(up, UART_IER, 0);
-
- out:
-	spin_unlock_irqrestore(&up->port.lock, flags);
-	DEBUG_AUTOCONF("type=%s\n", uart_config[up->port.type].name);
-}
-
-static void autoconfig_irq(struct uart_8250_port *up)
-{
-	unsigned char save_mcr, save_ier;
-	unsigned char save_ICP = 0;
-	unsigned int ICP = 0;
-	unsigned long irqs;
-	int irq;
-
-	if (up->port.flags & UPF_FOURPORT) {
-		ICP = (up->port.iobase & 0xfe0) | 0x1f;
-		save_ICP = inb_p(ICP);
-		outb_p(0x80, ICP);
-		(void) inb_p(ICP);
-	}
-
-	/* forget possible initially masked and pending IRQ */
-	probe_irq_off(probe_irq_on());
-	save_mcr = serial_inp(up, UART_MCR);
-	save_ier = serial_inp(up, UART_IER);
-	serial_outp(up, UART_MCR, UART_MCR_OUT1 | UART_MCR_OUT2);
-
-	irqs = probe_irq_on();
-	serial_outp(up, UART_MCR, 0);
-	udelay(10);
-	if (up->port.flags & UPF_FOURPORT) {
-		serial_outp(up, UART_MCR,
-			    UART_MCR_DTR | UART_MCR_RTS);
-	} else {
-		serial_outp(up, UART_MCR,
-			    UART_MCR_DTR | UART_MCR_RTS | UART_MCR_OUT2);
 	}
-	serial_outp(up, UART_IER, 0x0f);	/* enable all intrs */
-	(void)serial_inp(up, UART_LSR);
-	(void)serial_inp(up, UART_RX);
-	(void)serial_inp(up, UART_IIR);
-	(void)serial_inp(up, UART_MSR);
-	serial_outp(up, UART_TX, 0xFF);
-	udelay(20);
-	irq = probe_irq_off(irqs);
-
-	serial_outp(up, UART_MCR, save_mcr);
-	serial_outp(up, UART_IER, save_ier);
-
-	if (up->port.flags & UPF_FOURPORT)
-		outb_p(save_ICP, ICP);
-
-	up->port.irq = (irq > 0) ? irq : 0;
 }
 
 static inline void __stop_tx(struct uart_8250_port *p)
@@ -1309,14 +412,6 @@ static void serial8250_stop_tx(struct ua
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
 	__stop_tx(up);
-
-	/*
-	 * We really want to stop the transmitter from sending.
-	 */
-	if (up->port.type == PORT_16C950) {
-		up->acr |= UART_ACR_TXDIS;
-		serial_icr_write(up, UART_ACR, up->acr);
-	}
 }
 
 static void transmit_chars(struct uart_8250_port *up);
@@ -1341,14 +436,6 @@ static void serial8250_start_tx(struct u
 				transmit_chars(up);
 		}
 	}
-
-	/*
-	 * Re-enable the transmitter if we disabled it.
-	 */
-	if (up->port.type == PORT_16C950 && up->acr & UART_ACR_TXDIS) {
-		up->acr &= ~UART_ACR_TXDIS;
-		serial_icr_write(up, UART_ACR, up->acr);
-	}
 }
 
 static void serial8250_stop_rx(struct uart_port *port)
@@ -1382,7 +469,7 @@ receive_chars(struct uart_8250_port *up,
 
 	do {
 		if (likely(lsr & UART_LSR_DR))
-			ch = serial_inp(up, UART_RX);
+			ch = serial_in(up, UART_RX);
 		else
 			/*
 			 * Intel 82571 has a Serial Over Lan device that will
@@ -1440,7 +527,7 @@ receive_chars(struct uart_8250_port *up,
 		uart_insert_char(&up->port, lsr, UART_LSR_OE, ch, flag);
 
 ignore_char:
-		lsr = serial_inp(up, UART_LSR);
+		lsr = serial_in(up, UART_LSR);
 	} while ((lsr & (UART_LSR_DR | UART_LSR_BI)) && (max_count-- > 0));
 	spin_unlock(&up->port.lock);
 	tty_flip_buffer_push(tty);
@@ -1454,7 +541,7 @@ static void transmit_chars(struct uart_8
 	int count;
 
 	if (up->port.x_char) {
-		serial_outp(up, UART_TX, up->port.x_char);
+		serial_out(up, UART_TX, up->port.x_char);
 		up->port.icount.tx++;
 		up->port.x_char = 0;
 		return;
@@ -1519,7 +606,7 @@ static void serial8250_handle_port(struc
 
 	spin_lock_irqsave(&up->port.lock, flags);
 
-	status = serial_inp(up, UART_LSR);
+	status = serial_in(up, UART_LSR);
 
 	DEBUG_INTR("status = %x...", status);
 
@@ -1552,6 +639,11 @@ static irqreturn_t serial8250_interrupt(
 	struct list_head *l, *end = NULL;
 	int pass_counter = 0, handled = 0;
 
+#ifdef CONFIG_SERIAL_SC16IS7X0
+	extern int sc16is7x0_clean_interrupt( int irq );
+	if( sc16is7x0_clean_interrupt( irq ) < 0 )
+		return IRQ_RETVAL(handled);
+#endif
 	DEBUG_INTR("serial8250_interrupt(%d)...", irq);
 
 	spin_lock(&i->lock);
@@ -1635,7 +727,8 @@ static int serial_link_irq_chain(struct
 	struct hlist_head *h;
 	struct hlist_node *n;
 	struct irq_info *i;
-	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+//	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : IRQF_DISABLED;
 
 	mutex_lock(&hash_mutex);
 
@@ -1682,7 +775,7 @@ static int serial_link_irq_chain(struct
 
 static void serial_unlink_irq_chain(struct uart_8250_port *up)
 {
-	struct irq_info *i;
+	struct irq_info *i=NULL;
 	struct hlist_node *n;
 	struct hlist_head *h;
 
@@ -1886,12 +979,12 @@ static void wait_for_xmitr(struct uart_8
 static int serial8250_get_poll_char(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	unsigned char lsr = serial_inp(up, UART_LSR);
+	unsigned char lsr = serial_in(up, UART_LSR);
 
 	while (!(lsr & UART_LSR_DR))
-		lsr = serial_inp(up, UART_LSR);
+		lsr = serial_in(up, UART_LSR);
 
-	return serial_inp(up, UART_RX);
+	return serial_in(up, UART_RX);
 }
 
 
@@ -1944,27 +1037,6 @@ static int serial8250_startup(struct uar
 	if (up->port.iotype != up->cur_iotype)
 		set_io_from_upio(port);
 
-	if (up->port.type == PORT_16C950) {
-		/* Wake up and initialize UART */
-		up->acr = 0;
-		serial_outp(up, UART_LCR, 0xBF);
-		serial_outp(up, UART_EFR, UART_EFR_ECB);
-		serial_outp(up, UART_IER, 0);
-		serial_outp(up, UART_LCR, 0);
-		serial_icr_write(up, UART_CSR, 0); /* Reset the UART */
-		serial_outp(up, UART_LCR, 0xBF);
-		serial_outp(up, UART_EFR, UART_EFR_ECB);
-		serial_outp(up, UART_LCR, 0);
-	}
-
-#ifdef CONFIG_SERIAL_8250_RSA
-	/*
-	 * If this is an RSA port, see if we can kick it up to the
-	 * higher speed clock.
-	 */
-	enable_rsa(up);
-#endif
-
 	/*
 	 * Clear the FIFO buffers and disable them.
 	 * (they will be reenabled in set_termios())
@@ -1974,10 +1046,10 @@ static int serial8250_startup(struct uar
 	/*
 	 * Clear the interrupt registers.
 	 */
-	(void) serial_inp(up, UART_LSR);
-	(void) serial_inp(up, UART_RX);
-	(void) serial_inp(up, UART_IIR);
-	(void) serial_inp(up, UART_MSR);
+	(void) serial_in(up, UART_LSR);
+	(void) serial_in(up, UART_RX);
+	(void) serial_in(up, UART_IIR);
+	(void) serial_in(up, UART_MSR);
 
 	/*
 	 * At this point, there's no way the LSR could still be 0xff;
@@ -1985,29 +1057,12 @@ static int serial8250_startup(struct uar
 	 * here.
 	 */
 	if (!(up->port.flags & UPF_BUGGY_UART) &&
-	    (serial_inp(up, UART_LSR) == 0xff)) {
+	    (serial_in(up, UART_LSR) == 0xff)) {
 		printk(KERN_INFO "ttyS%d: LSR safety check engaged!\n",
 		       serial_index(&up->port));
 		return -ENODEV;
 	}
 
-	/*
-	 * For a XR16C850, we need to set the trigger levels
-	 */
-	if (up->port.type == PORT_16850) {
-		unsigned char fctr;
-
-		serial_outp(up, UART_LCR, 0xbf);
-
-		fctr = serial_inp(up, UART_FCTR) & ~(UART_FCTR_RX|UART_FCTR_TX);
-		serial_outp(up, UART_FCTR, fctr | UART_FCTR_TRGD | UART_FCTR_RX);
-		serial_outp(up, UART_TRG, UART_TRG_96);
-		serial_outp(up, UART_FCTR, fctr | UART_FCTR_TRGD | UART_FCTR_TX);
-		serial_outp(up, UART_TRG, UART_TRG_96);
-
-		serial_outp(up, UART_LCR, 0);
-	}
-
 	if (is_real_interrupt(up->port.irq)) {
 		unsigned char iir1;
 		/*
@@ -2075,13 +1130,9 @@ static int serial8250_startup(struct uar
 	/*
 	 * Now, initialize the UART
 	 */
-	serial_outp(up, UART_LCR, UART_LCR_WLEN8);
+	serial_out(up, UART_LCR, UART_LCR_WLEN8);
 
 	spin_lock_irqsave(&up->port.lock, flags);
-	if (up->port.flags & UPF_FOURPORT) {
-		if (!is_real_interrupt(up->port.irq))
-			up->port.mctrl |= TIOCM_OUT1;
-	} else
 		/*
 		 * Most PC uarts need OUT2 raised to enable interrupts.
 		 */
@@ -2108,10 +1159,10 @@ static int serial8250_startup(struct uar
 	 * Do a quick test to see if we receive an
 	 * interrupt when we enable the TX irq.
 	 */
-	serial_outp(up, UART_IER, UART_IER_THRI);
+	serial_out(up, UART_IER, UART_IER_THRI);
 	lsr = serial_in(up, UART_LSR);
 	iir = serial_in(up, UART_IIR);
-	serial_outp(up, UART_IER, 0);
+	serial_out(up, UART_IER, 0);
 
 	if (lsr & UART_LSR_TEMT && iir & UART_IIR_NO_INT) {
 		if (!(up->bugs & UART_BUG_TXEN)) {
@@ -2131,10 +1182,10 @@ dont_test_tx_en:
 	 * saved flags to avoid getting false values from polling
 	 * routines or the previous session.
 	 */
-	serial_inp(up, UART_LSR);
-	serial_inp(up, UART_RX);
-	serial_inp(up, UART_IIR);
-	serial_inp(up, UART_MSR);
+	serial_in(up, UART_LSR);
+	serial_in(up, UART_RX);
+	serial_in(up, UART_IIR);
+	serial_in(up, UART_MSR);
 	up->lsr_saved_flags = 0;
 	up->msr_saved_flags = 0;
 
@@ -2144,17 +1195,7 @@ dont_test_tx_en:
 	 * anyway, so we don't enable them here.
 	 */
 	up->ier = UART_IER_RLSI | UART_IER_RDI;
-	serial_outp(up, UART_IER, up->ier);
-
-	if (up->port.flags & UPF_FOURPORT) {
-		unsigned int icp;
-		/*
-		 * Enable interrupts on the AST Fourport board
-		 */
-		icp = (up->port.iobase & 0xfe0) | 0x01f;
-		outb_p(0x80, icp);
-		(void) inb_p(icp);
-	}
+	serial_out(up, UART_IER, up->ier);
 
 	return 0;
 }
@@ -2168,14 +1209,9 @@ static void serial8250_shutdown(struct u
 	 * Disable interrupts from this port
 	 */
 	up->ier = 0;
-	serial_outp(up, UART_IER, 0);
+	serial_out(up, UART_IER, 0);
 
 	spin_lock_irqsave(&up->port.lock, flags);
-	if (up->port.flags & UPF_FOURPORT) {
-		/* reset interrupts on the AST Fourport board */
-		inb((up->port.iobase & 0xfe0) | 0x1f);
-		up->port.mctrl |= TIOCM_OUT1;
-	} else
 		up->port.mctrl &= ~TIOCM_OUT2;
 
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
@@ -2184,16 +1220,9 @@ static void serial8250_shutdown(struct u
 	/*
 	 * Disable break condition and FIFOs
 	 */
-	serial_out(up, UART_LCR, serial_inp(up, UART_LCR) & ~UART_LCR_SBC);
+	serial_out(up, UART_LCR, serial_in(up, UART_LCR) & ~UART_LCR_SBC);
 	serial8250_clear_fifos(up);
 
-#ifdef CONFIG_SERIAL_8250_RSA
-	/*
-	 * Reset the RSA board back to 115kbps compat mode.
-	 */
-	disable_rsa(up);
-#endif
-
 	/*
 	 * Read data port to reset things, and then unlink from
 	 * the IRQ chain.
@@ -2289,7 +1318,11 @@ serial8250_set_termios(struct uart_port
 	 * have sufficient FIFO entries for the latency of the remote
 	 * UART to respond.  IOW, at least 32 bytes of FIFO.
 	 */
+#ifdef CONFIG_SERIAL_RTL8198_UART1
+	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 16) {
+#else
 	if (up->capabilities & UART_CAP_AFE && up->port.fifosize >= 32) {
+#endif
 		up->mcr &= ~UART_MCR_AFE;
 		if (termios->c_cflag & CRTSCTS)
 			up->mcr |= UART_MCR_AFE;
@@ -2356,46 +1389,21 @@ serial8250_set_termios(struct uart_port
 		if (termios->c_cflag & CRTSCTS)
 			efr |= UART_EFR_CTS;
 
-		serial_outp(up, UART_LCR, 0xBF);
-		serial_outp(up, UART_EFR, efr);
-	}
-
-#ifdef CONFIG_ARCH_OMAP
-	/* Workaround to enable 115200 baud on OMAP1510 internal ports */
-	if (cpu_is_omap1510() && is_omap_port(up)) {
-		if (baud == 115200) {
-			quot = 1;
-			serial_out(up, UART_OMAP_OSC_12M_SEL, 1);
-		} else
-			serial_out(up, UART_OMAP_OSC_12M_SEL, 0);
-	}
-#endif
-
-	if (up->capabilities & UART_NATSEMI) {
-		/* Switch to bank 2 not bank 1, to avoid resetting EXCR2 */
-		serial_outp(up, UART_LCR, 0xe0);
-	} else {
-		serial_outp(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
+		serial_out(up, UART_LCR, 0xBF);
+		serial_out(up, UART_EFR, efr);
 	}
 
+    serial_out(up, UART_LCR, cval | UART_LCR_DLAB);/* set DLAB */
 	serial_dl_write(up, quot);
 
-	/*
-	 * LCR DLAB must be set to enable 64-byte FIFO mode. If the FCR
-	 * is written without DLAB set, this mode will be disabled.
-	 */
-	if (up->port.type == PORT_16750)
-		serial_outp(up, UART_FCR, fcr);
-
-	serial_outp(up, UART_LCR, cval);		/* reset DLAB */
+	serial_out(up, UART_LCR, cval);		/* reset DLAB */
 	up->lcr = cval;					/* Save LCR */
-	if (up->port.type != PORT_16750) {
 		if (fcr & UART_FCR_ENABLE_FIFO) {
 			/* emulated UARTs (Lucent Venus 167x) need two steps */
-			serial_outp(up, UART_FCR, UART_FCR_ENABLE_FIFO);
-		}
-		serial_outp(up, UART_FCR, fcr);		/* set fcr */
+      serial_out(up, UART_FCR, UART_FCR_ENABLE_FIFO);
 	}
+    serial_out(up, UART_FCR, fcr);		/* set fcr */
+
 	serial8250_set_mctrl(&up->port, up->port.mctrl);
 	spin_unlock_irqrestore(&up->port.lock, flags);
 	/* Don't rewrite B0 */
@@ -2417,12 +1425,6 @@ serial8250_pm(struct uart_port *port, un
 
 static unsigned int serial8250_port_size(struct uart_8250_port *pt)
 {
-	if (pt->port.iotype == UPIO_AU)
-		return 0x100000;
-#ifdef CONFIG_ARCH_OMAP
-	if (is_omap_port(pt))
-		return 0x16 << pt->port.regshift;
-#endif
 	return 8 << pt->port.regshift;
 }
 
@@ -2435,8 +1437,6 @@ static int serial8250_request_std_resour
 	int ret = 0;
 
 	switch (up->port.iotype) {
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_MEM32:
 	case UPIO_MEM:
 	case UPIO_DWAPB:
@@ -2463,6 +1463,8 @@ static int serial8250_request_std_resour
 		if (!request_region(up->port.iobase, size, "serial"))
 			ret = -EBUSY;
 		break;
+	case UPIO_I2C:
+		break;
 	}
 	return ret;
 }
@@ -2472,8 +1474,6 @@ static void serial8250_release_std_resou
 	unsigned int size = serial8250_port_size(up);
 
 	switch (up->port.iotype) {
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_MEM32:
 	case UPIO_MEM:
 	case UPIO_DWAPB:
@@ -2492,38 +1492,7 @@ static void serial8250_release_std_resou
 	case UPIO_PORT:
 		release_region(up->port.iobase, size);
 		break;
-	}
-}
-
-static int serial8250_request_rsa_resource(struct uart_8250_port *up)
-{
-	unsigned long start = UART_RSA_BASE << up->port.regshift;
-	unsigned int size = 8 << up->port.regshift;
-	int ret = -EINVAL;
-
-	switch (up->port.iotype) {
-	case UPIO_HUB6:
-	case UPIO_PORT:
-		start += up->port.iobase;
-		if (request_region(start, size, "serial-rsa"))
-			ret = 0;
-		else
-			ret = -EBUSY;
-		break;
-	}
-
-	return ret;
-}
-
-static void serial8250_release_rsa_resource(struct uart_8250_port *up)
-{
-	unsigned long offset = UART_RSA_BASE << up->port.regshift;
-	unsigned int size = 8 << up->port.regshift;
-
-	switch (up->port.iotype) {
-	case UPIO_HUB6:
-	case UPIO_PORT:
-		release_region(up->port.iobase + offset, size);
+	case UPIO_I2C:
 		break;
 	}
 }
@@ -2533,29 +1502,18 @@ static void serial8250_release_port(stru
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
 
 	serial8250_release_std_resource(up);
-	if (up->port.type == PORT_RSA)
-		serial8250_release_rsa_resource(up);
 }
 
 static int serial8250_request_port(struct uart_port *port)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	int ret = 0;
 
-	ret = serial8250_request_std_resource(up);
-	if (ret == 0 && up->port.type == PORT_RSA) {
-		ret = serial8250_request_rsa_resource(up);
-		if (ret < 0)
-			serial8250_release_std_resource(up);
-	}
-
-	return ret;
+	return serial8250_request_std_resource(up);
 }
 
 static void serial8250_config_port(struct uart_port *port, int flags)
 {
 	struct uart_8250_port *up = (struct uart_8250_port *)port;
-	int probeflags = PROBE_ANY;
 	int ret;
 
 	/*
@@ -2566,20 +1524,9 @@ static void serial8250_config_port(struc
 	if (ret < 0)
 		return;
 
-	ret = serial8250_request_rsa_resource(up);
-	if (ret < 0)
-		probeflags &= ~PROBE_RSA;
-
 	if (up->port.iotype != up->cur_iotype)
 		set_io_from_upio(port);
 
-	if (flags & UART_CONFIG_TYPE)
-		autoconfig(up, probeflags);
-	if (up->port.type != PORT_UNKNOWN && flags & UART_CONFIG_IRQ)
-		autoconfig_irq(up);
-
-	if (up->port.type != PORT_RSA && probeflags & PROBE_RSA)
-		serial8250_release_rsa_resource(up);
 	if (up->port.type == PORT_UNKNOWN)
 		serial8250_release_std_resource(up);
 }
@@ -2773,6 +1720,14 @@ static int __init serial8250_console_set
 	int parity = 'n';
 	int flow = 'n';
 
+#ifdef CONFIG_SERIAL_SC16IS7X0
+	extern int __init early_sc16is7x0_init_i2c_and_check( void );
+	if( serial8250_ports[co->index].port.iotype == UPIO_I2C &&
+		early_sc16is7x0_init_i2c_and_check() != 0 )
+	{
+		return -ENODEV;
+	}
+#endif
 	/*
 	 * Check whether an invalid uart number has been specified, and
 	 * if so, search for the first available port that does have
@@ -2902,19 +1857,6 @@ void serial8250_resume_port(int line)
 {
 	struct uart_8250_port *up = &serial8250_ports[line];
 
-	if (up->capabilities & UART_NATSEMI) {
-		unsigned char tmp;
-
-		/* Ensure it's still in high speed mode */
-		serial_outp(up, UART_LCR, 0xE0);
-
-		tmp = serial_in(up, 0x04); /* EXCR2 */
-		tmp &= ~0xB0; /* Disable LOCK, mask out PRESL[01] */
-		tmp |= 0x10;  /* 1.625 divisor for baud_base --> 921600 */
-		serial_outp(up, 0x04, tmp);
-
-		serial_outp(up, UART_LCR, 0);
-	}
 	uart_resume_port(&serial8250_reg, &up->port);
 }
 
@@ -3159,12 +2101,8 @@ static int __init serial8250_init(void)
 		"%d ports, IRQ sharing %sabled\n", nr_uarts,
 		share_irqs ? "en" : "dis");
 
-#ifdef CONFIG_SPARC
-	ret = sunserial_register_minors(&serial8250_reg, UART_NR);
-#else
 	serial8250_reg.nr = UART_NR;
 	ret = uart_register_driver(&serial8250_reg);
-#endif
 	if (ret)
 		goto out;
 
@@ -3189,11 +2127,7 @@ static int __init serial8250_init(void)
 put_dev:
 	platform_device_put(serial8250_isa_devs);
 unreg_uart_drv:
-#ifdef CONFIG_SPARC
-	sunserial_unregister_minors(&serial8250_reg, UART_NR);
-#else
 	uart_unregister_driver(&serial8250_reg);
-#endif
 out:
 	return ret;
 }
@@ -3212,11 +2146,7 @@ static void __exit serial8250_exit(void)
 	platform_driver_unregister(&serial8250_isa_driver);
 	platform_device_unregister(isa_dev);
 
-#ifdef CONFIG_SPARC
-	sunserial_unregister_minors(&serial8250_reg, UART_NR);
-#else
 	uart_unregister_driver(&serial8250_reg);
-#endif
 }
 
 module_init(serial8250_init);
@@ -3235,8 +2165,4 @@ MODULE_PARM_DESC(share_irqs, "Share IRQs
 module_param(nr_uarts, uint, 0644);
 MODULE_PARM_DESC(nr_uarts, "Maximum number of UARTs supported. (1-" __MODULE_STRING(CONFIG_SERIAL_8250_NR_UARTS) ")");
 
-#ifdef CONFIG_SERIAL_8250_RSA
-module_param_array(probe_rsa, ulong, &probe_rsa_count, 0444);
-MODULE_PARM_DESC(probe_rsa, "Probe I/O ports for RSA");
-#endif
 MODULE_ALIAS_CHARDEV_MAJOR(TTY_MAJOR);
--- linux-2.6.30.9/drivers/serial/8250.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/serial/8250.h	2013-05-02 01:47:55.684226900 +0300
@@ -60,20 +60,4 @@ struct serial8250_config {
 #define SERIAL8250_SHARE_IRQS 0
 #endif
 
-#if defined(__alpha__) && !defined(CONFIG_PCI)
-/*
- * Digital did something really horribly wrong with the OUT1 and OUT2
- * lines on at least some ALPHA's.  The failure mode is that if either
- * is cleared, the machine locks up with endless interrupts.
- */
-#define ALPHA_KLUDGE_MCR  (UART_MCR_OUT2 | UART_MCR_OUT1)
-#elif defined(CONFIG_SBC8560)
-/*
- * WindRiver did something similarly broken on their SBC8560 board. The
- * UART tristates its IRQ output while OUT2 is clear, but they pulled
- * the interrupt line _up_ instead of down, so if we register the IRQ
- * while the UART is in that state, we die in an IRQ storm. */
-#define ALPHA_KLUDGE_MCR (UART_MCR_OUT2)
-#else
 #define ALPHA_KLUDGE_MCR 0
-#endif
--- linux-2.6.30.9/drivers/serial/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/serial/Kconfig	2013-05-02 01:47:55.686226899 +0300
@@ -1,9 +1,10 @@
 #
 # Serial device configuration
 #
+# $Id: Kconfig,v 1.11 2004/03/11 18:08:04 lethal Exp $
+#
 
 menu "Serial drivers"
-	depends on HAS_IOMEM
 
 #
 # The new 8250/16550 serial drivers
@@ -59,61 +60,6 @@ config SERIAL_8250_CONSOLE
 	  kernel will automatically use the first serial line, /dev/ttyS0, as
 	  system console.
 
-	  You can set that using a kernel command line option such as
-	  "console=uart8250,io,0x3f8,9600n8"
-	  "console=uart8250,mmio,0xff5e0000,115200n8".
-	  and it will switch to normal serial console when the corresponding 
-	  port is ready.
-	  "earlycon=uart8250,io,0x3f8,9600n8"
-	  "earlycon=uart8250,mmio,0xff5e0000,115200n8".
-	  it will not only setup early console.
-
-	  If unsure, say N.
-
-config FIX_EARLYCON_MEM
-	bool
-	depends on X86
-	default y
-
-config SERIAL_8250_GSC
-	tristate
-	depends on SERIAL_8250 && GSC
-	default SERIAL_8250
-
-config SERIAL_8250_PCI
-	tristate "8250/16550 PCI device support" if EMBEDDED
-	depends on SERIAL_8250 && PCI
-	default SERIAL_8250
-	help
-	  This builds standard PCI serial support. You may be able to
-	  disable this feature if you only need legacy serial support.
-	  Saves about 9K.
-
-config SERIAL_8250_PNP
-	tristate "8250/16550 PNP device support" if EMBEDDED
-	depends on SERIAL_8250 && PNP
-	default SERIAL_8250
-	help
-	  This builds standard PNP serial support. You may be able to
-	  disable this feature if you only need legacy serial support.
-
-config SERIAL_8250_HP300
-	tristate
-	depends on SERIAL_8250 && HP300
-	default SERIAL_8250
-
-config SERIAL_8250_CS
-	tristate "8250/16550 PCMCIA device support"
-	depends on PCMCIA && SERIAL_8250
-	---help---
-	  Say Y here to enable support for 16-bit PCMCIA serial devices,
-	  including serial port cards, modems, and the modem functions of
-	  multi-function Ethernet/modem cards. (PCMCIA- or PC-cards are
-	  credit-card size devices often used with laptops.)
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called serial_cs.
-
 	  If unsure, say N.
 
 config SERIAL_8250_NR_UARTS
@@ -163,58 +109,6 @@ config SERIAL_8250_MANY_PORTS
 	  say N here to save some memory. You can also say Y if you have an
 	  "intelligent" multiport card such as Cyclades, Digiboards, etc.
 
-#
-# Multi-port serial cards
-#
-
-config SERIAL_8250_FOURPORT
-	tristate "Support Fourport cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have an AST FourPort serial board.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_fourport.
-
-config SERIAL_8250_ACCENT
-	tristate "Support Accent cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have an Accent Async serial board.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_accent.
-
-config SERIAL_8250_BOCA
-	tristate "Support Boca cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have a Boca serial board.  Please read the Boca
-	  mini-HOWTO, available from <http://www.tldp.org/docs.html#howto>
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_boca.
-
-config SERIAL_8250_EXAR_ST16C554
-	tristate "Support Exar ST16C554/554D Quad UART"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  The Uplogix Envoy TU301 uses this Exar Quad UART.  If you are
-	  tinkering with your Envoy TU301, or have a machine with this UART,
-	  say Y here.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_exar_st16c554.
-
-config SERIAL_8250_HUB6
-	tristate "Support Hub6 cards"
-	depends on SERIAL_8250 != n && ISA && SERIAL_8250_MANY_PORTS
-	help
-	  Say Y here if you have a HUB6 serial board.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_hub6.
-
 config SERIAL_8250_SHARE_IRQ
 	bool "Support for sharing serial interrupts"
 	depends on SERIAL_8250_EXTENDED
@@ -223,1214 +117,48 @@ config SERIAL_8250_SHARE_IRQ
 	  serial ports on the same board to share a single IRQ. To enable
 	  support for this in the serial driver, say Y here.
 
-config SERIAL_8250_DETECT_IRQ
-	bool "Autodetect IRQ on standard ports (unsafe)"
-	depends on SERIAL_8250_EXTENDED
-	help
-	  Say Y here if you want the kernel to try to guess which IRQ
-	  to use for your serial port.
-
-	  This is considered unsafe; it is far better to configure the IRQ in
-	  a boot script using the setserial command.
-
-	  If unsure, say N.
-
-config SERIAL_8250_RSA
-	bool "Support RSA serial ports"
-	depends on SERIAL_8250_EXTENDED
-	help
-	  ::: To be written :::
-
-config SERIAL_8250_MCA
-	tristate "Support 8250-type ports on MCA buses"
-	depends on SERIAL_8250 != n && MCA
-	help
-	  Say Y here if you have a MCA serial ports.
-
-	  To compile this driver as a module, choose M here: the module
-	  will be called 8250_mca.
-
-config SERIAL_8250_ACORN
-	tristate "Acorn expansion card serial port support"
-	depends on ARCH_ACORN && SERIAL_8250
-	help
-	  If you have an Atomwide Serial card or Serial Port card for an Acorn
-	  system, say Y to this option.  The driver can handle 1, 2, or 3 port
-	  cards.  If unsure, say N.
-
-config SERIAL_8250_AU1X00
-	bool "Au1x00 serial port support"
-	depends on SERIAL_8250 != n && SOC_AU1X00
-	help
-	  If you have an Au1x00 SOC based board and want to use the serial port,
-	  say Y to this option. The driver can handle up to 4 serial ports,
-	  depending on the SOC. If unsure, say N.
-
-config SERIAL_8250_RM9K
-	bool "Support for MIPS RM9xxx integrated serial port"
-	depends on SERIAL_8250 != n && SERIAL_RM9000
-	select SERIAL_8250_SHARE_IRQ
-	help
-	  Selecting this option will add support for the integrated serial
-	  port hardware found on MIPS RM9122 and similar processors.
-	  If unsure, say N.
-
-comment "Non-8250 serial port support"
-
-config SERIAL_AMBA_PL010
-	tristate "ARM AMBA PL010 serial port support"
-	depends on ARM_AMBA && (BROKEN || !ARCH_VERSATILE)
-	select SERIAL_CORE
-	help
-	  This selects the ARM(R) AMBA(R) PrimeCell PL010 UART.  If you have
-	  an Integrator/AP or Integrator/PP2 platform, or if you have a
-	  Cirrus Logic EP93xx CPU, say Y or M here.
-
-	  If unsure, say N.
-
-config SERIAL_AMBA_PL010_CONSOLE
-	bool "Support for console on AMBA serial port"
-	depends on SERIAL_AMBA_PL010=y
-	select SERIAL_CORE_CONSOLE
-	---help---
-	  Say Y here if you wish to use an AMBA PrimeCell UART as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyAM0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_AMBA_PL011
-	tristate "ARM AMBA PL011 serial port support"
-	depends on ARM_AMBA
-	select SERIAL_CORE
-	help
-	  This selects the ARM(R) AMBA(R) PrimeCell PL011 UART.  If you have
-	  an Integrator/PP2, Integrator/CP or Versatile platform, say Y or M
-	  here.
-
-	  If unsure, say N.
-
-config SERIAL_AMBA_PL011_CONSOLE
-	bool "Support for console on AMBA serial port"
-	depends on SERIAL_AMBA_PL011=y
-	select SERIAL_CORE_CONSOLE
-	---help---
-	  Say Y here if you wish to use an AMBA PrimeCell UART as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyAMA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SB1250_DUART
-	tristate "BCM1xxx on-chip DUART serial support"
-	depends on SIBYTE_SB1xxx_SOC=y
-	select SERIAL_CORE
-	default y
-	---help---
-	  Support for the asynchronous serial interface (DUART) included in
-	  the BCM1250 and derived System-On-a-Chip (SOC) devices.  Note that
-	  the letter D in DUART stands for "dual", which is how the device
-	  is implemented.  Depending on the SOC configuration there may be
-	  one or more DUARTs available of which all are handled.
-
-	  If unsure, say Y.  To compile this driver as a module, choose M here:
-	  the module will be called sb1250-duart.
-
-config SERIAL_SB1250_DUART_CONSOLE
-	bool "Support for console on a BCM1xxx DUART serial port"
-	depends on SERIAL_SB1250_DUART=y
-	select SERIAL_CORE_CONSOLE
-	default y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode).
-
-	  If unsure, say Y.
-
-config SERIAL_ATMEL
-	bool "AT91 / AT32 on-chip serial port support"
-	depends on (ARM && ARCH_AT91) || AVR32
-	select SERIAL_CORE
-	help
-	  This enables the driver for the on-chip UARTs of the Atmel
-	  AT91 and AT32 processors.
-
-config SERIAL_ATMEL_CONSOLE
-	bool "Support for console on AT91 / AT32 serial port"
-	depends on SERIAL_ATMEL=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use an on-chip UART on a Atmel
-	  AT91 or AT32 processor as the system console (the system
-	  console is the device which receives all kernel messages and
-	  warnings and which allows logins in single user mode).
-
-config SERIAL_ATMEL_PDC
-	bool "Support DMA transfers on AT91 / AT32 serial port"
-	depends on SERIAL_ATMEL
-	default y
-	help
-	  Say Y here if you wish to use the PDC to do DMA transfers to
-	  and from the Atmel AT91 / AT32 serial port. In order to
-	  actually use DMA transfers, make sure that the use_dma_tx
-	  and use_dma_rx members in the atmel_uart_data struct is set
-	  appropriately for each port.
-
-	  Note that break and error handling currently doesn't work
-	  properly when DMA is enabled. Make sure that ports where
-	  this matters don't use DMA.
-
-config SERIAL_ATMEL_TTYAT
-	bool "Install as device ttyATn instead of ttySn"
-	depends on SERIAL_ATMEL=y
-	help
-	  Say Y here if you wish to have the internal AT91 / AT32 UARTs
-	  appear as /dev/ttyATn (major 204, minor starting at 154)
-	  instead of the normal /dev/ttySn (major 4, minor starting at
-	  64). This is necessary if you also want other UARTs, such as
-	  external 8250/16C550 compatible UARTs.
-	  The ttySn nodes are legally reserved for the 8250 serial driver
-	  but are often misused by other serial drivers.
-
-	  To use this, you should create suitable ttyATn device nodes in
-	  /dev/, and pass "console=ttyATn" to the kernel.
-
-	  Say Y if you have an external 8250/16C550 UART.  If unsure, say N.
-
-config SERIAL_KS8695
-	bool "Micrel KS8695 (Centaur) serial port support"
-	depends on ARCH_KS8695
-	select SERIAL_CORE
-	help
-	  This selects the Micrel Centaur KS8695 UART.  Say Y here.
-
-config SERIAL_KS8695_CONSOLE
-	bool "Support for console on KS8695 (Centaur) serial port"
-	depends on SERIAL_KS8695=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use a KS8695 (Centaur) UART as the
-	  system console (the system console is the device which
-	  receives all kernel messages and warnings and which allows
-	  logins in single user mode).
-
-config SERIAL_CLPS711X
-	tristate "CLPS711X serial port support"
-	depends on ARM && ARCH_CLPS711X
-	select SERIAL_CORE
-	help
-	  ::: To be written :::
-
-config SERIAL_CLPS711X_CONSOLE
-	bool "Support for console on CLPS711X serial port"
-	depends on SERIAL_CLPS711X=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyCL1". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SAMSUNG
-	tristate "Samsung SoC serial support"
-	depends on ARM && PLAT_S3C
-	select SERIAL_CORE
-	help
-	  Support for the on-chip UARTs on the Samsung S3C24XX series CPUs,
-	  providing /dev/ttySAC0, 1 and 2 (note, some machines may not
-	  provide all of these ports, depending on how the serial port
-	  pins are configured.
-
-config SERIAL_SAMSUNG_UARTS
-	int
-	depends on ARM && PLAT_S3C
-	default 2 if ARCH_S3C2400
-	default 4 if ARCH_S3C64XX || CPU_S3C2443
-	default 3
-	help
-	  Select the number of available UART ports for the Samsung S3C
-	  serial driver
-	
-config SERIAL_SAMSUNG_DEBUG
-	bool "Samsung SoC serial debug"
-	depends on SERIAL_SAMSUNG && DEBUG_LL
-	help
-	  Add support for debugging the serial driver. Since this is
-	  generally being used as a console, we use our own output
-	  routines that go via the low-level debug printascii()
-	  function.
-
-config SERIAL_SAMSUNG_CONSOLE
-	bool "Support for console on Samsung SoC serial port"
-	depends on SERIAL_SAMSUNG=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Allow selection of the S3C24XX on-board serial ports for use as
-	  an virtual console.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySACx". (Try "man bootparam" or see the documentation of
-	  your boot loader about how to pass options to the kernel at
-	  boot time.)
-
-config SERIAL_S3C2400
-	tristate "Samsung S3C2410 Serial port support"
-	depends on ARM && SERIAL_SAMSUNG && CPU_S3C2400
-	default y if CPU_S3C2400
-	help
-	  Serial port support for the Samsung S3C2400 SoC
-
-config SERIAL_S3C2410
-	tristate "Samsung S3C2410 Serial port support"
-	depends on SERIAL_SAMSUNG && CPU_S3C2410
-	default y if CPU_S3C2410
-	help
-	  Serial port support for the Samsung S3C2410 SoC
-
-config SERIAL_S3C2412
-	tristate "Samsung S3C2412/S3C2413 Serial port support"
-	depends on SERIAL_SAMSUNG && CPU_S3C2412
-	default y if CPU_S3C2412
-	help
-	  Serial port support for the Samsung S3C2412 and S3C2413 SoC
-
-config SERIAL_S3C2440
-	tristate "Samsung S3C2440/S3C2442 Serial port support"
-	depends on SERIAL_SAMSUNG && (CPU_S3C2440 || CPU_S3C2442)
-	default y if CPU_S3C2440
-	default y if CPU_S3C2442
-	help
-	  Serial port support for the Samsung S3C2440 and S3C2442 SoC
-
-config SERIAL_S3C24A0
-	tristate "Samsung S3C24A0 Serial port support"
-	depends on SERIAL_SAMSUNG && CPU_S3C24A0
-	default y if CPU_S3C24A0
-	help
-	  Serial port support for the Samsung S3C24A0 SoC
-
-config SERIAL_S3C6400
-	tristate "Samsung S3C6400/S3C6410 Serial port support"
-	depends on SERIAL_SAMSUNG && (CPU_S3C600 || CPU_S3C6410)
-	default y
-	help
-	  Serial port support for the Samsung S3C6400 and S3C6410
-	  SoCs
-
-config SERIAL_MAX3100
-	tristate "MAX3100 support"
-	depends on SPI
-	select SERIAL_CORE
-	help
-	  MAX3100 chip support
-
-config SERIAL_DZ
-	bool "DECstation DZ serial driver"
-	depends on MACH_DECSTATION && 32BIT
-	select SERIAL_CORE
-	default y
-	---help---
-	  DZ11-family serial controllers for DECstations and VAXstations,
-	  including the DC7085, M7814, and M7819.
-
-config SERIAL_DZ_CONSOLE
-	bool "Support console on DECstation DZ serial driver"
-	depends on SERIAL_DZ=y
-	select SERIAL_CORE_CONSOLE
-	default y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode).
-
-	  Note that the firmware uses ttyS3 as the serial console on
-	  DECstations that use this driver.
-
-	  If unsure, say Y.
-
-config SERIAL_ZS
-	tristate "DECstation Z85C30 serial support"
-	depends on MACH_DECSTATION
-	select SERIAL_CORE
-	default y
-	---help---
-	  Support for the Zilog 85C350 serial communications controller used
-	  for serial ports in newer DECstation systems.  These include the
-	  DECsystem 5900 and all models of the DECstation and DECsystem 5000
-	  systems except from model 200.
-
-	  If unsure, say Y.  To compile this driver as a module, choose M here:
-	  the module will be called zs.
-
-config SERIAL_ZS_CONSOLE
-	bool "Support for console on a DECstation Z85C30 serial port"
-	depends on SERIAL_ZS=y
-	select SERIAL_CORE_CONSOLE
-	default y
-	---help---
-	  If you say Y here, it will be possible to use a serial port as the
-	  system console (the system console is the device which receives all
-	  kernel messages and warnings and which allows logins in single user
-	  mode).
-
-	  Note that the firmware uses ttyS1 as the serial console on the
-	  Maxine and ttyS3 on the others using this driver.
-
-	  If unsure, say Y.
-
-config SERIAL_21285
-	tristate "DC21285 serial port support"
-	depends on ARM && FOOTBRIDGE
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a 21285 (Footbridge) StrongARM(R)/
-	  PCI bridge you can enable its onboard serial port by enabling this
-	  option.
-
-config SERIAL_21285_CONSOLE
-	bool "Console on DC21285 serial port"
-	depends on SERIAL_21285=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the 21285 footbridge you can
-	  make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyFB". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_MPSC
-	bool "Marvell MPSC serial port support"
-	depends on PPC32 && MV64X60
-	select SERIAL_CORE
-	help
-	  Say Y here if you want to use the Marvell MPSC serial controller.
-
-config SERIAL_MPSC_CONSOLE
-	bool "Support for console on Marvell MPSC serial port"
-	depends on SERIAL_MPSC
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you want to support a serial console on a Marvell MPSC.
-
-config SERIAL_PXA
-	bool "PXA serial port support"
-	depends on ARCH_PXA || ARCH_MMP
-	select SERIAL_CORE
-	help
-	  If you have a machine based on an Intel XScale PXA2xx CPU you
-	  can enable its onboard serial ports by enabling this option.
-
-config SERIAL_PXA_CONSOLE
-	bool "Console on PXA serial port"
-	depends on SERIAL_PXA
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the Intel XScale PXA
-	  CPU you can make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SA1100
-	bool "SA1100 serial port support"
-	depends on ARM && ARCH_SA1100
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a SA1100/SA1110 StrongARM(R) CPU you
-	  can enable its onboard serial port by enabling this option.
-	  Please read <file:Documentation/arm/SA1100/serial_UART> for further
-	  info.
-
-config SERIAL_SA1100_CONSOLE
-	bool "Console on SA1100 serial port"
-	depends on SERIAL_SA1100
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the SA1100/SA1110 StrongARM
-	  CPU you can make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_BFIN
-	tristate "Blackfin serial port support"
-	depends on BLACKFIN
-	select SERIAL_CORE
-	select SERIAL_BFIN_UART0 if (BF531 || BF532 || BF533 || BF561)
-	help
-	  Add support for the built-in UARTs on the Blackfin.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bfin_5xx.
-
-config SERIAL_BFIN_CONSOLE
-	bool "Console on Blackfin serial port"
-	depends on SERIAL_BFIN=y
-	select SERIAL_CORE_CONSOLE
-
-choice
-	prompt "UART Mode"
-	depends on SERIAL_BFIN
-	default SERIAL_BFIN_DMA
-	help
-	  This driver supports the built-in serial ports of the Blackfin family
-	  of CPUs
-
-config SERIAL_BFIN_DMA
-	bool "DMA mode"
-	depends on !DMA_UNCACHED_NONE && KGDB_SERIAL_CONSOLE=n
-	help
-	  This driver works under DMA mode. If this option is selected, the
-	  blackfin simple dma driver is also enabled.
-
-config SERIAL_BFIN_PIO
-	bool "PIO mode"
-	help
-	  This driver works under PIO mode.
-
-endchoice
-
-config SERIAL_BFIN_UART0
-	bool "Enable UART0"
-	depends on SERIAL_BFIN
-	help
-	  Enable UART0
-
-config BFIN_UART0_CTSRTS
-	bool "Enable UART0 hardware flow control"
-	depends on SERIAL_BFIN_UART0
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART0_CTS_PIN
-	int "UART0 CTS pin"
-	depends on BFIN_UART0_CTSRTS && !BF548
-	default 23
-	help
-	  The default pin is GPIO_GP7.
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART0_RTS_PIN
-	int "UART0 RTS pin"
-	depends on BFIN_UART0_CTSRTS && !BF548
-	default 22
-	help
-	  The default pin is GPIO_GP6.
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_BFIN_UART1
-	bool "Enable UART1"
-	depends on SERIAL_BFIN && (!BF531 && !BF532 && !BF533 && !BF561)
-	help
-	  Enable UART1
-
-config BFIN_UART1_CTSRTS
-	bool "Enable UART1 hardware flow control"
-	depends on SERIAL_BFIN_UART1
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART1_CTS_PIN
-	int "UART1 CTS pin"
-	depends on BFIN_UART1_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART1_RTS_PIN
-	int "UART1 RTS pin"
-	depends on BFIN_UART1_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_BFIN_UART2
-	bool "Enable UART2"
-	depends on SERIAL_BFIN && (BF54x || BF538 || BF539)
-	help
-	  Enable UART2
-
-config BFIN_UART2_CTSRTS
-	bool "Enable UART2 hardware flow control"
-	depends on SERIAL_BFIN_UART2
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART2_CTS_PIN
-	int "UART2 CTS pin"
-	depends on BFIN_UART2_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART2_RTS_PIN
-	int "UART2 RTS pin"
-	depends on BFIN_UART2_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_BFIN_UART3
-	bool "Enable UART3"
-	depends on SERIAL_BFIN && (BF54x)
-	help
-	  Enable UART3
-
-config BFIN_UART3_CTSRTS
-	bool "Enable UART3 hardware flow control"
-	depends on SERIAL_BFIN_UART3
-	help
-	  Enable hardware flow control in the driver. Using GPIO emulate the CTS/RTS
-	  signal.
-
-config UART3_CTS_PIN
-	int "UART3 CTS pin"
-	depends on BFIN_UART3_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config UART3_RTS_PIN
-	int "UART3 RTS pin"
-	depends on BFIN_UART3_CTSRTS && !BF548
-	default -1
-	help
-	  Refer to arch/blackfin/mach-*/include/mach/gpio.h to see the GPIO map.
-
-config SERIAL_IMX
-	bool "IMX serial port support"
-	depends on ARM && (ARCH_IMX || ARCH_MXC)
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a Motorola IMX CPU you
-	  can enable its onboard serial port by enabling this option.
-
-config SERIAL_IMX_CONSOLE
-	bool "Console on IMX serial port"
-	depends on SERIAL_IMX
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the Motorola IMX
-	  CPU you can make it the console by answering Y to this option.
-
-	  Even if you say Y here, the currently visible virtual console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttySA0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_UARTLITE
-	tristate "Xilinx uartlite serial port support"
-	depends on PPC32 || MICROBLAZE
-	select SERIAL_CORE
-	help
-	  Say Y here if you want to use the Xilinx uartlite serial controller.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called uartlite.ko.
-
-config SERIAL_UARTLITE_CONSOLE
-	bool "Support for console on Xilinx uartlite serial port"
-	depends on SERIAL_UARTLITE=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use a Xilinx uartlite as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-config SERIAL_SUNCORE
-	bool
-	depends on SPARC
-	select SERIAL_CORE
-	select SERIAL_CORE_CONSOLE
-	default y
-
-config SERIAL_SUNZILOG
-	tristate "Sun Zilog8530 serial support"
-	depends on SPARC
-	help
-	  This driver supports the Zilog8530 serial ports found on many Sparc
-	  systems.  Say Y or M if you want to be able to these serial ports.
-
-config SERIAL_SUNZILOG_CONSOLE
-	bool "Console on Sun Zilog8530 serial port"
-	depends on SERIAL_SUNZILOG=y
-	help
-	  If you would like to be able to use the Zilog8530 serial port
-	  on your Sparc system as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_SUNSU
-	tristate "Sun SU serial support"
-	depends on SPARC && PCI
-	help
-	  This driver supports the 8250 serial ports that run the keyboard and
-	  mouse on (PCI) UltraSPARC systems.  Say Y or M if you want to be able
-	  to these serial ports.
-
-config SERIAL_SUNSU_CONSOLE
-	bool "Console on Sun SU serial port"
-	depends on SERIAL_SUNSU=y
-	help
-	  If you would like to be able to use the SU serial port
-	  on your Sparc system as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_MUX
-	tristate "Serial MUX support"
-	depends on GSC
-	select SERIAL_CORE
-	default y
-	---help---
-	  Saying Y here will enable the hardware MUX serial driver for
-	  the Nova, K class systems and D class with a 'remote control card'.
-	  The hardware MUX is not 8250/16550 compatible therefore the
-	  /dev/ttyB0 device is shared between the Serial MUX and the PDC
-	  software console. The following steps need to be completed to use
-	  the Serial MUX:
-
-	    1. create the device entry (mknod /dev/ttyB0 c 11 0)
-	    2. Edit the /etc/inittab to start a getty listening on /dev/ttyB0
-	    3. Add device ttyB0 to /etc/securetty (if you want to log on as
-		 root on this console.)
-	    4. Change the kernel command console parameter to: console=ttyB0
-
-config SERIAL_MUX_CONSOLE
-	bool "Support for console on serial MUX"
-	depends on SERIAL_MUX=y
-	select SERIAL_CORE_CONSOLE
-	default y
-
-config PDC_CONSOLE
-	bool "PDC software console support"
-	depends on PARISC && !SERIAL_MUX && VT
-	default n
-	help
-	  Saying Y here will enable the software based PDC console to be 
-	  used as the system console.  This is useful for machines in 
-	  which the hardware based console has not been written yet.  The
-	  following steps must be competed to use the PDC console:
-
-	    1. create the device entry (mknod /dev/ttyB0 c 11 0)
-	    2. Edit the /etc/inittab to start a getty listening on /dev/ttyB0
-	    3. Add device ttyB0 to /etc/securetty (if you want to log on as
-		 root on this console.)
-	    4. Change the kernel command console parameter to: console=ttyB0
-
-config SERIAL_SUNSAB
-	tristate "Sun Siemens SAB82532 serial support"
-	depends on SPARC && PCI
-	help
-	  This driver supports the Siemens SAB82532 DUSCC serial ports on newer
-	  (PCI) UltraSPARC systems.  Say Y or M if you want to be able to these
-	  serial ports.
-
-config SERIAL_SUNSAB_CONSOLE
-	bool "Console on Sun Siemens SAB82532 serial port"
-	depends on SERIAL_SUNSAB=y
-	help
-	  If you would like to be able to use the SAB82532 serial port
-	  on your Sparc system as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_SUNHV
-	bool "Sun4v Hypervisor Console support"
-	depends on SPARC64
-	help
-	  This driver supports the console device found on SUN4V Sparc
-	  systems.  Say Y if you want to be able to use this device.
-
-config SERIAL_IP22_ZILOG
-	tristate "SGI Zilog8530 serial support"
-	depends on SGI_HAS_ZILOG
-	select SERIAL_CORE
-	help
-	  This driver supports the Zilog8530 serial ports found on SGI
-	  systems.  Say Y or M if you want to be able to these serial ports.
-
-config SERIAL_IP22_ZILOG_CONSOLE
-	bool "Console on SGI Zilog8530 serial port"
-	depends on SERIAL_IP22_ZILOG=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_SH_SCI
-	tristate "SuperH SCI(F) serial port support"
-	depends on SUPERH || H8300
-	select SERIAL_CORE
-
-config SERIAL_SH_SCI_NR_UARTS
-	int "Maximum number of SCI(F) serial ports"
-	depends on SERIAL_SH_SCI
-	default "2"
-
-config SERIAL_SH_SCI_CONSOLE
-	bool "Support for console on SuperH SCI(F)"
-	depends on SERIAL_SH_SCI=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_PNX8XXX
-	bool "Enable PNX8XXX SoCs' UART Support"
-	depends on MIPS && (SOC_PNX8550 || SOC_PNX833X)
-	select SERIAL_CORE
-	help
-	  If you have a MIPS-based Philips SoC such as PNX8550 or PNX8330
-	  and you want to use serial ports, say Y.  Otherwise, say N.
-
-config SERIAL_PNX8XXX_CONSOLE
-	bool "Enable PNX8XX0 serial console"
-	depends on SERIAL_PNX8XXX
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have a MIPS-based Philips SoC such as PNX8550 or PNX8330
-	  and you want to use serial console, say Y. Otherwise, say N.
-
 config SERIAL_CORE
 	tristate
 
 config SERIAL_CORE_CONSOLE
 	bool
 
-config CONSOLE_POLL
-	bool
-
-config SERIAL_68328
-	bool "68328 serial support"
-	depends on M68328 || M68EZ328 || M68VZ328
-	help
-	  This driver supports the built-in serial port of the Motorola 68328
-	  (standard, EZ and VZ varieties).
-
-config SERIAL_68328_RTS_CTS
-	bool "Support RTS/CTS on 68328 serial port"
-	depends on SERIAL_68328
-
-config SERIAL_MCF
-	bool "Coldfire serial support"
-	depends on COLDFIRE
-	select SERIAL_CORE
-	help
-	  This serial driver supports the Freescale Coldfire serial ports.
-
-config SERIAL_MCF_BAUDRATE
-	int "Default baudrate for Coldfire serial ports"
-	depends on SERIAL_MCF
-	default 19200
-	help
-	  This setting lets you define what the default baudrate is for the
-	  ColdFire serial ports. The usual default varies from board to board,
-	  and this setting is a way of catering for that.
-
-config SERIAL_MCF_CONSOLE
-	bool "Coldfire serial console support"
-	depends on SERIAL_MCF
-	select SERIAL_CORE_CONSOLE
-	help
-	  Enable a ColdFire internal serial port to be the system console.
-
-config SERIAL_68360_SMC
-	bool "68360 SMC uart support"
-	depends on M68360
-	help
-	  This driver supports the SMC serial ports of the Motorola 68360 CPU.
-
-config SERIAL_68360_SCC
-	bool "68360 SCC uart support"
-	depends on M68360
-	help
-	  This driver supports the SCC serial ports of the Motorola 68360 CPU.
-
-config SERIAL_68360
-	bool
-	depends on SERIAL_68360_SMC || SERIAL_68360_SCC
-	default y
-
-config SERIAL_PMACZILOG
-	tristate "PowerMac z85c30 ESCC support"
-	depends on PPC_OF && PPC_PMAC
-	select SERIAL_CORE
-	help
-	  This driver supports the Zilog z85C30 serial ports found on
-	  PowerMac machines.
-	  Say Y or M if you want to be able to these serial ports.
-
-config SERIAL_PMACZILOG_TTYS
-	bool "Use ttySn device nodes for Zilog z85c30"
-	depends on SERIAL_PMACZILOG
-	help
-	  The pmac_zilog driver for the z85C30 chip on many powermacs
-	  historically used the device numbers for /dev/ttySn.  The
-	  8250 serial port driver also uses these numbers, which means
-	  the two drivers being unable to coexist; you could not use
-	  both z85C30 and 8250 type ports at the same time.
-
-	  If this option is not selected, the pmac_zilog driver will
-	  use the device numbers allocated for /dev/ttyPZn.  This allows
-	  the pmac_zilog and 8250 drivers to co-exist, but may cause
-	  existing userspace setups to break.  Programs that need to
-	  access the built-in serial ports on powermacs will need to
-	  be reconfigured to use /dev/ttyPZn instead of /dev/ttySn.
-
-	  If you enable this option, any z85c30 ports in the system will
-	  be registered as ttyS0 onwards as in the past, and you will be
-	  unable to use the 8250 module for PCMCIA or other 16C550-style
-	  UARTs.
-
-	  Say N unless you need the z85c30 ports on your powermac
-	  to appear as /dev/ttySn.
-
-config SERIAL_PMACZILOG_CONSOLE
-	bool "Console on PowerMac z85c30 serial port"
-	depends on SERIAL_PMACZILOG=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you would like to be able to use the z85c30 serial port
-	  on your PowerMac as the console, you can do so by answering
-	  Y to this option.
-
-config SERIAL_LH7A40X
-	tristate "Sharp LH7A40X embedded UART support"
-	depends on ARM && ARCH_LH7A40X
-	select SERIAL_CORE
-	help
-	  This enables support for the three on-board UARTs of the
-	  Sharp LH7A40X series CPUs.  Choose Y or M.
-
-config SERIAL_LH7A40X_CONSOLE
-	bool "Support for console on Sharp LH7A40X serial port"
-	depends on SERIAL_LH7A40X=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use one of the serial ports as the
-	  system console--the system console is the device which
-	  receives all kernel messages and warnings and which allows
-	  logins in single user mode.
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the default system console, but
-	  you can alter that using a kernel command line, for example
-	  "console=ttyAM1".
-
-config SERIAL_CPM
-	tristate "CPM SCC/SMC serial port support"
-	depends on CPM2 || 8xx
-	select SERIAL_CORE
-	help
-	  This driver supports the SCC and SMC serial ports on Motorola 
-	  embedded PowerPC that contain a CPM1 (8xx) or CPM2 (8xxx)
-
-config SERIAL_CPM_CONSOLE
-	bool "Support for console on CPM SCC/SMC serial port"
-	depends on SERIAL_CPM=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you wish to use a SCC or SMC CPM UART as the system
-	  console (the system console is the device which receives all kernel
-	  messages and warnings and which allows logins in single user mode).
-
-	  Even if you say Y here, the currently visible framebuffer console
-	  (/dev/tty0) will still be used as the system console by default, but
-	  you can alter that using a kernel command line option such as
-	  "console=ttyCPM0". (Try "man bootparam" or see the documentation of
-	  your boot loader (lilo or loadlin) about how to pass options to the
-	  kernel at boot time.)
-
-config SERIAL_SGI_L1_CONSOLE
-	bool "SGI Altix L1 serial console support"
-	depends on IA64_GENERIC || IA64_SGI_SN2
-	select SERIAL_CORE
-	select SERIAL_CORE_CONSOLE
-	help
-		If you have an SGI Altix and you would like to use the system
-		controller serial port as your console (you want this!),
-		say Y.  Otherwise, say N.
-
-config SERIAL_MPC52xx
-	tristate "Freescale MPC52xx/MPC512x family PSC serial support"
-	depends on PPC_MPC52xx || PPC_MPC512x
-	select SERIAL_CORE
-	help
-	  This driver supports MPC52xx and MPC512x PSC serial ports. If you would
-	  like to use them, you must answer Y or M to this option. Note that
-	  for use as console, it must be included in kernel and not as a
-	  module.
-
-config SERIAL_MPC52xx_CONSOLE
-	bool "Console on a Freescale MPC52xx/MPC512x family PSC serial port"
-	depends on SERIAL_MPC52xx=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Select this options if you'd like to use one of the PSC serial port
-	  of the Freescale MPC52xx family as a console.
-
-config SERIAL_MPC52xx_CONSOLE_BAUD
-	int "Freescale MPC52xx/MPC512x family PSC serial port baud"
-	depends on SERIAL_MPC52xx_CONSOLE=y
-	default "9600"
-	help
-	  Select the MPC52xx console baud rate.
-	  This value is only used if the bootloader doesn't pass in the
-	  console baudrate
-
-config SERIAL_ICOM
-	tristate "IBM Multiport Serial Adapter"
-	depends on PCI && (PPC_ISERIES || PPC_PSERIES)
-	select SERIAL_CORE
-	select FW_LOADER
-	help
-	  This driver is for a family of multiport serial adapters
-	  including 2 port RVX, 2 port internal modem, 4 port internal
-	  modem and a split 1 port RVX and 1 port internal modem.
-
-	  This driver can also be built as a module.  If so, the module
-	  will be called icom.
-
-config SERIAL_M32R_SIO
-	bool "M32R SIO I/F"
-	depends on M32R
-	default y
-	select SERIAL_CORE
-	help
-	  Say Y here if you want to use the M32R serial controller.
-
-config SERIAL_M32R_SIO_CONSOLE
-	bool "use SIO console"
-	depends on SERIAL_M32R_SIO=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Say Y here if you want to support a serial console.
-
-	  If you use an M3T-M32700UT or an OPSPUT platform,
-	  please say also y for SERIAL_M32R_PLDSIO.
-
-config SERIAL_M32R_PLDSIO
-	bool "M32R SIO I/F on a PLD"
-	depends on SERIAL_M32R_SIO=y && (PLAT_OPSPUT || PLAT_USRV || PLAT_M32700UT)
-	default n
-	help
-	  Say Y here if you want to use the M32R serial controller
-	  on a PLD (Programmable Logic Device).
-
-	  If you use an M3T-M32700UT or an OPSPUT platform,
-	  please say Y.
-
-config SERIAL_TXX9
-	bool "TMPTX39XX/49XX SIO support"
-	depends on HAS_TXX9_SERIAL
-	select SERIAL_CORE
-	default y
-
-config HAS_TXX9_SERIAL
-	bool
-
-config SERIAL_TXX9_NR_UARTS
-	int "Maximum number of TMPTX39XX/49XX SIO ports"
-	depends on SERIAL_TXX9
-	default "6"
-
-config SERIAL_TXX9_CONSOLE
-	bool "TMPTX39XX/49XX SIO Console support"
-	depends on SERIAL_TXX9=y
-	select SERIAL_CORE_CONSOLE
-
-config SERIAL_TXX9_STDSERIAL
-	bool "TX39XX/49XX SIO act as standard serial"
-	depends on !SERIAL_8250 && SERIAL_TXX9
-
-config SERIAL_VR41XX
-	tristate "NEC VR4100 series Serial Interface Unit support"
-	depends on CPU_VR41XX
-	select SERIAL_CORE
-	help
-	  If you have a NEC VR4100 series processor and you want to use
-	  Serial Interface Unit(SIU) or Debug Serial Interface Unit(DSIU)
-	  (not include VR4111/VR4121 DSIU), say Y.  Otherwise, say N.
-
-config SERIAL_VR41XX_CONSOLE
-	bool "Enable NEC VR4100 series Serial Interface Unit console"
-	depends on SERIAL_VR41XX=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have a NEC VR4100 series processor and you want to use
-	  a console on a serial port, say Y.  Otherwise, say N.
-
-config SERIAL_JSM
-	tristate "Digi International NEO PCI Support"
-	depends on PCI
-	select SERIAL_CORE
-	help
-	  This is a driver for Digi International's Neo series
-	  of cards which provide multiple serial ports. You would need
-	  something like this to connect more than two modems to your Linux
-	  box, for instance in order to become a dial-in server. This driver
-	  supports PCI boards only.
-
-	  If you have a card like this, say Y here, otherwise say N.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called jsm.
-
-config SERIAL_SGI_IOC4
-	tristate "SGI IOC4 controller serial support"
-	depends on (IA64_GENERIC || IA64_SGI_SN2) && SGI_IOC4
-	select SERIAL_CORE
-	help
-		If you have an SGI Altix with an IOC4 based Base IO card
-		and wish to use the serial ports on this card, say Y.
-		Otherwise, say N.
-
-config SERIAL_SGI_IOC3
-	tristate "SGI Altix IOC3 serial support"
-	depends on (IA64_GENERIC || IA64_SGI_SN2) && SGI_IOC3
-	select SERIAL_CORE
-	help
-	  If you have an SGI Altix with an IOC3 serial card,
-	  say Y or M.  Otherwise, say N.
-
-config SERIAL_NETX
-	tristate "NetX serial port support"
-	depends on ARM && ARCH_NETX
-	select SERIAL_CORE
-	help
-	  If you have a machine based on a Hilscher NetX SoC you
-	  can enable its onboard serial port by enabling this option.
-
-          To compile this driver as a module, choose M here: the
-          module will be called netx-serial.
-
-config SERIAL_NETX_CONSOLE
-	bool "Console on NetX serial port"
-	depends on SERIAL_NETX=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  If you have enabled the serial port on the Hilscher NetX SoC
-	  you can make it the console by answering Y to this option.
-
-config SERIAL_OF_PLATFORM
-	tristate "Serial port on Open Firmware platform bus"
-	depends on PPC_OF || MICROBLAZE
-	depends on SERIAL_8250 || SERIAL_OF_PLATFORM_NWPSERIAL
-	help
-	  If you have a PowerPC based system that has serial ports
-	  on a platform specific bus, you should enable this option.
-	  Currently, only 8250 compatible ports are supported, but
-	  others can easily be added.
-
-config SERIAL_OF_PLATFORM_NWPSERIAL
-	tristate "NWP serial port driver"
-	depends on PPC_OF && PPC_DCR
-	select SERIAL_OF_PLATFORM
-	select SERIAL_CORE_CONSOLE
-	select SERIAL_CORE
-	help
-	  This driver supports the cell network processor nwp serial
-	  device.
-
-config SERIAL_OF_PLATFORM_NWPSERIAL_CONSOLE
-	bool "Console on NWP serial port"
-	depends on SERIAL_OF_PLATFORM_NWPSERIAL=y
-	select SERIAL_CORE_CONSOLE
-	help
-	  Support for Console on the NWP serial ports.
-
-config SERIAL_QE
-	tristate "Freescale QUICC Engine serial port support"
-	depends on QUICC_ENGINE
-	select SERIAL_CORE
-	select FW_LOADER
-	default n
-	help
-	  This driver supports the QE serial ports on Freescale embedded
-	  PowerPC that contain a QUICC Engine.
-
-config SERIAL_SC26XX
-	tristate "SC2681/SC2692 serial port support"
-	depends on SNI_RM
-	select SERIAL_CORE
-	help
-	  This is a driver for the onboard serial ports of
-	  older RM400 machines.
-
-config SERIAL_SC26XX_CONSOLE
-	bool "Console on SC2681/SC2692 serial port"
-	depends on SERIAL_SC26XX
-	select SERIAL_CORE_CONSOLE
-	help
-	  Support for Console on SC2681/SC2692 serial ports.
-
-config SERIAL_BFIN_SPORT
-	tristate "Blackfin SPORT emulate UART (EXPERIMENTAL)"
-	depends on BLACKFIN && EXPERIMENTAL
-	select SERIAL_CORE
+comment "8250 compatible port support"
+config SERIAL_RTL8198_UART1
+	bool "8198 UART1 support"
+	depends on SERIAL_8250 && SERIAL_8250_NR_UARTS >= 2 && SERIAL_8250_RUNTIME_UARTS >= 2
+	help
+		Enable 8198 UART1 support, and this MAY add an uart device to ttyS1. 
+		NOTE: We don't provide option for this port to be console. 
+
+config SERIAL_SC16IS7X0
+	bool "SC16IS7x0 series (I2C bus) support"
+	depends on SERIAL_8250 && SERIAL_8250_NR_UARTS >= 2 && SERIAL_8250_RUNTIME_UARTS >= 2
 	help
-	  Enable SPORT emulate UART on Blackfin series.
-
-	  To compile this driver as a module, choose M here: the
-	  module will be called bfin_sport_uart.
-
+		Enable sc16is7x0 definition is to add an UART device to ttyS1. 
+		This is based on standard 8250, and doesn't affect original setting. 
 choice
-	prompt "Baud rate for Blackfin SPORT UART"
-	depends on SERIAL_BFIN_SPORT
-	default SERIAL_SPORT_BAUD_RATE_57600
+	prompt "Crystal for SC16IS7x0 XTAL1"
+	depends on SERIAL_SC16IS7X0
 	help
-	  Choose a baud rate for the SPORT UART, other uart settings are
-	  8 bit, 1 stop bit, no parity, no flow control.
-
-config SERIAL_SPORT_BAUD_RATE_115200
-	bool "115200"
-
-config SERIAL_SPORT_BAUD_RATE_57600
-	bool "57600"
-
-config SERIAL_SPORT_BAUD_RATE_38400
-	bool "38400"
-
-config SERIAL_SPORT_BAUD_RATE_19200
-	bool "19200"
-
-config SERIAL_SPORT_BAUD_RATE_9600
-	bool "9600"
+		Crystal for SC16IS7x0 XTAL1. 
+		This is factor of baudrate, so bad parameter will cause UART to be 
+		abnormal.
+	config SERIAL_SC16IS7X0_XTAL1_CLK_1843200
+		bool "1.8432 MHZ"
+	config SERIAL_SC16IS7X0_XTAL1_CLK_14746500
+		bool "14.7465 MHZ (NXP demoboard)"
 endchoice
-
-config SPORT_BAUD_RATE
-	int
-	depends on SERIAL_BFIN_SPORT
-	default 115200 if (SERIAL_SPORT_BAUD_RATE_115200)
-	default 57600 if (SERIAL_SPORT_BAUD_RATE_57600)
-	default 38400 if (SERIAL_SPORT_BAUD_RATE_38400)
-	default 19200 if (SERIAL_SPORT_BAUD_RATE_19200)
-	default 9600 if (SERIAL_SPORT_BAUD_RATE_9600)
-
+config SERIAL_SC16IS7X0_CONSOLE
+	bool "Console on SC16IS7x0 port (ttyS1)"
+	depends on SERIAL_SC16IS7X0 && SERIAL_8250_CONSOLE
+	help
+		If you don't check this option, we will use standard 8250 as console.
+		Here, 8250 and sc16is7x0 occups ttyS0 and ttyS1 respectively.
+		Notice 1:
+			You need add "console=ttyS1" to CONFIG_CMDLINE, or console output will be incorrect.  
+		Notice 2: 
+			If you want to make user space's stdout to this port, 
+			device (major,minor) of /dev/console has to be ttyS1 (4,65) 
+			instead of ttyS0 (4,64). 
 endmenu
--- linux-2.6.30.9/drivers/serial/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/serial/Makefile	2013-05-02 01:47:55.686226899 +0300
@@ -1,79 +1,35 @@
 #
 # Makefile for the kernel serial device drivers.
 #
+ifeq ($(CONFIG_SERIAL_SC16IS7X0),y)
+	EXTRA_CFLAGS += -DCONFIG_RTK_VOIP_DRIVERS_PCM8972B_FAMILY
+endif
 
+ifeq ($(CONFIG_SND_RTL8197D_SOC_ALC5628),y)
+	EXTRA_CFLAGS += -DCONFIG_RTK_VOIP_DRIVERS_PCM89xxD
+endif
 obj-$(CONFIG_SERIAL_CORE) += serial_core.o
-obj-$(CONFIG_SERIAL_21285) += 21285.o
 
 # These Sparc drivers have to appear before others such as 8250
 # which share ttySx minor node space.  Otherwise console device
 # names change and other unplesantries.
-obj-$(CONFIG_SERIAL_SUNCORE) += suncore.o
-obj-$(CONFIG_SERIAL_SUNHV) += sunhv.o
-obj-$(CONFIG_SERIAL_SUNZILOG) += sunzilog.o
-obj-$(CONFIG_SERIAL_SUNSU) += sunsu.o
-obj-$(CONFIG_SERIAL_SUNSAB) += sunsab.o
 
 obj-$(CONFIG_SERIAL_8250) += 8250.o
 obj-$(CONFIG_SERIAL_8250_PNP) += 8250_pnp.o
 obj-$(CONFIG_SERIAL_8250_GSC) += 8250_gsc.o
 obj-$(CONFIG_SERIAL_8250_PCI) += 8250_pci.o
-obj-$(CONFIG_SERIAL_8250_HP300) += 8250_hp300.o
-obj-$(CONFIG_SERIAL_8250_CS) += serial_cs.o
-obj-$(CONFIG_SERIAL_8250_ACORN) += 8250_acorn.o
 obj-$(CONFIG_SERIAL_8250_CONSOLE) += 8250_early.o
-obj-$(CONFIG_SERIAL_8250_FOURPORT) += 8250_fourport.o
-obj-$(CONFIG_SERIAL_8250_ACCENT) += 8250_accent.o
-obj-$(CONFIG_SERIAL_8250_BOCA) += 8250_boca.o
-obj-$(CONFIG_SERIAL_8250_EXAR_ST16C554) += 8250_exar_st16c554.o
-obj-$(CONFIG_SERIAL_8250_HUB6) += 8250_hub6.o
-obj-$(CONFIG_SERIAL_8250_MCA) += 8250_mca.o
-obj-$(CONFIG_SERIAL_AMBA_PL010) += amba-pl010.o
-obj-$(CONFIG_SERIAL_AMBA_PL011) += amba-pl011.o
-obj-$(CONFIG_SERIAL_CLPS711X) += clps711x.o
-obj-$(CONFIG_SERIAL_PXA) += pxa.o
-obj-$(CONFIG_SERIAL_PNX8XXX) += pnx8xxx_uart.o
-obj-$(CONFIG_SERIAL_SA1100) += sa1100.o
-obj-$(CONFIG_SERIAL_BFIN) += bfin_5xx.o
-obj-$(CONFIG_SERIAL_BFIN_SPORT) += bfin_sport_uart.o
-obj-$(CONFIG_SERIAL_SAMSUNG) += samsung.o
-obj-$(CONFIG_SERIAL_S3C2400) += s3c2400.o
-obj-$(CONFIG_SERIAL_S3C2410) += s3c2410.o
-obj-$(CONFIG_SERIAL_S3C2412) += s3c2412.o
-obj-$(CONFIG_SERIAL_S3C2440) += s3c2440.o
-obj-$(CONFIG_SERIAL_S3C24A0) += s3c24a0.o
-obj-$(CONFIG_SERIAL_S3C6400) += s3c6400.o
-obj-$(CONFIG_SERIAL_MAX3100) += max3100.o
-obj-$(CONFIG_SERIAL_IP22_ZILOG) += ip22zilog.o
-obj-$(CONFIG_SERIAL_MUX) += mux.o
-obj-$(CONFIG_SERIAL_68328) += 68328serial.o
-obj-$(CONFIG_SERIAL_68360) += 68360serial.o
-obj-$(CONFIG_SERIAL_MCF) += mcf.o
-obj-$(CONFIG_SERIAL_PMACZILOG) += pmac_zilog.o
-obj-$(CONFIG_SERIAL_LH7A40X) += serial_lh7a40x.o
-obj-$(CONFIG_SERIAL_DZ) += dz.o
-obj-$(CONFIG_SERIAL_ZS) += zs.o
-obj-$(CONFIG_SERIAL_SH_SCI) += sh-sci.o
-obj-$(CONFIG_SERIAL_SGI_L1_CONSOLE) += sn_console.o
-obj-$(CONFIG_SERIAL_CPM) += cpm_uart/
-obj-$(CONFIG_SERIAL_IMX) += imx.o
-obj-$(CONFIG_SERIAL_MPC52xx) += mpc52xx_uart.o
-obj-$(CONFIG_SERIAL_ICOM) += icom.o
-obj-$(CONFIG_SERIAL_M32R_SIO) += m32r_sio.o
-obj-$(CONFIG_SERIAL_MPSC) += mpsc.o
-obj-$(CONFIG_SERIAL_SB1250_DUART) += sb1250-duart.o
-obj-$(CONFIG_ETRAX_SERIAL) += crisv10.o
-obj-$(CONFIG_SERIAL_SC26XX) += sc26xx.o
-obj-$(CONFIG_SERIAL_JSM) += jsm/
-obj-$(CONFIG_SERIAL_TXX9) += serial_txx9.o
-obj-$(CONFIG_SERIAL_VR41XX) += vr41xx_siu.o
-obj-$(CONFIG_SERIAL_SGI_IOC4) += ioc4_serial.o
-obj-$(CONFIG_SERIAL_SGI_IOC3) += ioc3_serial.o
-obj-$(CONFIG_SERIAL_ATMEL) += atmel_serial.o
-obj-$(CONFIG_SERIAL_UARTLITE) += uartlite.o
-obj-$(CONFIG_SERIAL_NETX) += netx-serial.o
 obj-$(CONFIG_SERIAL_OF_PLATFORM) += of_serial.o
 obj-$(CONFIG_SERIAL_OF_PLATFORM_NWPSERIAL) += nwpserial.o
-obj-$(CONFIG_SERIAL_KS8695) += serial_ks8695.o
 obj-$(CONFIG_KGDB_SERIAL_CONSOLE) += kgdboc.o
-obj-$(CONFIG_SERIAL_QE) += ucc_uart.o
+obj-$(CONFIG_SERIAL_SC16IS7X0) += 8250_sc16is7x0.o
+obj-$(CONFIG_SERIAL_SC16IS7X0) += i2c.o
+obj-$(CONFIG_SERIAL_SC16IS7X0) += gpio_8972b.o
+
+ifneq ($(CONFIG_SERIAL_SC16IS7X0),y)
+	obj-$(CONFIG_SND_RTL8197D_SOC_ALC5628) += i2c.o
+endif
+obj-$(CONFIG_SND_RTL819X_SOC) += gpio_8972d.o
+obj-$(CONFIG_SND_RTL8197D_SOC_ALC5628) += i2c_alc5628.o
+
+EXTRA_CFLAGS += -Iinclude/asm-mips/rtl865x/
--- linux-2.6.30.9/drivers/serial/serial_core.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/serial/serial_core.c	2013-05-02 01:47:55.689226899 +0300
@@ -417,7 +417,7 @@ uart_get_divisor(struct uart_port *port,
 	 * Old custom speed handling.
 	 */
 	if (baud == 38400 && (port->flags & UPF_SPD_MASK) == UPF_SPD_CUST)
-		quot = port->custom_divisor;
+		quot = 3; //port->custom_divisor;
 	else
 		quot = (port->uartclk + (8 * baud)) / (16 * baud);
 
@@ -2140,12 +2140,14 @@ uart_report_port(struct uart_driver *drv
 		break;
 	case UPIO_MEM:
 	case UPIO_MEM32:
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_DWAPB:
 		snprintf(address, sizeof(address),
 			 "MMIO 0x%llx", (unsigned long long)port->mapbase);
 		break;
+	case UPIO_I2C:
+		snprintf(address, sizeof(address),
+			 "I2C 0x%lx", port->iobase);
+		break;		
 	default:
 		strlcpy(address, "*unknown*", sizeof(address));
 		break;
@@ -2349,8 +2351,13 @@ int uart_register_driver(struct uart_dri
 	normal->type		= TTY_DRIVER_TYPE_SERIAL;
 	normal->subtype		= SERIAL_TYPE_NORMAL;
 	normal->init_termios	= tty_std_termios;
+#if defined(CONFIG_SERIAL_SC16IS7X0) || defined(CONFIG_SERIAL_RTL8198_UART1)
+	normal->init_termios.c_cflag = B38400 | CS8 | CREAD | HUPCL | CLOCAL;
+	normal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 38400;
+#else
 	normal->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
 	normal->init_termios.c_ispeed = normal->init_termios.c_ospeed = 9600;
+#endif
 	normal->flags		= TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
 	normal->driver_state    = drv;
 	tty_set_operations(normal, &uart_ops);
@@ -2554,10 +2561,10 @@ int uart_match_port(struct uart_port *po
 		       (port1->hub6   == port2->hub6);
 	case UPIO_MEM:
 	case UPIO_MEM32:
-	case UPIO_AU:
-	case UPIO_TSI:
 	case UPIO_DWAPB:
 		return (port1->mapbase == port2->mapbase);
+	case UPIO_I2C:
+		return (port1->iobase == port2->iobase);		
 	}
 	return 0;
 }
--- linux-2.6.30.9/drivers/staging/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/staging/Kconfig	2013-05-02 01:47:55.708226898 +0300
@@ -41,6 +41,8 @@ config STAGING_EXCLUDE_BUILD
 
 if !STAGING_EXCLUDE_BUILD
 
+source "drivers/staging/rtk_uWiFi/Kconfig"
+
 source "drivers/staging/et131x/Kconfig"
 
 source "drivers/staging/slicoss/Kconfig"
@@ -85,6 +87,8 @@ source "drivers/staging/altpciechdma/Kco
 
 source "drivers/staging/rtl8187se/Kconfig"
 
+source "drivers/staging/rtl8192su/Kconfig"
+
 source "drivers/staging/rspiusb/Kconfig"
 
 source "drivers/staging/mimio/Kconfig"
--- linux-2.6.30.9/drivers/staging/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/staging/Makefile	2013-05-02 01:47:55.708226898 +0300
@@ -2,7 +2,7 @@
 
 # fix for build system bug...
 obj-$(CONFIG_STAGING)		+= staging.o
-
+obj-$(CONFIG_USB_UWIFI_HOST)	+= rtk_uWiFi/
 obj-$(CONFIG_ET131X)		+= et131x/
 obj-$(CONFIG_SLICOSS)		+= slicoss/
 obj-$(CONFIG_SXG)		+= sxg/
@@ -25,6 +25,7 @@ obj-$(CONFIG_ASUS_OLED)		+= asus_oled/
 obj-$(CONFIG_PANEL)		+= panel/
 obj-$(CONFIG_ALTERA_PCIE_CHDMA)	+= altpciechdma/
 obj-$(CONFIG_RTL8187SE)		+= rtl8187se/
+obj-$(CONFIG_RTL8192SU)		+= rtl8192su/
 obj-$(CONFIG_USB_RSPI)		+= rspiusb/
 obj-$(CONFIG_INPUT_MIMIO)	+= mimio/
 obj-$(CONFIG_TRANZPORT)		+= frontier/
--- linux-2.6.30.9/drivers/usb/c67x00/c67x00-hcd.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/c67x00/c67x00-hcd.h	2013-05-02 01:47:56.720226816 +0300
@@ -28,7 +28,13 @@
 #include <linux/spinlock.h>
 #include <linux/list.h>
 #include <linux/usb.h>
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
+
 #include "c67x00.h"
 
 /*
--- linux-2.6.30.9/drivers/usb/core/devio.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/core/devio.c	2013-05-02 01:47:56.726226815 +0300
@@ -476,6 +476,9 @@ static int releaseintf(struct dev_state
 	else if (test_and_clear_bit(ifnum, &ps->ifclaimed)) {
 		usb_driver_release_interface(&usbfs_driver, intf);
 		err = 0;
+	#if defined(CONFIG_RTL_8198) || defined(CONFIG_RTL_819XD)
+		mdelay(100);
+	#endif
 	}
 	return err;
 }
--- linux-2.6.30.9/drivers/usb/core/hcd.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/core/hcd.c	2013-05-02 01:47:56.728226815 +0300
@@ -82,7 +82,7 @@
 /*-------------------------------------------------------------------------*/
 
 /* Keep track of which host controller drivers are loaded */
-unsigned long usb_hcds_loaded;
+unsigned long usb_hcds_loaded=0;
 EXPORT_SYMBOL_GPL(usb_hcds_loaded);
 
 /* host controllers we manage */
@@ -878,7 +878,7 @@ static void usb_deregister_bus (struct u
  * to register the usb device.  It also assigns the root hub's USB address
  * (always 1).
  */
-static int register_root_hub(struct usb_hcd *hcd)
+int register_root_hub(struct usb_hcd *hcd)
 {
 	struct device *parent_dev = hcd->self.controller;
 	struct usb_device *usb_dev = hcd->self.root_hub;
@@ -923,6 +923,8 @@ static int register_root_hub(struct usb_
 	return retval;
 }
 
+EXPORT_SYMBOL(register_root_hub);
+
 
 /*-------------------------------------------------------------------------*/
 
--- linux-2.6.30.9/drivers/usb/core/hub.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/core/hub.c	2013-05-02 01:47:56.731226815 +0300
@@ -30,6 +30,13 @@
 #include "hcd.h"
 #include "hub.h"
 
+//#include "rtl865xc_asicregs.h"
+
+#define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
+#define PABCD_DIR  0xb8003508
+#define PABCD_DAT 0xb800350C
+#define USB_LED_OFFSET 19
+
 /* if we are in debug mode, always announce new devices */
 #ifdef DEBUG
 #ifndef CONFIG_USB_ANNOUNCE_NEW_DEVICES
@@ -1432,8 +1439,12 @@ void usb_disconnect(struct usb_device **
 	 * this quiesces everyting except pending urbs.
 	 */
 	usb_set_device_state(udev, USB_STATE_NOTATTACHED);
+	//RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) | (1 << EN_USB_LED)));
+	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<USB_LED_OFFSET);
+	REG32(PABCD_DAT) = REG32(PABCD_DAT) | (0x1<<USB_LED_OFFSET);
 	dev_info (&udev->dev, "USB disconnect, address %d\n", udev->devnum);
 
+	
 	usb_lock_device(udev);
 
 	/* Free up all the children before we remove this device */
@@ -1775,14 +1786,21 @@ static unsigned hub_is_wusb(struct usb_h
 	return hcd->wireless;
 }
 
-
+#ifdef CONFIG_RTL_USB_OTG
 #define PORT_RESET_TRIES	5
+#else
+#define PORT_RESET_TRIES	20
+#endif
 #define SET_ADDRESS_TRIES	2
 #define GET_DESCRIPTOR_TRIES	2
 #define SET_CONFIG_TRIES	(2 * (use_both_schemes + 1))
 #define USE_NEW_SCHEME(i)	((i) / 2 == old_scheme_first)
 
+#ifdef CONFIG_RTL_USB_OTG
 #define HUB_ROOT_RESET_TIME	50	/* times are in msec */
+#else
+#define HUB_ROOT_RESET_TIME	500	/* times are in msec */
+#endif
 #define HUB_SHORT_RESET_TIME	10
 #define HUB_LONG_RESET_TIME	200
 #define HUB_RESET_TIMEOUT	500
@@ -1842,8 +1859,13 @@ static int hub_port_wait_reset(struct us
 static int hub_port_reset(struct usb_hub *hub, int port1,
 				struct usb_device *udev, unsigned int delay)
 {
+#ifdef CONFIG_RTL_OTGCTRL	 
+	//slove the usb phy debonce. close the auto-det interrupt
+	extern unsigned int TurnOn_OTGCtrl_Interrupt(unsigned int);  //wei add
+	int old=TurnOn_OTGCtrl_Interrupt(0);  //wei add
+#endif	
 	int i, status;
-
+	unsigned char retry=3;  //realtek patch, if failed, retry 3 times
 	/* Block EHCI CF initialization during the port reset.
 	 * Some companion controllers don't like it when they mix.
 	 */
@@ -1868,12 +1890,19 @@ static int hub_port_reset(struct usb_hub
 		/* return on disconnect or reset */
 		switch (status) {
 		case 0:
+			retry = 0; //realtek patch
 			/* TRSTRCY = 10 ms; plus some extra */
 			msleep(10 + 40);
 			update_address(udev, 0);
 			/* FALL THROUGH */
 		case -ENOTCONN:
 		case -ENODEV:
+//realtek patch
+			if(retry){
+				retry--;
+				continue;
+			}
+////
 			clear_port_feature(hub->hdev,
 				port1, USB_PORT_FEAT_C_RESET);
 			/* FIXME need disconnect() for NOTATTACHED device */
@@ -1895,6 +1924,10 @@ static int hub_port_reset(struct usb_hub
 
  done:
 	up_read(&ehci_cf_port_reset_rwsem);
+	
+#ifdef CONFIG_RTL_OTGCTRL	 
+	TurnOn_OTGCtrl_Interrupt(old);  //wei add
+#endif
 	return status;
 }
 
@@ -2152,15 +2185,31 @@ static int finish_port_resume(struct usb
  *
  * Returns 0 on success, else negative errno.
  */
+ #define RTL_R32(addr)		(*(volatile unsigned long *)(addr))
+#define RTL_W32(addr, l)	((*(volatile unsigned long*)(addr)) = (l))
+extern Enable_OTG_Suspend(int sel, int en) ;
 int usb_port_resume(struct usb_device *udev, pm_message_t msg)
 {
 	struct usb_hub	*hub = hdev_to_hub(udev->parent);
 	int		port1 = udev->portnum;
 	int		status;
 	u16		portchange, portstatus;
-
+	unsigned int tmp32=0; 
 	/* Skip the initial Clear-Suspend step for a remote wakeup */
 	status = hub_port_status(hub, port1, &portstatus, &portchange);
+#if defined(CONFIG_RTL_8196E) && defined(CONFIG_DWC_OTG)	
+	//Notify OTG Host to resume
+	msleep(10);
+	Enable_OTG_Suspend(0,0);
+	msleep(10);
+	tmp32 = 0x41100000;
+	RTL_W32(0xB8030440, tmp32);
+	msleep(10);
+	tmp32 = 0x01100000;
+	RTL_W32(0xB8030440, tmp32);
+	msleep(10);
+	/////////////////////////
+#endif	
 	if (status == 0 && !(portstatus & USB_PORT_STAT_SUSPEND))
 		goto SuspendCleared;
 
@@ -2451,6 +2500,13 @@ hub_port_init (struct usb_hub *hub, stru
 	/* root hub ports have a slightly longer reset period
 	 * (from USB 2.0 spec, section 7.1.7.5)
 	 */
+
+	//RTL_W32(AUTOCFG_LED_DATABASE, (RTL_R32(AUTOCFG_LED_DATABASE) & 0xffffbfff));
+
+	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<USB_LED_OFFSET);
+	REG32(PABCD_DAT) = REG32(PABCD_DAT) &(~ (0x1<<USB_LED_OFFSET));
+
+
 	if (!hdev->parent) {
 		delay = HUB_ROOT_RESET_TIME;
 		if (port1 == hdev->bus->otg_port)
--- linux-2.6.30.9/drivers/usb/core/urb.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/core/urb.c	2013-05-02 01:47:56.735226815 +0300
@@ -8,6 +8,12 @@
 #include <linux/wait.h>
 #include "hcd.h"
 
+#include "bspchip.h"
+
+#ifndef __IRAM_USB
+#define __IRAM_USB 
+#endif
+
 #define to_urb(d) container_of(d, struct urb, kref)
 
 
@@ -87,6 +93,7 @@ EXPORT_SYMBOL_GPL(usb_alloc_urb);
  * Note: The transfer buffer associated with the urb is not freed unless the
  * URB_FREE_BUFFER transfer flag is set.
  */
+__IRAM_USB 
 void usb_free_urb(struct urb *urb)
 {
 	if (urb)
@@ -104,6 +111,7 @@ EXPORT_SYMBOL_GPL(usb_free_urb);
  *
  * A pointer to the urb with the incremented reference counter is returned.
  */
+__IRAM_USB
 struct urb *usb_get_urb(struct urb *urb)
 {
 	if (urb)
@@ -285,6 +293,7 @@ EXPORT_SYMBOL_GPL(usb_unanchor_urb);
  *      GFP_NOIO, unless b) or c) apply
  *
  */
+__IRAM_USB
 int usb_submit_urb(struct urb *urb, gfp_t mem_flags)
 {
 	int				xfertype, max;
--- linux-2.6.30.9/drivers/usb/core/usb.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/core/usb.c	2013-05-02 01:47:56.736226814 +0300
@@ -43,6 +43,10 @@
 #include "hcd.h"
 #include "usb.h"
 
+#define REG32(reg)   (*(volatile unsigned int *)((unsigned int)reg))
+#define PIN_MUX_SEL_2 0xb8000044
+#define PABCD_DIR  0xb8003508
+#define PABCD_DAT 0xb800350C
 
 const char *usbcore_name = "usbcore";
 
@@ -1001,6 +1005,16 @@ static struct notifier_block usb_bus_nb
 	.notifier_call = usb_bus_notify,
 };
 
+
+static void usb_led_init(void)
+{
+	REG32(PIN_MUX_SEL_2) = REG32(PIN_MUX_SEL_2) |(0x7<<21);
+	REG32(PABCD_DIR) = REG32(PABCD_DIR) |(0x1<<19);
+	REG32(PABCD_DAT) = REG32(PABCD_DAT) |(0x1<<19);
+}
+
+
+
 /*
  * Init
  */
@@ -1011,7 +1025,7 @@ static int __init usb_init(void)
 		pr_info("%s: USB support disabled\n", usbcore_name);
 		return 0;
 	}
-
+	usb_led_init();
 	retval = ksuspend_usb_init();
 	if (retval)
 		goto out;
--- linux-2.6.30.9/drivers/usb/gadget/dummy_hcd.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/gadget/dummy_hcd.c	2013-05-02 01:47:56.782226811 +0300
@@ -55,7 +55,11 @@
 #include <asm/unaligned.h>
 
 
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 
 #define DRIVER_DESC	"USB Host+Gadget Emulator"
--- linux-2.6.30.9/drivers/usb/host/ehci.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci.h	2013-05-02 01:47:56.828226807 +0300
@@ -36,6 +36,11 @@ typedef __u16 __bitwise __hc16;
 #define __hc32	__le32
 #define __hc16	__le16
 #endif
+#include "bspchip.h"
+
+#ifndef __IRAM_USB
+#define __IRAM_USB 
+#endif
 
 /* statistics can be kept for for tuning/monitoring */
 struct ehci_stats {
@@ -602,6 +607,9 @@ ehci_port_speed(struct ehci_hcd *ehci, u
 static inline unsigned int ehci_readl(const struct ehci_hcd *ehci,
 		__u32 __iomem * regs)
 {
+#if defined(CONFIG_RTL_819X)
+        return (le32_to_cpu((*(volatile unsigned long *)(regs))));
+#else
 #ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
 	return ehci_big_endian_mmio(ehci) ?
 		readl_be(regs) :
@@ -609,11 +617,15 @@ static inline unsigned int ehci_readl(co
 #else
 	return readl(regs);
 #endif
+#endif
 }
 
 static inline void ehci_writel(const struct ehci_hcd *ehci,
 		const unsigned int val, __u32 __iomem *regs)
 {
+#if defined(CONFIG_RTL_819X)
+        ((*(volatile unsigned long *)(regs))=cpu_to_le32(val));
+#else
 #ifdef CONFIG_USB_EHCI_BIG_ENDIAN_MMIO
 	ehci_big_endian_mmio(ehci) ?
 		writel_be(val, regs) :
@@ -621,6 +633,7 @@ static inline void ehci_writel(const str
 #else
 	writel(val, regs);
 #endif
+#endif
 }
 
 /*
--- linux-2.6.30.9/drivers/usb/host/ehci-hcd.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-hcd.c	2013-05-02 01:47:56.825226807 +0300
@@ -169,10 +169,10 @@ static int handshake (struct ehci_hcd *e
 	u32	result;
 
 	do {
-		result = ehci_readl(ehci, ptr);
+		result = (ehci_readl(ehci, ptr))&0xffff;
 		if (result == ~(u32)0)		/* card removed */
 			return -ENODEV;
-		result &= mask;
+		result &= (mask)&0xffff;
 		if (result == done)
 			return 0;
 		udelay (1);
@@ -429,6 +429,7 @@ static void ehci_port_power (struct ehci
  * ehci_work is called from some interrupts, timers, and so on.
  * it calls driver completion functions, after dropping ehci->lock.
  */
+__IRAM_USB
 static void ehci_work (struct ehci_hcd *ehci)
 {
 	timer_action_done (ehci, TIMER_IO_WATCHDOG);
@@ -677,7 +678,7 @@ static int ehci_run (struct usb_hcd *hcd
 }
 
 /*-------------------------------------------------------------------------*/
-
+__IRAM_USB
 static irqreturn_t ehci_irq (struct usb_hcd *hcd)
 {
 	struct ehci_hcd		*ehci = hcd_to_ehci (hcd);
@@ -786,7 +787,19 @@ dead:
 	}
 
 	if (bh)
+	{
+		#if 1
+		 __asm__ __volatile__(  \
+                ".set   push\n\t"       \
+                ".set   noreorder\n\t"  \
+                "nop\n\t"               \
+		"nop\n\t"               \
+		"nop\n\t"               \
+		".set   pop\n\t");
+		#endif
+
 		ehci_work (ehci);
+	}
 	spin_unlock (&ehci->lock);
 	if (pcd_status)
 		usb_hcd_poll_rh_status(hcd);
@@ -807,6 +820,7 @@ dead:
  * NOTE:  control, bulk, and interrupt share the same code to append TDs
  * to a (possibly active) QH, and the same QH scanning code.
  */
+__IRAM_USB
 static int ehci_urb_enqueue (
 	struct usb_hcd	*hcd,
 	struct urb	*urb,
@@ -1040,48 +1054,35 @@ MODULE_DESCRIPTION(DRIVER_DESC);
 MODULE_AUTHOR (DRIVER_AUTHOR);
 MODULE_LICENSE ("GPL");
 
-#ifdef CONFIG_PCI
+#ifdef CONFIG_USB_VIA_PCI
 #include "ehci-pci.c"
 #define	PCI_DRIVER		ehci_pci_driver
 #endif
 
-#ifdef CONFIG_USB_EHCI_FSL
-#include "ehci-fsl.c"
-#define	PLATFORM_DRIVER		ehci_fsl_driver
-#endif
-
-#ifdef CONFIG_SOC_AU1200
-#include "ehci-au1xxx.c"
-#define	PLATFORM_DRIVER		ehci_hcd_au1xxx_driver
-#endif
-
-#ifdef CONFIG_PPC_PS3
-#include "ehci-ps3.c"
-#define	PS3_SYSTEM_BUS_DRIVER	ps3_ehci_driver
-#endif
-
-#ifdef CONFIG_USB_EHCI_HCD_PPC_OF
-#include "ehci-ppc-of.c"
-#define OF_PLATFORM_DRIVER	ehci_hcd_ppc_of_driver
-#endif
-
-#ifdef CONFIG_PLAT_ORION
-#include "ehci-orion.c"
-#define	PLATFORM_DRIVER		ehci_orion_driver
+#if defined(CONFIG_RTL_819X)
+#include "ehci-rtl8652.c"
+#define PLATFORM_DRIVER		ehci_rtl8652_driver
 #endif
 
-#ifdef CONFIG_ARCH_IXP4XX
-#include "ehci-ixp4xx.c"
-#define	PLATFORM_DRIVER		ixp4xx_ehci_driver
+#ifdef CONFIG_USB_EHCI_DWC 
+#include "ehci-dwc.c"
+#define	PLATFORM_DRIVER  ehci_dwc_driver
 #endif
 
-#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER) && \
-    !defined(PS3_SYSTEM_BUS_DRIVER) && !defined(OF_PLATFORM_DRIVER)
+#if !defined(PCI_DRIVER) && !defined(PLATFORM_DRIVER)
 #error "missing bus glue for ehci-hcd"
 #endif
 
+#if defined(CONFIG_RTL_ULINKER)
+int ehci_hcd_init(void)
+#else
 static int __init ehci_hcd_init(void)
+#endif
 {
+	if (test_bit(USB_EHCI_LOADED, &usb_hcds_loaded))
+	{	printk("EHCI-HCD: already init \n");
+		return -1;
+	}
 	int retval = 0;
 
 	if (usb_disabled())
@@ -1099,6 +1100,13 @@ static int __init ehci_hcd_init(void)
 		 sizeof(struct ehci_qh), sizeof(struct ehci_qtd),
 		 sizeof(struct ehci_itd), sizeof(struct ehci_sitd));
 
+#if defined(CONFIG_RTL_819X)
+	if(ehci_rtl8652_init() !=0)
+	{ retval = -1;   //wei add
+	   goto err_out;   //wei add
+	}
+#endif
+
 #ifdef DEBUG
 	ehci_debug_root = debugfs_create_dir("ehci", NULL);
 	if (!ehci_debug_root) {
@@ -1119,27 +1127,8 @@ static int __init ehci_hcd_init(void)
 		goto clean1;
 #endif
 
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	retval = ps3_ehci_driver_register(&PS3_SYSTEM_BUS_DRIVER);
-	if (retval < 0)
-		goto clean2;
-#endif
-
-#ifdef OF_PLATFORM_DRIVER
-	retval = of_register_platform_driver(&OF_PLATFORM_DRIVER);
-	if (retval < 0)
-		goto clean3;
-#endif
 	return retval;
 
-#ifdef OF_PLATFORM_DRIVER
-	/* of_unregister_platform_driver(&OF_PLATFORM_DRIVER); */
-clean3:
-#endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
-clean2:
-#endif
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 clean1:
@@ -1153,25 +1142,36 @@ clean0:
 	ehci_debug_root = NULL;
 err_debug:
 #endif
+err_out:
+
+#if defined(CONFIG_RTL_819X)  
+	ehci_rtl8652_cleanup();   //wei add
+#endif
+
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ehci_hcd_init);
-
+//-----------------------------------------------------------
+#if defined(CONFIG_RTL_ULINKER)
+void  ehci_hcd_cleanup(void)  //wei add
+#else
 static void __exit ehci_hcd_cleanup(void)
-{
-#ifdef OF_PLATFORM_DRIVER
-	of_unregister_platform_driver(&OF_PLATFORM_DRIVER);
-#endif
-#ifdef PLATFORM_DRIVER
-	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
+{
+	if (!test_bit(USB_EHCI_LOADED, &usb_hcds_loaded))
+	{	printk("EHCI-HCD: not init, cannot cleanup \n");
+		return;
+	}
+
 #ifdef PCI_DRIVER
 	pci_unregister_driver(&PCI_DRIVER);
 #endif
-#ifdef PS3_SYSTEM_BUS_DRIVER
-	ps3_ehci_driver_unregister(&PS3_SYSTEM_BUS_DRIVER);
+
+#ifdef PLATFORM_DRIVER
+	platform_driver_unregister(&PLATFORM_DRIVER);
 #endif
+
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 #endif
@@ -1175,6 +1175,10 @@ static void __exit ehci_hcd_cleanup(void
 #ifdef DEBUG
 	debugfs_remove(ehci_debug_root);
 #endif
+
+#if defined(CONFIG_RTL_819X)  
+	ehci_rtl8652_cleanup();   //wei add
+#endif
 	clear_bit(USB_EHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ehci_hcd_cleanup);
--- linux-2.6.30.9/drivers/usb/host/ehci-hub.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-hub.c	2013-05-02 01:47:56.825226807 +0300
@@ -412,6 +412,16 @@ static int check_reset_complete (
 	u32 __iomem	*status_reg,
 	int		port_status
 ) {
+//realtek patch
+#if 1 /* patch for synopsis USB 2.0 */
+	int i;
+	#ifdef CONFIG_DWC_OTG
+	static unsigned char retry=1; //if failed, retry 1 times
+	#else
+	static unsigned char retry=3; //if failed, retry 3 times
+	#endif
+#endif
+////
 	if (!(port_status & PORT_CONNECT))
 		return port_status;
 
@@ -425,7 +435,12 @@ static int check_reset_complete (
 				index+1);
 			return port_status;
 		}
-
+		//realtek patch
+		if(--retry) {
+			return port_status;
+		}
+		retry = 3;	
+		/////	
 		ehci_dbg (ehci, "port %d full speed --> companion\n",
 			index + 1);
 
@@ -438,6 +453,9 @@ static int check_reset_complete (
 		if (ehci->has_amcc_usb23)
 			set_ohci_hcfs(ehci, 1);
 	} else {
+            //realtek patch
+		retry = 3;  //realtek patch
+            ////
 		ehci_dbg (ehci, "port %d high speed\n", index + 1);
 		/* ensure 440EPx ohci controller state is suspended */
 		if (ehci->has_amcc_usb23)
--- linux-2.6.30.9/drivers/usb/host/ehci-q.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-q.c	2013-05-02 01:47:56.827226807 +0300
@@ -41,7 +41,7 @@
 /*-------------------------------------------------------------------------*/
 
 /* fill a qtd, returning how much of the buffer we were able to queue up */
-
+__IRAM_USB
 static int
 qtd_fill(struct ehci_hcd *ehci, struct ehci_qtd *qtd, dma_addr_t buf,
 		  size_t len, int token, int maxpacket)
@@ -83,7 +83,7 @@ qtd_fill(struct ehci_hcd *ehci, struct e
 }
 
 /*-------------------------------------------------------------------------*/
-
+__IRAM_USB
 static inline void
 qh_update (struct ehci_hcd *ehci, struct ehci_qh *qh, struct ehci_qtd *qtd)
 {
@@ -118,6 +118,7 @@ qh_update (struct ehci_hcd *ehci, struct
  * overlay, so qh->hw_token wrongly becomes inactive/halted), only fault
  * recovery (including urb dequeue) would need software changes to a QH...
  */
+__IRAM_USB
 static void
 qh_refresh (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
@@ -138,7 +139,7 @@ qh_refresh (struct ehci_hcd *ehci, struc
 }
 
 /*-------------------------------------------------------------------------*/
-
+__IRAM_USB
 static void qh_link_async(struct ehci_hcd *ehci, struct ehci_qh *qh);
 
 static void ehci_clear_tt_buffer_complete(struct usb_hcd *hcd,
@@ -187,7 +188,7 @@ static void ehci_clear_tt_buffer(struct
 		}
 	}
 }
-
+__IRAM_USB
 static int qtd_copy_status (
 	struct ehci_hcd *ehci,
 	struct urb *urb,
@@ -248,7 +249,7 @@ static int qtd_copy_status (
 
 	return status;
 }
-
+__IRAM_USB
 static void
 ehci_urb_done(struct ehci_hcd *ehci, struct urb *urb, int status)
 __releases(ehci->lock)
@@ -570,6 +571,7 @@ static void qtd_list_free (
 /*
  * create a list of filled qtds for this URB; won't link into qh.
  */
+__IRAM_USB
 static struct list_head *
 qh_urb_transaction (
 	struct ehci_hcd		*ehci,
@@ -952,6 +954,7 @@ static void qh_link_async (struct ehci_h
  * Returns null if it can't allocate a QH it needs to.
  * If the QH has TDs (urbs) already, that's great.
  */
+__IRAM_USB
 static struct ehci_qh *qh_append_tds (
 	struct ehci_hcd		*ehci,
 	struct urb		*urb,
@@ -1033,6 +1036,7 @@ static struct ehci_qh *qh_append_tds (
 
 /*-------------------------------------------------------------------------*/
 
+__IRAM_USB
 static int
 submit_async (
 	struct ehci_hcd		*ehci,
@@ -1091,6 +1095,7 @@ submit_async (
 
 /* the async qh for the qtds being reclaimed are now unlinked from the HC */
 
+__IRAM_USB
 static void end_unlink_async (struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh = ehci->reclaim;
@@ -1132,6 +1137,7 @@ static void end_unlink_async (struct ehc
 /* makes sure the async qh will become idle */
 /* caller must own ehci->lock */
 
+__IRAM_USB
 static void start_unlink_async (struct ehci_hcd *ehci, struct ehci_qh *qh)
 {
 	int		cmd = ehci_readl(ehci, &ehci->regs->command);
@@ -1189,6 +1195,7 @@ static void start_unlink_async (struct e
 
 /*-------------------------------------------------------------------------*/
 
+__IRAM_USB
 static void scan_async (struct ehci_hcd *ehci)
 {
 	struct ehci_qh		*qh;
--- linux-2.6.30.9/drivers/usb/host/ehci-sched.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ehci-sched.c	2013-05-02 01:47:56.828226807 +0300
@@ -33,7 +33,7 @@
  * It keeps track of every ITD (or SITD) that's linked, and holds enough
  * pre-calculated schedule data to make appending to the queue be quick.
  */
-
+// #define CONFIG_USB_3G_SUPPORT //for specifical dongle
 static int ehci_get_frame (struct usb_hcd *hcd);
 
 /*-------------------------------------------------------------------------*/
@@ -323,7 +323,11 @@ static int tt_available (
 		 * already scheduled transactions
 		 */
 		if (125 < usecs) {
+#ifdef CONFIG_USB_3G_SUPPORT
+		nt ufs = (usecs / 125) - 1;
+#else
 			int ufs = (usecs / 125);
+#endif
 			int i;
 			for (i = uframe; i < (uframe + ufs) && i < 8; i++)
 				if (0 < tt_usecs[i]) {
@@ -436,15 +440,23 @@ static int enable_periodic (struct ehci_
 {
 	u32	cmd;
 	int	status;
-
+#ifndef CONFIG_USB_3G_SUPPORT
 	if (ehci->periodic_sched++)
 		return 0;
+#else
+        udelay(1024);
+#endif
 
 	/* did clearing PSE did take effect yet?
 	 * takes effect only at frame boundaries...
 	 */
 	status = handshake_on_error_set_halt(ehci, &ehci->regs->status,
-					     STS_PSS, 0, 9 * 125);
+					     STS_PSS, 0, 
+						#ifdef CONFIG_USB_3G_SUPPORT
+						120000 * 125);
+						#else
+						9 * 125);
+						#endif
 	if (status)
 		return status;
 
@@ -471,7 +483,12 @@ static int disable_periodic (struct ehci
 	 * takes effect only at frame boundaries...
 	 */
 	status = handshake_on_error_set_halt(ehci, &ehci->regs->status,
-					     STS_PSS, STS_PSS, 9 * 125);
+					     STS_PSS, STS_PSS, 
+#ifdef CONFIG_USB_3G_SUPPORT
+						120000 * 125);
+#else
+						9 * 125);
+#endif
 	if (status)
 		return status;
 
@@ -550,7 +567,14 @@ static int qh_link_periodic (struct ehci
 		: (qh->usecs * 8);
 
 	/* maybe enable periodic schedule processing */
+#ifdef CONFIG_USB_3G_SUPPORT
+        if (!ehci->periodic_sched++)
 	return enable_periodic(ehci);
+	return 0;
+
+#else
+	return enable_periodic(ehci);
+#endif
 }
 
 static int qh_unlink_periodic(struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -589,7 +613,14 @@ static int qh_unlink_periodic(struct ehc
 	qh_put (qh);
 
 	/* maybe turn off periodic schedule */
+        #ifdef CONFIG_USB_3G_SUPPORT
+        ehci->periodic_sched--;
+	if (!ehci->periodic_sched)
+		(void) disable_periodic (ehci);
+
+        #else
 	return disable_periodic(ehci);
+        #endif
 }
 
 static void intr_deschedule (struct ehci_hcd *ehci, struct ehci_qh *qh)
@@ -606,9 +637,18 @@ static void intr_deschedule (struct ehci
 	if (list_empty (&qh->qtd_list)
 			|| (cpu_to_hc32(ehci, QH_CMASK)
 					& qh->hw_info2) != 0)
+#ifdef CONFIG_USB_3G_SUPPORT
+		wait =  55;
+#else
 		wait = 2;
+#endif
 	else
+#ifdef CONFIG_RTL_USB_OTG
 		wait = 55;	/* worst case: 3 * 1024 */
+#else
+		//wait = 55;	/* worst case: 3 * 1024 */
+		wait = 3 * 1024;
+#endif
 
 	udelay (wait);
 	qh->qh_state = QH_STATE_IDLE;
@@ -1564,7 +1604,13 @@ itd_link_urb (
 	urb->hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+#ifdef CONFIG_USB_3G_SUPPORT
+        if (unlikely (!ehci->periodic_sched++))
+	return enable_periodic(ehci);
+	return 0;
+#else
 	return enable_periodic(ehci);
+#endif
 }
 
 #define	ISO_ERRS (EHCI_ISOC_BUF_ERR | EHCI_ISOC_BABBLE | EHCI_ISOC_XACTERR)
@@ -1645,7 +1691,14 @@ itd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+#ifdef CONFIG_USB_3G_SUPPORT
+        /* defer stopping schedule; completion can submit */
+	ehci->periodic_sched--;
+	if (unlikely (!ehci->periodic_sched))
+
+#else
 	(void) disable_periodic(ehci);
+#endif
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
 	if (unlikely(list_is_singular(&stream->td_list))) {
@@ -1967,7 +2020,13 @@ sitd_link_urb (
 	urb->hcpriv = NULL;
 
 	timer_action (ehci, TIMER_IO_WATCHDOG);
+#ifdef CONFIG_USB_3G_SUPPORT
+        if (!ehci->periodic_sched++)
 	return enable_periodic(ehci);
+	return 0;
+#else
+	return enable_periodic(ehci);
+#endif
 }
 
 /*-------------------------------------------------------------------------*/
@@ -2034,6 +2093,11 @@ sitd_complete (
 	ehci_urb_done(ehci, urb, 0);
 	retval = true;
 	urb = NULL;
+#ifdef CONFIG_USB_3G_SUPPORT
+        /* defer stopping schedule; completion can submit */
+	ehci->periodic_sched--;
+	if (!ehci->periodic_sched)
+#endif
 	(void) disable_periodic(ehci);
 	ehci_to_hcd(ehci)->self.bandwidth_isoc_reqs--;
 
--- linux-2.6.30.9/drivers/usb/host/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/Kconfig	2013-05-02 01:47:56.823226807 +0300
@@ -78,6 +78,12 @@ config USB_EHCI_BIG_ENDIAN_DESC
 	depends on USB_EHCI_HCD && (440EPX || ARCH_IXP4XX)
 	default y
 
+#config USB_EHCI_DWC
+#	bool "Support for Synopsys DWC EHCI USB controller"
+#	depends on USB_EHCI_HCD
+#	select USB_EHCI_ROOT_HUB_TT
+#    default y
+
 config USB_EHCI_FSL
 	bool "Support for Freescale on-chip EHCI USB controller"
 	depends on USB_EHCI_HCD && FSL_SOC
@@ -88,7 +94,6 @@ config USB_EHCI_FSL
 config USB_EHCI_HCD_PPC_OF
 	bool "EHCI support for PPC USB controller on OF platform bus"
 	depends on USB_EHCI_HCD && PPC_OF
-	default y
 	---help---
 	  Enables support for the USB controller present on the PowerPC
 	  OpenFirmware platform bus.
--- linux-2.6.30.9/drivers/usb/host/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/Makefile	2013-05-02 01:47:56.823226807 +0300
@@ -6,6 +6,9 @@ ifeq ($(CONFIG_USB_DEBUG),y)
 	EXTRA_CFLAGS		+= -DDEBUG
 endif
 
+ifeq ($(CONFIG_RTL_819X),y)
+	EXTRA_CFLAGS		+= -I$(DIR_BOARD)
+endif
 isp1760-objs := isp1760-hcd.o isp1760-if.o
 fhci-objs := fhci-hcd.o fhci-hub.o fhci-q.o fhci-mem.o \
 	     fhci-tds.o fhci-sched.o
--- linux-2.6.30.9/drivers/usb/host/ohci.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ohci.h	2013-05-02 01:47:56.839226806 +0300
@@ -544,6 +544,9 @@ static inline struct usb_hcd *ohci_to_hc
 static inline unsigned int _ohci_readl (const struct ohci_hcd *ohci,
 					__hc32 __iomem * regs)
 {
+#if defined(CONFIG_RTL_819X)
+        return (le32_to_cpu((*(volatile unsigned long *)(regs))));
+#else
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	return big_endian_mmio(ohci) ?
 		readl_be (regs) :
@@ -551,11 +554,15 @@ static inline unsigned int _ohci_readl (
 #else
 	return readl (regs);
 #endif
+#endif
 }
 
 static inline void _ohci_writel (const struct ohci_hcd *ohci,
 				 const unsigned int val, __hc32 __iomem *regs)
 {
+#if defined(CONFIG_RTL_819X)
+        ((*(volatile unsigned long *)(regs))=cpu_to_le32(val));
+#else
 #ifdef CONFIG_USB_OHCI_BIG_ENDIAN_MMIO
 	big_endian_mmio(ohci) ?
 		writel_be (val, regs) :
@@ -563,6 +570,7 @@ static inline void _ohci_writel (const s
 #else
 		writel (val, regs);
 #endif
+#endif
 }
 
 #ifdef CONFIG_ARCH_LH7A404
--- linux-2.6.30.9/drivers/usb/host/ohci-hcd.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/host/ohci-hcd.c	2013-05-02 01:47:56.835226806 +0300
@@ -1047,6 +1047,11 @@ MODULE_LICENSE ("GPL");
 #define PLATFORM_DRIVER		usb_hcd_pnx4008_driver
 #endif
 
+#if defined(CONFIG_RTL_819X)
+#include "ohci-rtl8652.c"
+#define PLATFORM_DRIVER		ohci_hcd_rtl8652_driver
+#endif
+
 #if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
     defined(CONFIG_CPU_SUBTYPE_SH7721) || \
     defined(CONFIG_CPU_SUBTYPE_SH7763) || \
@@ -1092,8 +1097,17 @@ MODULE_LICENSE ("GPL");
 #error "missing bus glue for ohci-hcd"
 #endif
 
+#if defined(CONFIG_RTL_ULINKER)
+int  ohci_hcd_mod_init(void)  //wei add
+#else
 static int __init ohci_hcd_mod_init(void)
+#endif
 {
+	if ( test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+	{	printk("OHCI-HCD: already init \n");
+		return -1;
+	}
+	
 	int retval = 0;
 
 	if (usb_disabled())
@@ -1104,6 +1118,13 @@ static int __init ohci_hcd_mod_init(void
 		sizeof (struct ed), sizeof (struct td));
 	set_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 
+#if defined(CONFIG_RTL_819X)
+	if(ohci_rtl8652_init() !=0)
+	{ retval = -1;   //wei add
+	   goto err_out;   //wei add
+	}
+#endif
+
 #ifdef DEBUG
 	ohci_debug_root = debugfs_create_dir("ohci", NULL);
 	if (!ohci_debug_root) {
@@ -1200,14 +1221,26 @@ static int __init ohci_hcd_mod_init(void
 	ohci_debug_root = NULL;
  error_debug:
 #endif
-
+err_out:
+#if defined(CONFIG_RTL_819X)  
+	ohci_rtl8652_cleanup();   //wei add
+#endif
 	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 	return retval;
 }
 module_init(ohci_hcd_mod_init);
-
+//-----------------------------------------------------------
+#if defined(CONFIG_RTL_ULINKER)
+void  ohci_hcd_mod_exit(void)  //wei add
+#else
 static void __exit ohci_hcd_mod_exit(void)
+#endif
 {
+	if (!test_bit(USB_OHCI_LOADED, &usb_hcds_loaded))
+	{	printk("OHCI-HCD: not init, cannot cleanup \n");
+		return;
+	}
+
 #ifdef TMIO_OHCI_DRIVER
 	platform_driver_unregister(&TMIO_OHCI_DRIVER);
 #endif
@@ -1235,6 +1268,10 @@ static void __exit ohci_hcd_mod_exit(voi
 #ifdef DEBUG
 	debugfs_remove(ohci_debug_root);
 #endif
+
+#if defined(CONFIG_RTL_819X)  //wei add
+        ohci_rtl8652_cleanup();
+#endif
 	clear_bit(USB_OHCI_LOADED, &usb_hcds_loaded);
 }
 module_exit(ohci_hcd_mod_exit);
--- linux-2.6.30.9/drivers/usb/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/Kconfig	2013-05-09 15:45:47.582603984 +0300
@@ -19,45 +19,18 @@ config USB_ARCH_HAS_HCD
 	boolean
 	default y if USB_ARCH_HAS_OHCI
 	default y if USB_ARCH_HAS_EHCI
-	default y if PCMCIA && !M32R			# sl811_cs
-	default y if ARM				# SL-811
-	default y if SUPERH				# r8a66597-hcd
-	default PCI
+	default y if RTL_819X
+	default y if SOC_HAS_USB
 
 # many non-PCI SOC chips embed OHCI
 config USB_ARCH_HAS_OHCI
 	boolean
-	# ARM:
-	default y if SA1111
-	default y if ARCH_OMAP
-	default y if ARCH_LH7A404
-	default y if ARCH_S3C2410
-	default y if PXA27x
-	default y if PXA3xx
-	default y if ARCH_EP93XX
-	default y if ARCH_AT91
-	default y if ARCH_PNX4008 && I2C
-	default y if MFD_TC6393XB
-	# PPC:
-	default y if STB03xxx
-	default y if PPC_MPC52xx
-	# MIPS:
-	default y if SOC_AU1X00
-	# SH:
-	default y if CPU_SUBTYPE_SH7720
-	default y if CPU_SUBTYPE_SH7721
-	default y if CPU_SUBTYPE_SH7763
-	default y if CPU_SUBTYPE_SH7786
-	# more:
-	default PCI
+	default y if RTL_819X
 
 # some non-PCI hcds implement EHCI
 config USB_ARCH_HAS_EHCI
 	boolean
-	default y if PPC_83xx
-	default y if SOC_AU1200
-	default y if ARCH_IXP4XX
-	default PCI
+	default y if RTL_819X
 
 # ARM SA1111 chips have a non-PCI based "OHCI-compatible" USB host interface.
 config USB
@@ -149,8 +122,11 @@ source "drivers/usb/misc/Kconfig"
 
 source "drivers/usb/atm/Kconfig"
 
-source "drivers/usb/gadget/Kconfig"
+source "drivers/usb/gadget_cathy/Kconfig"
+#source "drivers/usb/gadget/Kconfig"
 
 source "drivers/usb/otg/Kconfig"
 
+source "drivers/usb/dwc_otg/Kconfig"
+
 endif # USB_SUPPORT
--- linux-2.6.30.9/drivers/usb/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/Makefile	2013-05-02 01:47:56.716226816 +0300
@@ -4,10 +4,27 @@
 
 # Object files in subdirectories
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+obj-$(CONFIG_USB)		+= core_uWiFi/
+else
 obj-$(CONFIG_USB)		+= core/
+endif
 
 obj-$(CONFIG_USB_MON)		+= mon/
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+obj-$(CONFIG_PCI)		+= host_uWiFi/
+obj-$(CONFIG_USB_EHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_ISP116X_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_OHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_UHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_FHCI_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_SL811_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_U132_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_R8A66597_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_HWA_HCD)	+= host_uWiFi/
+obj-$(CONFIG_USB_ISP1760_HCD)	+= host_uWiFi/
+else
 obj-$(CONFIG_PCI)		+= host/
 obj-$(CONFIG_USB_EHCI_HCD)	+= host/
 obj-$(CONFIG_USB_ISP116X_HCD)	+= host/
@@ -19,6 +36,7 @@ obj-$(CONFIG_USB_U132_HCD)	+= host/
 obj-$(CONFIG_USB_R8A66597_HCD)	+= host/
 obj-$(CONFIG_USB_HWA_HCD)	+= host/
 obj-$(CONFIG_USB_ISP1760_HCD)	+= host/
+endif
 
 obj-$(CONFIG_USB_C67X00_HCD)	+= c67x00/
 
@@ -29,9 +47,13 @@ obj-$(CONFIG_USB_PRINTER)	+= class/
 obj-$(CONFIG_USB_WDM)		+= class/
 obj-$(CONFIG_USB_TMC)		+= class/
 
+ifeq ($(CONFIG_USB_UWIFI_HOST),y)
+obj-$(CONFIG_USB_STORAGE)	+= storage_uWiFi/
+obj-$(CONFIG_USB)		+= storage_uWiFi/
+else
 obj-$(CONFIG_USB_STORAGE)	+= storage/
 obj-$(CONFIG_USB)		+= storage/
-
+endif
 obj-$(CONFIG_USB_MDC800)	+= image/
 obj-$(CONFIG_USB_MICROTEK)	+= image/
 
@@ -41,3 +63,12 @@ obj-$(CONFIG_USB)		+= misc/
 
 obj-$(CONFIG_USB_ATM)		+= atm/
 obj-$(CONFIG_USB_SPEEDTOUCH)	+= atm/
+
+obj-$(CONFIG_DWC_OTG)       += dwc_otg/
+
+#wei add for otg device mode
+ifeq ($(CONFIG_RTL_USB_OTG),y)
+obj-$(CONFIG_USB_GADGET)	+= gadget_cathy/
+else
+obj-$(CONFIG_USB_GADGET)	+= gadget/
+endif
--- linux-2.6.30.9/drivers/usb/misc/ftdi-elan.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/misc/ftdi-elan.c	2013-05-02 01:47:56.875226803 +0300
@@ -73,7 +73,12 @@ static struct list_head ftdi_static_list
 */
 #include "usb_u132.h"
 #include <asm/io.h>
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 	/* FIXME ohci.h is ONLY for internal use by the OHCI driver.
 	 * If you're going to try stuff like this, you need to split
--- linux-2.6.30.9/drivers/usb/misc/Kconfig	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/misc/Kconfig	2013-05-02 01:47:56.873226803 +0300
@@ -255,4 +255,4 @@ config USB_VST
 	  To compile this driver as a module, choose M here: the
 	  module will be called vstusb.
 
-
+#source "drivers/usb/misc/rts51xx/Kconfig"
--- linux-2.6.30.9/drivers/usb/misc/Makefile	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/misc/Makefile	2013-05-02 01:47:56.873226803 +0300
@@ -26,6 +26,7 @@ obj-$(CONFIG_USB_SEVSEG)	+= usbsevseg.o
 obj-$(CONFIG_USB_VST)		+= vstusb.o
 
 obj-$(CONFIG_USB_SISUSBVGA)	+= sisusbvga/
+#obj-$(CONFIG_RTS5139)		+= rts51xx/
 
 ifeq ($(CONFIG_USB_DEBUG),y)
 EXTRA_CFLAGS += -DDEBUG
--- linux-2.6.30.9/drivers/usb/mon/mon_main.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/mon/mon_main.c	2013-05-02 01:47:56.892226802 +0300
@@ -13,7 +13,12 @@
 #include <linux/mutex.h>
 
 #include "usb_mon.h"
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 
 static void mon_stop(struct mon_bus *mbus);
 static void mon_dissolve(struct mon_bus *mbus, struct usb_bus *ubus);
--- linux-2.6.30.9/drivers/usb/musb/musb_core.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/musb/musb_core.h	2013-05-02 01:47:56.895226802 +0300
@@ -60,7 +60,12 @@ struct musb_ep;
 #include "musb_regs.h"
 
 #include "musb_gadget.h"
+
+#if defined(CONFIG_USB_UWIFI_HOST)
+#include "../core_uWiFi/hcd.h"
+#else
 #include "../core/hcd.h"
+#endif
 #include "musb_host.h"
 
 
--- linux-2.6.30.9/drivers/usb/serial/option.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/serial/option.c	2013-05-02 01:47:56.919226800 +0300
@@ -161,6 +161,7 @@ static int  option_resume(struct usb_ser
 #define HUAWEI_PRODUCT_E143D			0x143D
 #define HUAWEI_PRODUCT_E143E			0x143E
 #define HUAWEI_PRODUCT_E143F			0x143F
+#define HUAWEI_PRODUCT_K4505			0x1464
 
 #define QUANTA_VENDOR_ID			0x0408
 #define QUANTA_PRODUCT_Q101			0xEA02
@@ -297,6 +298,8 @@ static int  option_resume(struct usb_ser
 #define ZTE_PRODUCT_MF628			0x0015
 #define ZTE_PRODUCT_MF626			0x0031
 #define ZTE_PRODUCT_CDMA_TECH			0xfffe
+#define ZTE_PRODUCT_AC8710			0xfff1
+#define ZTE_PRODUCT_AC2726			0xfff5
 
 #define BENQ_VENDOR_ID				0x04a5
 #define BENQ_PRODUCT_H10			0x4068
@@ -304,6 +307,19 @@ static int  option_resume(struct usb_ser
 #define DLINK_VENDOR_ID				0x1186
 #define DLINK_PRODUCT_DWM_652			0x3e04
 
+#define QISDA_VENDOR_ID             0x1da5
+#define QISDA_PRODUCT_H21_4512          0x4512
+#define QISDA_PRODUCT_H21_4523          0x4523
+#define QISDA_PRODUCT_H20_4515          0x4515
+#define QISDA_PRODUCT_H20_4519          0x4519
+
+/* SMPS PRODUCTS */
+#define SMPS_VENDOR_ID              0xfeed
+#define SMPS_PRODUCT_TITAN20            0x1234
+
+/* VIBO */
+#define VIBO_VENDOR_ID				0x1c9e
+#define VIBO_PRODUCT_D200			0x9605
 
 static struct usb_device_id option_ids[] = {
 	{ USB_DEVICE(OPTION_VENDOR_ID, OPTION_PRODUCT_COLT) },
@@ -522,7 +538,25 @@ static struct usb_device_id option_ids[]
 	{ USB_DEVICE(ZTE_VENDOR_ID, ZTE_PRODUCT_CDMA_TECH) },
 	{ USB_DEVICE(BENQ_VENDOR_ID, BENQ_PRODUCT_H10) },
 	{ USB_DEVICE(DLINK_VENDOR_ID, DLINK_PRODUCT_DWM_652) },
-	{ USB_DEVICE(0x1da5, 0x4515) }, /* BenQ H20 */
+
+    /* bruce: for qisda */
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H21_4512) },
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H21_4523) },
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H20_4515) },
+    { USB_DEVICE(QISDA_VENDOR_ID, QISDA_PRODUCT_H20_4519) },
+
+	/* bruce: for ZTE */
+	{ USB_DEVICE_AND_INTERFACE_INFO(ZTE_VENDOR_ID, ZTE_PRODUCT_AC8710, 0xff, 0xff, 0xff) },
+
+    /* mobilepeak */
+    { USB_DEVICE_AND_INTERFACE_INFO(SMPS_VENDOR_ID, SMPS_PRODUCT_TITAN20, 0xff, 0xff, 0xff) },
+
+	/* Huawei*/
+	{ USB_DEVICE_AND_INTERFACE_INFO(HUAWEI_VENDOR_ID, HUAWEI_PRODUCT_K4505, 0xff, 0xff, 0xff) },
+
+	/* vibo */
+    { USB_DEVICE(VIBO_VENDOR_ID, VIBO_PRODUCT_D200) },
+
 	{ } /* Terminating entry */
 };
 MODULE_DEVICE_TABLE(usb, option_ids);
@@ -833,8 +867,9 @@ static void option_instat_callback(struc
 			dbg("%s: type %x req %x", __func__,
 				req_pkt->bRequestType, req_pkt->bRequest);
 		}
-	} else
+	} else {/////TODO
 		err("%s: error %d", __func__, status);
+    }
 
 	/* Resubmit urb so we continue receiving IRQ data */
 	if (status != -ESHUTDOWN && status != -ENOENT) {
--- linux-2.6.30.9/drivers/usb/serial/usb-serial.c	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/serial/usb-serial.c	2013-05-02 01:47:56.923226799 +0300
@@ -35,6 +35,10 @@
 #include <linux/usb/serial.h>
 #include "pl2303.h"
 
+#if CONFIG_USB_SERIAL_OPTION
+#include <linux/smp_lock.h> /* brucehou, 2010/05/21, for lock_kernel & unlock_kernel */
+#endif
+
 /*
  * Version Information
  */
--- linux-2.6.30.9/drivers/usb/storage/unusual_devs.h	2009-10-05 18:38:08.000000000 +0300
+++ linux-2.6.30.9-rsdk/drivers/usb/storage/unusual_devs.h	2013-05-02 01:47:56.933226799 +0300
@@ -1865,6 +1865,13 @@ UNUSUAL_DEV( 0xed10, 0x7636, 0x0001, 0x0
 		"Digital MP3 Audio Player",
 		US_SC_DEVICE, US_PR_DEVICE, NULL, US_FL_NOT_LOCKABLE ),
 
+/* brucehou@RTK for AMOI H01 */
+UNUSUAL_DEV(  0x1614, 0x0800, 0x0000, 0x0000,
+		"Amoi",
+		"Mass Storage",
+		US_SC_DEVICE, US_PR_DEVICE, option_ms_init,
+		0),
+
 /* Control/Bulk transport for all SubClass values */
 USUAL_DEV(US_SC_RBC, US_PR_CB, USB_US_TYPE_STOR),
 USUAL_DEV(US_SC_8020, US_PR_CB, USB_US_TYPE_STOR),
